
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=">
<meta name="GENERATOR" content="Quadralay WebWorks Publisher AutoMap 6.0.7">
<meta name="TEMPLATEBASE" content="CadencePubs_HelpTopics">
<meta name="LASTUPDATED" content="Wed Jul 17 14:09:11 2013">

<script TYPE="text/javascript" LANGUAGE="JavaScript" >
  <!--
  // Dummy script statement to get rid of Netscape timing errors which may
  // print garbage JavaScript code at the top in Unix 4.x Netscape browser.
  // -->
  </script>
                                                                                                                                                                
  <script type="text/javascript" language="JavaScript" src="/Browser.js">
  </script>
                                                                                                                                                                
  <script type="text/javascript" language="JavaScript" src="/Cookies.js">
  </script>
                                                                                                                                                                
  <script type="text/javascript" language="JavaScript" src="/Search.js">
  </script>
                                                                                                                                                                
  <script type="text/javascript" language="JavaScript">
  <!--
  function window_resized(){
    window.location.reload();
  }
  window.onresize=window_resized;
                                                                                                                                                                
  /*
  * Initializes before submitting query
  */
  function initOnSubmit() {
    storeStateAndQuery();
  }
                                                                                                                                                                
  setCookie("DocumentTitle", "Common Power Format Language Reference");
  setCookie("Chapter", "N/A");
  setCookie("Keyword", "search");
  setCookie("Version", "Product Version 2.2");

  // -->
  </script>


<title>Common Power Format Language Reference -- 5. Hierarchical Flow</title>
<META NAME="Approver" CONTENT="Technical Publications">
<META NAME="Author" CONTENT="Technical Publications">
<META NAME="CreateDate" CONTENT="2013-07-17">
<META NAME="CreateTime" CONTENT="1374095377">
<META NAME="DataType" CONTENT="Manuals">
<META NAME="Description" CONTENT="Describes CPF">
<META NAME="DocTitle" CONTENT="Common Power Format Language Reference">
<META NAME="DocType" CONTENT="Manual">
<META NAME="FileTitle" CONTENT="5. Hierarchical Flow">
<META NAME="FileType" CONTENT="Chapter">
<META NAME="Keyword" CONTENT="cpf_ref">
<META NAME="Language" CONTENT="English">
<META NAME="ModifiedDate" CONTENT="2013-07-17">
<META NAME="ModifiedTime" CONTENT="1374095377">
<META NAME="NextFile" CONTENT="rules.html">
<META NAME="PageCount" CONTENT="30">
<META NAME="Platform" CONTENT="ALL">
<META NAME="PrevFile" CONTENT="domains_and_modes.html">
<META NAME="Product" CONTENT="Languages">
<META NAME="ProductFamily" CONTENT="Cadence Shared Tools">
<META NAME="ProductVersion" CONTENT="2.0">
<META NAME="RightsManagement" CONTENT="Copyright 2006 Cadence Design Systems Inc.">
<META NAME="Title" CONTENT="Common Power Format Language Reference -- 5. Hierarchical Flow">
<META NAME="TopicTags" CONTENT="FALSE">
<META NAME="Version" CONTENT="2.0">
</head>

<body bgcolor="#ffffff">
<a name="firstpage"></a>
<a name="pagetop"></a>

<p>
<!-- Begin Buttons -->

<form name="advancedform" action="/vtopic.isapi" method="GET" onSubmit="initOnSubmit()">
<input type=hidden name="action" value="FilterSearch">
<input type=hidden name="Filter" value="altsearchfilter.hts">
<input type=hidden name="resulttemplate" value="altsearchresults.hts">
<input type=hidden name="resultcount" value="10">
<input type=hidden name="resultmaxdocs" value="-1">
<input type=hidden name="queryhidden" value="null">
<input type=hidden name="queryitemselected" value="no">

<table border="0" cellpadding="0" cellspacing="0" width="650">
<tr>
  <td height="36" width="650" colspan="10"><img src="../support/header_doc.gif" WIDTH="650" HEIGHT="36"></td>
</tr>
<tr>
  <td height="20" width="59"><a href="javascript:openLibrary()"><img src="../support/nav2_library.gif" border="0" alt="View Library" height="20" width="59"></a></td>
  <td height="20" width="73"><a href="cpf_refTOC.html"><img src="../support/nav2_toc.gif" border="0" alt="View Table Of Contents" height="20" width="73"></a></td>
  <td height="20" width="46"><a href="cpf_refIX.html"><img src="../support/nav2_index.gif" border="0" alt="View Index for This Manual" height="20" width="46"></a></td>
  <td height="20" width="83"><a href="domains_and_modes.html"><img src="../support/nav2_previous.gif" border="0" alt="View Previous Chapter in Book" height="20" width="83"></a></td>
  <td height="20" width="59"><a href="rules.html"><img src="../support/nav2_next.gif" border="0" alt="View Next Chapter in Book" height="20" width="59"></a></td>
  <td height="20" width="114"><a href="cpf_ref.pdf"><img src="../support/nav2_print.gif" border="0" alt="Open PDF to print book" height="20" width="114"></a></td>
  <td height="20" width="61"><img src="../support/nav2_black.gif" height="20" width="61"></td>
  <td height="20" width="76"><a href="/feedback.htm"><img src="../support/nav2_feedback.gif" border="0" alt="Email Comments" height="20" width="76"></a></td>
  <td height="20" width="43"><a href="../cdsuser/help.html"><img src="../support/nav2_help.gif" border="0" alt="Help Using Documentation" height="20" width="43"></a></td>
  <td height="20" width="37"><a href="/exitsearch.htm"><img src="../support/nav2_exit.gif" border="0" alt="Shut Down Cadence Documentation Server" height="20" width="37"></a></td>
</tr>
 <tr>
    <td colspan="10">
      <script type="text/javascript">
      <!--// We wrap all this inside javascript because we only want to display  -->
      <!--// the search bar if the http server is running. If it is not running  -->
      <!--// the search bar should not be visible to the user                    -->
      <!-- BEGIN SEARCH BAR -->
      var isloaded = isLoaded();
      var enteredquery = getCookie("enteredquery");
      if(enteredquery) {
        enteredquery = enteredquery.replace(/</g,"&lt ");
        enteredquery = enteredquery.replace(/>/g,"&gt ");
      } else {
         enteredquery = "";
      }
                                                                                                                                                                
      <!-- Only display search bar if server is running -->
      if(isloaded) {
                                                                                                                                                                
        display_search_bar(enteredquery);
                                                                                                                                                                
      }
      <!-- END SEARCH BAR -->
      </script>
    </td>
  </tr>
</table>
</form>

<!-- End Buttons -->
<p>
<p>
<hr>
<p>
<h3><center>Common Power Format Language Reference&#0044; Version 2.0</center></h3><br>
<p>


<blockquote>

  
<div align="right">
<h1 align="left">
  <a name="1032955"> </a>5</h1>
</div>

<hr>
<h1>
  <a name="1035250"> </a>Hierarchical Flow</h1>





<ul>
  <a name="1038398"></a><li><p><a href="hier_flow.html#1047397">IP Categories</a></p>

  <a name="1047421"></a><li><p><a href="hier_flow.html#1037345">Power Domain Mapping Concepts</a></p>

  <a name="1043239"></a><li><p><a href="hier_flow.html#1049763">Handling Power Domain Mapping</a></p>

  <a name="1038408"></a><li><p><a href="hier_flow.html#1038703">Handling Domain Attributes after Domain Mapping</a></p>

  <a name="1040820"></a><li><p><a href="hier_flow.html#1040580">Handling Power Modes after Domain Mapping</a></p>

  <a name="1041897"></a><li><p><a href="hier_flow.html#1048886">Modeling a Macro Cell</a></p>
<ul>
  <a name="1046119"> </a><li><p><a href="hier_flow.html#1042472">Modeling the Internal Power Structure of a Macro Cell</a>
</p>

  <a name="1046123"> </a><li><p><a href="hier_flow.html#1046221">Modeling the Internal Power Behavior of a Macro Cell</a>
</p>
</ul>
  <a name="1039738"></a><li><p><a href="hier_flow.html#1038899">CPF Modeling for Hierarchical Design</a></p>

  <a name="1039748"></a><li><p><a href="hier_flow.html#1039735">Handling Boundary Port Domain Definition at Top Level</a></p>

  <a name="1044172"></a><li><p><a href="hier_flow.html#1044080">Power Mode Control Groups</a></p>
</ul>
<br><br><br>
<h2>
  <a name="1037388"> </a>Introduction</h2>


<p>
<strong>Note:&nbsp;</strong>
<a name="1051249"> </a><em>In this context, top-level domain refers to the default power domain of the </em><strong><em>current</em></strong><em> design top. In other words, top-level domain does not necessarily refer to the default power domain of the chip.</em>
</p>

<br><br><br>
<h2>
  <a name="1047397"> </a>IP Categories</h2>


<p>
  <a name="1047416"> </a>In a hierarchical flow, your design can instantiate IPs. CPF distinguishes the following categories:</p>


<p>
  <a name="1047398"> </a>A <strong><em>hard non-custom IP</em></strong> is a block that has been synthesized and placed and routed, but small modifications can still be made. It is also referred to as a <em>hard IP</em>.</p>


<table border="0" cellpadding="0">
<tr>
<td valign="top"><img src=../chars/arrwrite.gif>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a name="1047399"> </a>	 To model a hard IP use the <code>set_design</code> command.</td>
</table>


<p>
  <a name="1049795"> </a>A <strong><em>hard custom IP</em></strong> is a block that is mostly implemented by hand. Custom IP users cannot make any changes to the block and may not have the logical and physical view of the block. Examples are third-party memories. A hard custom IP is also referred to as a <em>custom IP</em> or a <em>macro cell</em>.</p>


<table border="0" cellpadding="0">
<tr>
<td valign="top"><img src=../chars/arrwrite.gif>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a name="1049797"> </a>	 To model a macro cell, use the <a href="reference.html#1339211">set_macro_model</a> command.</td>
</table>

     <dl><dl>
<p>
  <a name="1047406"> </a>For more information, see <a href="hier_flow.html#1048886">Modeling a Macro Cell</a>.</p>

</dl>     </dl>
<p>
  <a name="1047407"> </a>A <strong><em>soft IP</em></strong> is a block that is a design module supplied by a third-party. Users have the full capability to (re-)synthesize and place and route the design. Examples are synthesizable CPU cores, and so on. </p>


<p>
  <a name="1047408"> </a>A soft IP is technology independent. A hard IP (custom or non-custom) is technology dependent. </p>


<table border="0" cellpadding="0">
<tr>
<td valign="top"><img src=../chars/arrwrite.gif>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><a name="1047409"> </a>	 To model a soft IP use the <code>set_design</code> command.</td>
</table>


<p>
  <a name="1047412"> </a>For more information on using an IP in a hierarchical design, refer to <a href="hier_flow.html#1038899">CPF Modeling for Hierarchical Design</a>.</p>


<br><br><br>
<h2>
  <a name="1037345"> </a>Power <a name="Domain Mapping"></a>Domain Mapping Concepts</h2>


<p>
  <a name="1037810"> </a>In a hierarchical design flow, a block can be implemented with a complex power structure. When the block is instantiated at the top level, the power and ground pins of the block must be connected to the power and ground nets of the top-level design. In other cases, designers might want to merge a power domain of a block into another power domain at the top when the block is instantiated at the top. </p>


<p>
  <a name="1037819"> </a><strong><em>Power domain mapping</em></strong> is the operation of merging a power domain of a block with another power domain of the top-level design in which the block is instantiated. </p>


<p>
  <a name="1037820"> </a>Mapping two power domains involves </p>

<ol type="1">
  <li value="1"><p><a name="1037836"> </a>Connecting the primary power and ground pins or nets of the block-level domain to the primary power and ground net of the domain specified at the top level</p>
  <li value="2"><p><a name="1037841"> </a>Merging the elements of the power domain of the block into the top-level domain</p>
  <li value="3"><p><a name="1042315"> </a>Merging the power modes</p>
  <li value="4"><p><a name="1038332"> </a>Resolving the precedence of the power domain settings</p>
  <li value="5"><p><a name="1038337"> </a>Resolving the precedence of the top-level and block-level rules</p>
</ol>

<p>
  <a name="1037842"> </a>Once a block-level power domain is mapped into a top-level power domain, the two power domains are considered identical and all instances of the two domains share the same power characteristics. For example, the standard cell instances of the two power domains will have their primary power and ground pin (follow pins) connected to the same primary power and ground nets.</p>


  <a name="1051054"> </a><table border="0"><tr><td valign="top"><img src="../support/tip.gif"></td><td>A warning will be given if the default block-leveldomain is mapped into a top-level domain which is different from the domain to which the block instance is assigned at the top level. The block-level domain mapping takes precedence. In the following example, instance <code>myFoo</code> is assigned to top-level domain <code>PD1</code>. After power domain mapping, <code>PDX</code>, the default power domain of the block, is mapped to power domain <code>PD2</code> which differs from <code>PD1</code>. </td></table>

     <dl><dl>
<pre><a name="1051055"></a><nobr>create_power_domain -name <code><strong>PD1</strong></code> -instances { i1 <code><strong>myFoo</strong></code> ...} -default<br>create_power_domain -name PD2 ...<br>create_power_domain -name PD3 ...</nobr></pre>

<pre><a name="1051056"></a><nobr>set_instance myFoo -domain_mapping { {<code><strong>PDX PD2</strong></code>} {PDY PD3} }<br>set_design foo<br>create_power_domain -name <code><strong>PDX -default</strong></code> -boundary_ports ...<br>create_power_domain -name PDY -boundary_ports ...<br>end_design foo</nobr></pre>
</dl><dl>
<p>
  <a name="1051057"> </a>The correct way is to not include the macro instance <code>myFoo</code> in the top-level domain specification.</p>

</dl><dl>
<pre><a name="1051058"></a><nobr>create_power_domain -name <code><strong>PD1</strong></code> -instances { i1 ...} -default<br>create_power_domain -name PD2 ...<br>create_power_domain -name PD3 ...</nobr></pre>

<pre><a name="1051059"></a><nobr>set_instance myFoo -domain_mapping { {<code><strong>PDX PD2</strong></code>} {PDY PD3} }<br>set_design foo<br>create_power_domain -name <code><strong>PDX -default</strong></code> -boundary_ports ...<br>create_power_domain -name PDY -boundary_ports ...<br>end_design foo</nobr></pre>
</dl><dl>
<p>
  <a name="1051060"> </a>After domain mapping, macro instance <code>myFoo</code> will be in domain <code>PD2</code>.</p>

</dl>     </dl>


<h4>
  <a name="1037861"> </a>Related commands</h4>


<p>
  <a name="1037866"> </a><a href="reference.html#1267176">set_instance</a></p>


<p>
  <a name="1037867"> </a><a href="reference.html#1267927">set_design</a> and <a href="reference.html#1267835">end_design</a></p>


<p>
  <a name="1049760"> </a><a href="reference.html#1339211">set_macro_model</a> and <a href="reference.html#1339322">end_macro_model</a></p>


<br><br><br>
<h2>
  <a name="1049763"> </a>Handling Power Domain Mapping</h2>


<p>
  <a name="1049770"> </a>If the top-level domain is an unswitched domain, all rules defined for the block-level domain need to be reevaluated for their necessity. For example, any state retention rule without <code>-required</code> option created for the block-level domain should be ignored by tools when the block is integrated into the top-level design. See <a href="rules.html#1035250">Chapter 6, "Precedence and Semantics of the Rules"</a> for more information. </p>


<p>
  <a name="1043353"> </a>On the other hand, if the top-level domain is a switchable domain, the verification tools should check the following requirements to ensure the correct usage of domain mapping:</p>

<ul>
  <a name="1043252"></a><li><p>When both the top-level and block-level domains are specified with a shutoff condition, the shutoff conditions must be structurally equivalent.</p>
<dl>
<p>
  <a name="1043386"> </a>Two CPF Boolean expressions are<a name="structurally"></a> <strong><em>structurally equivalent </em></strong>if </p>

</dl>  <ol type="a">
    <li value="1"><p><a name="1043387"> </a>Each pin in the first expression is electrically connected to a pin or its equivalent control pin in the second expression. </p><dl>
<p>
  <a name="1043391"> </a>See also <a href="reference.html#1342696">set_equivalent_control_pins</a>.</p>

</dl>    <li value="2"><p><a name="1043409"> </a>The two expressions become identical if each pin in the first expression is replaced with its corresponding pin in the second expression.</p>  </ol>

  <a name="1043413"></a><li><p>If the block-level domain is an on-chip controlled external switchable domain with base domains, the number of base domains for the block-level domain must correspond to the number of base domains for the top-level domain. In addition, each base domain of the block-level domain must map to a unique base domain of the top-level domain.</p>
</ul>
<p>
  <a name="1043500"> </a>An unswitched block-level domain can be mapped into any unswitched top-level domain. However, mapping an unswitched block-level domain into a switchable top-level domain may cause functional failure depending on the actual design of the block. As a result, the verification tools should issue warnings when this occurs. In this case, the block-level domain either inherits the top-level rules completely or just the control conditions. See <a href="rules.html#1035250">Chapter 6, "Precedence and Semantics of the Rules"</a> on handling hierarchical rules and isolation and retention rules without conditions for this case.</p>


<p>
  <a name="1046496"> </a>A block-level internal switchable domain can only be mapped into a top-level domain if the following conditions are met:</p>

<ul>
  <a name="1046504"></a><li><p>The top-level domain must be either internal switchable or an unswitched virtual power domain.</p>

  <a name="1046508"></a><li><p>Both the top-level and block-level domain must have exactly one base domain specified.</p>

  <a name="1046513"></a><li><p>The base domain of the block-level domain must also be mapped into the base domain of the top-level domain.</p>

  <a name="1046519"></a><li><p>The domain shutoff conditions of the top-level and block-level domain must be structurally equivalent.</p>
</ul>
<br><br><br>
<h2>
  <a name="1038703"> </a>Handling <a name="Domain Attributes"></a>Domain Attributes after Domain Mapping </h2>


<p>
<strong>Note:&nbsp;</strong>
<a name="1038704"> </a>In this section, any options specified with either the <a href="reference.html#1492744">create_power_domain</a> or <a href="reference.html#1253528">update_power_domain</a> command are referred to as <em>domain attributes</em>.
</p>

<p>
  <a name="1040498"> </a>Once a block-level domain is mapped into a top-level domain, the following precedence rules determine how the block-level domain attributes should be evaluated with respect to the settings of the top-level domain: </p>

<ul>
  <a name="1038004"></a><li><p><code>-default_restore_edge/-default_save_edge/-default_restore_level/<br>-default_save_level/-default_isolation_condition</code>: </p>
<dl>
<p>
  <a name="1049810"> </a>Block-level default conditions always overwrite the top-level default conditions. The top-level default condition will be used if the block-level default condition is missing.</p>

</dl>
  <a name="1049813"></a><li><p><code>-power_down_states/-power_up_states/-transition_slope/<br>-transition_cycles/-transition_latency/-pmos_bias_net/<br>-nmos_bias_net</code>:</p>
<dl>
<p>
  <a name="1038767"> </a>The settings of the top-level domain precede any settings of the block-level domain. If the top-level domain has no setting, then the default settings will apply. For example, <code>-power_up_states</code> applies to all non-retention type registers, flops, or latches of the domain.</p>

</dl>
  <a name="1038008"></a><li><p><code>-boundary_ports</code>: </p>
<dl>
<p>
  <a name="1040825"> </a>If the CPF model is a macro model or a design specified with the <code>-honor_boundary_port_domain</code> option, its boundary ports should be merged into the top-level domain definition. Otherwise, the boundary port association should be ignored.</p>

</dl>
  <a name="1038011"></a><li><p><code>-user_attributes</code>: </p>
<dl>
<p>
  <a name="1038808"> </a>The settings of both domains should be merged together. The top-level domain should contain the attributes from both power domains.</p>

</dl></ul>
<br><br><br>
<h2>
  <a name="1040580"> </a>Handling <a name="Power Modes"></a>Power Modes after Domain Mapping</h2>


<p>
  <a name="1040609"> </a>A block-level power mode can be merged into the top-level power modes in one of the following ways:</p>

<ul>
  <a name="1040611"></a><li><p>All block-level domains are mapped into top-level domains</p>
<dl>
<p>
  <a name="1044068"> </a>In this case, the top-level mode definitions become the current design power modes after the domain mapping. </p>


<p>
  <a name="1044069"> </a>Verification tools should flag any inconsistency between the block-level power mode definitions and the top-level power mode definitions. They should give</p>

</dl><ul>
  <a name="1048799"> </a><li><p>An error message if a power mode at the top level does not match any 
corresponding modes at the block level before mapping. 
</p>
<dl>
<p>
  <a name="1052423"> </a>Such a scenario could indicate that an IP is used in a wrong way.</p>

</dl>
  <a name="1044074"> </a><li><p>A warning if a power mode at the block level does not match any power mode at the 
top level. 
</p>
<dl>
<p>
  <a name="1052424"> </a>This can indicate that some configuration of the IP may not be used at the chip level.</p>

</dl></ul><dl>
<p>
  <a name="1040660"> </a>For example, during domain mapping, if a block-level domain is on in all power mode definitions, the corresponding top-level power domain must not be off in any top-level power mode definitions except when all other lower scope domains are off as well.</p>

</dl><dl>
<p>
<strong>Note:&nbsp;</strong>
<a name="1048866"> </a>For each scope, an implicit power mode definition exists where all power domains at that scope are operating in the off state. For more information, see <a href="domains_and_modes.html#1044136">Modes</a>.
</p>

</dl>
  <a name="1048777"></a><li><p>One or more block-level domains are not mapped into a top-level domain </p>
<dl>
<p>
  <a name="1048881"> </a>These block-level domains become power domains visible at the top-level, and they can be referenced using the hierarchical name for the domains. </p>


<p>
  <a name="1048894"> </a>The top-level power mode definition can refer to these block-level domains </p>

</dl><ul>
  <a name="1048900"> </a><li><p>Directly in the domain condition specification
</p>
<dl>
<p>
  <a name="1049631"> </a>For more information on how to name a power domain in a different scope, refer to <a href="structure.html#1119283">Referencing CPF Objects</a>.</p>

</dl>
  <a name="1048903"> </a><li><p>By referencing a block-level mode (that involves these domains) using the power 
mode control group definitions
</p>
<dl>
<p>
  <a name="1048909"> </a>See <a href="hier_flow.html#1044080">Power Mode Control Groups</a> for details. </p>

</dl></ul></ul>
<br><br><br>
<h2>
  <a name="1051065"> </a>Handling of Initial Statements</h2>


<p>
  <a name="1051066"> </a>Initial statements are non-synthesizable code used in simulation to create proper startup conditions at time zero of the simulation. </p>


<p>
  <a name="1051067"> </a>To specify the immediate action to be taken when the power is restored to power domains, you can use the <a href="reference.html#1470675">set_sim_control</a> command. </p>


<p>
  <a name="1051071"> </a>You can specify this command in a block-level CPF. It is equivalent to a command at the top level with the <code>-instances</code> or <code>-domain</code> options to restrict the target selection. For example:</p>




<h4>
  <a name="1051072"> </a>Case 1</h4>


<p>
  <a name="1051073"> </a>Consider the following block level command in block <code>foo</code>: </p>


<pre><a name="1051074"></a><nobr>set_sim_control -target initial1 </nobr></pre>

<p>
  <a name="1051075"> </a>The top-level equivalent command will be:</p>


<pre><a name="1051076"></a><nobr>set_sim_control -target initial1 -instances foo </nobr></pre>



<h4>
  <a name="1051077"> </a>Case 2</h4>


<p>
  <a name="1051078"> </a>Consider the following block level command in block <code>foo</code>: </p>


<pre><a name="1051079"></a><nobr>set_sim_control -target initial1 -domain X</nobr></pre>

<p>
  <a name="1051080"> </a>If the block-level domain <code>X</code> cannot be mapped to any top-level domain, the top-level equivalent command will be:</p>


<pre><a name="1051081"></a><nobr>set_sim_control -target initial1 -domain foo/X</nobr></pre>



<h4>
  <a name="1051082"> </a>Case 3: </h4>


<p>
  <a name="1051083"> </a>Consider the following block level command: </p>


<pre><a name="1051084"></a><nobr>set_sim_control -target initial1 -instances {i1 i2 ...}</nobr></pre>

<p>
  <a name="1051085"> </a>The top-level equivalent command will be:</p>


<pre><a name="1051086"></a><nobr>set_sim_control -target initial1 -instances {foo/i1 foo/i2 ...}</nobr></pre>

<br><br><br>
<h2>
  <a name="1048886"> </a><a name="Modeling"></a>Modeling a <a name="Macro Cell"></a>Macro Cell</h2>


<p>
  <a name="1042486"> </a>Proper modeling of macro cells (such as a RAM) with complex power network is important because it serves as a specification for the </p>

<ul>
  <a name="1042487"></a><li><p>Implementation tool to properly hook up the power and ground pins of the IP at the top level</p>

  <a name="1042488"></a><li><p>Verification tool to check for consistency between the implementation and the constraints specified in the CPF.</p>

  <a name="1042489"></a><li><p>Simulation tool to verify the behavior</p>
</ul>
<p>
  <a name="1047333"> </a>When a macro cell has only a non-power-aware behavioral model to describe its functionality, implementation and verification tools have to rely on the CPF modeling of the internal power network using the boundary ports.</p>


<p>
  <a name="1050502"> </a>When you assign a boundary port of a macro cell to a power domain, it is implied that the logic inside the macro cell connected to this port is powered by the power supply of this domain.</p>


<br><br>
<h3>
  <a name="1042472"> </a>Modeling the Internal Power Structure of a Macro Cell</h3>


<p>
  <a name="1041744"> </a>The design in Figure <a href="hier_flow.html#1041746">5-1</a> contains a macro cell, <code>BlockA</code>, at the SoC level. This section describes how to model the internal power behavior of this macro cell in CPF.</p>


  <a name="1041746"> </a><h4>
Figure 5-1   Block diagram of Design SoC</h4>


<p>
  <a name="1041750"> </a><img src="images/schematicSoC.gif">
</p>


<p>
  <a name="1041754"> </a><a href="hier_flow.html#1041759">Figure 5-2</a> shows a more detailed view of cell <code>cellA</code> of which <code>BlockA</code> is an instantiation.</p>


<p>
  <a name="1041755"> </a>In case of a macro cell, only the (boundary) input and output pins of the cell are visible to the outside world. </p>


<p>
  <a name="1041756"> </a>In <code>cellA</code>, the power shutoff is implemented with power switches that are part of the macro cell. As a result, the control ports for the power switches are part of the boundary port definitions.</p>


  <a name="1041759"> </a><h4>
Figure 5-2   Macro Cell cellA </h4>


<p>
  <a name="1041763"> </a><img src="images/macro.gif">
</p>


<p>
  <a name="1041764"> </a>To describe the internal power structure of a macro cell, the concept of a CPF <em>macro model</em> is introduced. <a href="hier_flow.html#1041769">Figure 5-3</a> shows the corresponding CPF to describe this IP cell.</p>


  <a name="1041769"> </a><h4>
Figure 5-3   CPF file CellA.cpf for Macro Cell CellA</h4>


<pre><a name="1041770"></a><nobr>set_macro_model CellA</nobr></pre>

<pre><a name="1041771"></a><nobr>create_power_domain -name PD1 -default -boundary_ports { psw[0]}<br>create_power_domain -name PD2 -boundary_ports { psw[1]}</nobr></pre>

<pre><a name="1047734"></a><nobr>create_power_domain -name PD1_SW -boundary_ports {M X}  \<br>-shutoff_condition { !psw[0] } &nbsp;-base_domains PD1 </nobr></pre>

<pre><a name="1047735"></a><nobr>create_power_domain  -name PD2_SW -boundary_ports {Y N} \<br>-shutoff_condition { !psw[1] } -base_domains PD2</nobr></pre>

<pre><a name="1041774"></a><nobr>update_power_domain -name PD1 -primary_power_net VDD1 -primary_ground_net VSS1<br>update_power_domain -name PD2 -primary_power_net VDD2 -primary_ground_net VSS1</nobr></pre>

<pre><a name="1041775"></a><nobr>end_macro_model</nobr></pre>

<p>
  <a name="1041776"> </a>The definition of a macro model starts with a <code>set_macro_model</code> command that specifies the name of the library cell that represents the macro cell. The definition ends with an <code>end_macro_model</code> command. These commands delimit the scope of a macro model description.</p>


<p>
  <a name="1041777"> </a>All commands between <code>set_macro_model</code> and <code>end_macro_model</code> describe the internal implementation of the macro cell. </p>


<p>
  <a name="1041778"> </a>Most power domains in the macro model are virtual power domains. The pins specified with the <code>-boundary_ports</code> option of the <code>create_power_domain</code> command are either input or output pins of the macro cell. The boundary ports belong to the specified domain. If the pin is an input pin, the power domain driven by the pin is the specified domain. If the pin is an output pin, the domain driving the pin is the specified power domain. </p>


<p>
  <a name="1041793"> </a>The CPF in <a href="hier_flow.html#1041769">Figure 5-3</a> contains the following power structure information of the macro cell: </p>

<ul>
  <a name="1041794"></a><li><p>The macro cell has two unswitched power domains, <code>PD1</code> and <code>PD2</code>. The corresponding <code>update_power_domain</code> command specify the external power and ground ports of the domain using the <code>-primary_power_net </code>and <code>-primary_ground_net</code> options.</p>

  <a name="1041795"></a><li><p>The macro cell has two internal switchable power domains, <code>PD1_SW</code> and <code>PD2_SW</code>. </p>
<dl>
<p>
  <a name="1041796"> </a>Even though domain <code>PD1_SW</code> is powered down using a power (header) switch, while domain <code>PD2_SW </code>can be powered down using a ground (footer) switch, from a modeling point of view, both domains are modeled the same way.</p>


<p>
  <a name="1041797"> </a>Both are modeled with an explicit base domain specification. Referring to the <code>update_power_domain</code> commands of the base domains, the definition clearly describes the external power and ground ports of power domains <code>PD1_SW</code> and <code>PD2_SW</code>. </p>

</dl>
  <a name="1041798"></a><li><p>Output pin <code>X</code> of the macro cell is driven by a signal from power domain <code>PD1_SW,</code> which is switchable. As a result, proper isolation logic is required at the top-level of the design when the macro cell is instantiated.</p>

  <a name="1041799"></a><li><p>Output pin <code>Y</code> of the macro cell is driven by a signal from power domain <code>PD2_SW,</code> which is also switchable. As a result, proper isolation logic is required when the macro cell is instantiated.</p>
</ul>
<p>
  <a name="1042438"> </a>At the top-level CPF a CPF macro model can be inferred using one of the following methods:</p>

<ul>
  <a name="1042442"></a><li><p>Use the <a href="reference.html#1267176">set_instance</a> command without the <code>-model</code> option, and follow the command with the CPF specification of the macro cell as shown in see <a href="hier_flow.html#1041801">Figure 5-4</a>. </p>

  <a name="1042446"></a><li><p>First load the CPF specification of the macro cell, then use the <code>set_instance</code> command with the <code>-model</code> option to reference the CPF macro model as shown in <a href="hier_flow.html#1049787">Figure 5-5</a>.</p>
</ul>
<p>
  <a name="1042447"> </a>The specified instance must be an instantiation of the cell specified by <code>set_macro_model</code>.</p>


  <a name="1041801"> </a><h4>
Figure 5-4   Chip-Level CPF inferring macro cell CellA (method 1)</h4>


<pre><a name="1041802"></a><nobr>set_design SoC </nobr></pre>

<pre><a name="1041803"></a><nobr>create_power_domain -name PDA -default <br>create_power_domain -name PDB -instances BlockB<br>create_power_domain -name PDB_SW -instances BlockC -shutoff_condition { !psw3} </nobr></pre>

<pre><a name="1041805"></a><nobr>create_isolation_rule -name iso1 -from PDB_SW  -isolation_enable iso_en </nobr></pre>

<pre><a name="1041806"></a><nobr>set_instance BlockA -domain_mapping {{PD1 PDA} {PD2 PDB}} </nobr></pre>

<pre><a name="1041807"></a><nobr><code><strong>include CellA.cpf</strong></code> </nobr></pre>

<pre><a name="1049785"></a><nobr>end_design</nobr></pre>

  <a name="1049787"> </a><h4>
Figure 5-5   Chip-Level CPF inferring macro cell CellA (method 2)</h4>


<pre><a name="1049788"></a><nobr><code><strong>include CellA.cpf</strong></code> </nobr></pre>

<pre><a name="1041811"></a><nobr>set_design SoC </nobr></pre>

<pre><a name="1041812"></a><nobr>create_power_domain -name PDA -default <br>create_power_domain -name PDB -instances BlockB<br>create_power_domain -name PDB_SW  -instances BlockC -shutoff_condition { !psw3} </nobr></pre>

<pre><a name="1041814"></a><nobr>create_isolation_rule -name iso1 -from PDB_SW  -isolation_enable iso_en </nobr></pre>

<pre><a name="1041815"></a><nobr>set_instance BlockA <code><strong>-model CellA</strong></code> -domain_mapping {{PD1 PDA} {PD2 PDB}} </nobr></pre>

<pre><a name="1041816"></a><nobr>end_design</nobr></pre>

<p>
  <a name="1046176"> </a>In the scenario shown in <a href="hier_flow.html#1046190">Figure 5-6</a>, the macro cell has some internal logic to control the power domains inside the macro cell. As a result, some required interface logic such as isolation logic may already be inserted in the macro cell. For example, output port <code>X</code> is already properly isolated in the macro cell. Consequently, the CPF in <a href="hier_flow.html#1041769">Figure 5-3</a> needs to be modified slightly to reflect the fact that output pin X is already isolated. The CPF for the macro cell in Figure <a href="hier_flow.html#1046190">5-6</a> is shown in <a href="hier_flow.html#1046199">Figure 5-7</a>.</p>


  <a name="1046190"> </a><h4>
Figure 5-6   Macro Cell in Figure <a href="hier_flow.html#1041759">5-2</a> where all external ports are properly isolated</h4>


<p>
  <a name="1046194"> </a><img src="images/macro_variation.gif">
</p>


  <a name="1046199"> </a><h4>
Figure 5-7   CPF for the Macro Cell in Figure <a href="hier_flow.html#1046190">5-6</a> with output pins already isolated within the Macro Cell</h4>


<pre><a name="1046200"></a><nobr>set_macro_model CellA </nobr></pre>

<pre><a name="1046201"></a><nobr>create_power_domain -name PD1 -default -boundary_ports { X {psw[0]} iso_en} create_power_domain -name PD2 -boundary_ports { psw[1]}</nobr></pre>

<pre><a name="1046202"></a><nobr>create_power_domain -name PD1_SW -boundary_ports {M}  \<br>-shutoff_condition { !psw[0] } &nbsp;-base_domains PD1 </nobr></pre>

<pre><a name="1046203"></a><nobr>create_power_domain  -name PD2_SW -boundary_ports {Y N} \<br>-shutoff_condition { !psw[1] } -base_domains PD2</nobr></pre>

<pre><a name="1046204"></a><nobr>update_power_domain -name PD1 -primary_power_net VDD1 -primary_ground_net VSS1<br>update_power_domain -name PD2 -primary_power_net VDD2 -primary_ground_net VSS1</nobr></pre>

<pre><a name="1046205"></a><nobr>create_isolation_rule -name iso -pins X -from PD1_SW \<br>-isolation_condition iso_en -isolation_output low</nobr></pre>

<pre><a name="1046206"></a><nobr>end_macro_model</nobr></pre>

<p>
  <a name="1046213"> </a>Comparing Figure <a href="hier_flow.html#1046199">5-7</a> with <a href="hier_flow.html#1046190">5-6</a>, the new CPF describes that pin <code>X</code> now belong to the unswitched domain <code>PD1</code> because pin X is already isolated to low when <code>iso_en</code> is <code>1</code>. Note that all commands between <code>set_macro_model</code> and <code>end_macro_model</code> are only for documenting purpose since they describe a macro cell. The <code>create_isolation_rule</code> command specifies that pin X of the macro cell is <em>already</em> isolated. After applying the same chip level CPF (see Figure <a href="hier_flow.html#1041801">5-4</a>), all implementation information is there. There is no need for isolation from pin X to <code>BlockB</code> since both domains that drive X and the domain of <code>BlockB</code> are unswitched.</p>


<p>
<strong>Note:&nbsp;</strong>
<a name="1051157"> </a>A complete isolation rule in a macro cell describes the isolation logic implemented inside the macro cell. Consequently, this isolation logic must be modeled explicitly in the behavioral model of the macro cell. An incomplete isolation rule (a rule with neither <code>-isolation_condition</code> nor <code>-no_condition</code>) specified for the input of a macro model indicates the required isolation value when the power domain that drives the port is powered down. 
</p>

<br><br>
<h3>
  <a name="1046221"> </a>Modeling the Internal Power Behavior of a Macro Cell</h3>


<p>
  <a name="1046223"> </a>The behavioral simulation model of a macro cell may not have any logical hierarchy. In this case, the methodology to create power domains following logical hierarchies does not work. To enable verification of such macro cells, the IP designer must use the following approach:</p>

<ol type="1">
  <li value="1"><p><a name="1046224"> </a>Within the scope of a macro model definition, create a power domain with registers only.</p>
  <li value="2"><p><a name="1046225"> </a>Create a default domain that is unswitched. </p>
  <li value="3"><p><a name="1046226"> </a>Create all necessary domains to model the switchable power domains and only list registers in the behavioral model as its members. </p>
  <li value="4"><p><a name="1046227"> </a>Associate the primary inputs and outputs of the IP with the proper power domains depending on the logic it connects to or is driven by. </p>
<dl>
<p>
<strong>Note:&nbsp;</strong>
<a name="1046228"> </a>The association of an input or output port with a power domain depends on the logic connected to the ports. For example, if the IP has primary output ports driven by logic that will be powered down, the ports should be assigned to that power domain and the outputs will be asserted X when the domain is down. However, if the port is isolated, the port should be assigned to the secondary power domain of the isolation instance.
</p>

</dl></ol>

<p>
  <a name="1046229"> </a>To support this modeling technique, the simulation tools must inject an X and the emulation tools should use the value specified for the <code>-power_down_states</code> option at the following ports when a power domain is powered down:</p>

<ul>
  <a name="1046230"></a><li><p>Associated primary input ports</p>

  <a name="1046231"></a><li><p>Associated output ports that have no isolation rules associated with them</p>

  <a name="1046232"></a><li><p>Outputs of registers in the domain that are not part of any retention rules </p>
</ul>
  <a name="1046233"> </a><table border="0"><tr><td valign="top"><img src="../support/important.gif"></td><td>The power down behavior of non-register logic is simulated by injecting X at primary inputs and unisolated outputs. Injecting X at unisolated outputs is needed because X may not be able to propagate if there is a controlling signal at some logic. For example, if <code>y = a|b</code>, <code>y</code> will not be <code>x</code> when <code>a</code> is <code>1</code> and <code>b</code> is <code>x</code>. The power down behavior of registers is simulated directly by associating them with the proper power domains.</td></table>


<h4>  <a name="1046234"> </a><i>Exceptions</i>
</h4>


<p>
  <a name="1046235"> </a>The above approach will not work when a primary input port fans out to multiple power domains with different switching behavior. In this case, the input port should be treated as always on during simulation. However, to accurately model such a macro cell, it is recommended to make their behavioral model CPF compliant by creating a module hierarchy based on the power domain partitions.</p>




<h4>
  <a name="1046236"> </a>Example</h4>


<p>
  <a name="1046237"> </a>Using the macro cell modeling technique, CPF can model complex multi-rail RAM. Lets consider a RAM macro cell with three power rails. One power rail <code>VDD_MAIN</code> is used for peripheral logic such as address encoder/decoder. The second power rail <code>VDD_ARRAY</code> is used for the memory array. The third power rail <code>VDD_AO</code> is used for the rest of the logic and it is always on. The peripheral logic has an internal power switch which can shut off the power supply to the peripheral logic when <code>CE</code> is low. The power net for the array is external switchable. The following CPF describes the RAM model.</p>


  <a name="1046238"> </a><h4>
Figure 5-8   RAM Model with Internal Power Switch</h4>


<pre><a name="1046239"></a><nobr>set_macro_model RAM</nobr></pre>

<pre><a name="1046240"></a><nobr>create_power_domain -name PD1 -boundary_ports {...} -shutoff_condition !CE \<br>-base_domains PD3</nobr></pre>

<pre><a name="1046241"></a><nobr>create_power_switch_rule -name sw1 -domain PD1 -external_power_net VDD_AO</nobr></pre>

<pre><a name="1046242"></a><nobr>create_power_domain -name PD2 -boundary_ports {...} <code><strong>-instances mem*</strong></code> \<br>create_power_domain -name PD3 -boundary_ports {...} -default</nobr></pre>

<pre><a name="1046243"></a><nobr>update_power_domain -name PD1 -primary_power_net VDD_MAIN \<br>-primary_ground_net VSS</nobr></pre>

<pre><a name="1046244"></a><nobr>update_power_domain -name PD2 -primary_power_net VDD_ARRAY \<br>-primary_ground_net VSS</nobr></pre>

<pre><a name="1046245"></a><nobr>update_power_domain -name PD3 -primary_power_net VDD_AO \<br>-primary_ground_net VSS</nobr></pre>

<pre><a name="1050448"></a><nobr>create_nominal_condition -name on -voltage 1.0 -state on</nobr></pre>

<pre><a name="1050449"></a><nobr>create_nominal_condition -name off -voltage 0 -state off</nobr></pre>

<pre><a name="1050450"></a><nobr>create_power_mode -name all_on -domain_conditions { PD1@on PD2@on PD3@on} -default</nobr></pre>

<pre><a name="1050451"></a><nobr>create_power_mode -name drowsy -domain_conditions { PD1@on PD2@off PD3@on} </nobr></pre>

<pre><a name="1046246"></a><nobr>create_power_mode -name sleep -domain_conditions { PD1@off PD2@off PD3@on}</nobr></pre>

<pre><a name="1050457"></a><nobr>end_macro_model</nobr></pre>

<p>
  <a name="1050459"> </a><code>mem</code>* are the registers in the memory array in the simulation model. Power domain <code>PD2</code> is an unswitched domain at the block level, but the macro model specification (power mode <code>drowsy</code> and <code>sleep</code>) indicates that it can be switched off externally. <code>PD2</code> is mapped into a top-level switchable domain when the macro cell is instantiated as shown in Figure <a href="hier_flow.html#1046252">5-9</a>.</p>


  <a name="1046252"> </a><h4>
Figure 5-9   Top Level Instantiation of RAM Can Map Domains in RAM to Any Top-Level Domain</h4>


<pre><a name="1046253"></a><nobr>include RAM.cpf</nobr></pre>

<pre><a name="1046254"></a><nobr>set_design top</nobr></pre>

<pre><a name="1046255"></a><nobr>create_power_domain -name PD_VDDA -default<br>create_power_domain -name PD_VDDB -instances {BlockB}<br>create_power_domain -name PD_VDDB_SW -instances {BlockC} \<br>-shutoff_condition { !psw3}</nobr></pre>

<pre><a name="1046256"></a><nobr>set_instance iRAM -model RAM -domain_mapping {{PD2 PD_VDDB_SW} {PD3 PD_VDDA}}</nobr></pre>

<pre><a name="1046257"></a><nobr>end_design</nobr></pre>

<p>
<strong>Note:&nbsp;</strong>
<a name="1046258"> </a>Above CPF can also be used for the testbench module so the array power down behavior can be simulated and verified.
</p>

<br><br><br>
<h2>
  <a name="1038899"> </a><a name="CPF Modeling"></a>CPF Modeling for Hierarchical Design</h2>


<p>
  <a name="1039384"> </a>In a hierarchical design flow, a block (soft IP, hard IP or custom IP) can have a separate CPF file to describe its power intent. The block level CPF is referred to as <strong><em>CPF model </em></strong>for the block. A CPF model is either a power design model or a macro model.</p>


<p>
  <a name="1051174"> </a>In CPF, a CPF model can be instantiated in a design in one of the following ways:</p>

<ul>
  <a name="1039385"></a><li><p>First use the <a href="reference.html#1339372">include</a> command to load the CPF specification, then use the <a href="reference.html#1267176">set_instance</a> command with the</p>
<ul>
  <a name="1039422"> </a><li><p><code>-model</code> option to reference a CPF model for a macro cell instance (custom IP) 
</p>

  <a name="1039433"> </a><li><p><code>-design</code> option to reference a CPF power design model for a module (hard or soft 
IP instance) (see <a href="hier_flow.html#1044417">Example&nbsp;5-1</a>)
</p>
</ul><dl>
<p>
  <a name="1042583"> </a>A <code>set_instance</code> command specified with an instance name with a <code>-design</code> or <code>-model</code> option will not cause a scope change after the command is executed.</p>

</dl>
  <a name="1039232"></a><li><p>Use the <code>set_instance</code> command without either of the above options, and follow the command by either the <a href="reference.html#1267927">set_design</a> or <a href="reference.html#1339211">set_macro_model</a> command. Some commands are allowed between <code>set_instance</code> and <code>set_design</code> or <code>set_macro_model</code>. See the commands shown in the <a href="structure.html#1132349">Command Dependency</a> table before <code>set_design</code>.</p>
<dl>
<p>
  <a name="1042570"> </a>In this case (see <a href="hier_flow.html#1039680">Example&nbsp;5-2</a>) the following steps will occur:</p>

</dl>  <ol type="a">
    <li value="1"><p><a name="1042571"> </a>The scope will be changed to the specified instance.</p>    <li value="2"><p><a name="1042572"> </a>The commands between the next <code>set_design</code> and <code>end_design</code> pair or <code>set_macro_model</code> and <code>end_macro_model</code> pair will be loaded and applied to the specified instance.</p>    <li value="3"><p><a name="1042573"> </a>The scope will be reset to the scope prior to the <code>set_instance</code> command after the <code>end_design</code> or <code>end_macro_model</code> command.</p>  </ol>
</ul>
<p>
  <a name="1044457"> </a>The same CPF model can be bound to multiple instances using <code>set_instance</code> with the <code>-design</code> or <code>-mode</code>l options. By default, a CPF model can be bound to any instance of any module (if defined with <code>set_design</code>) or macro cell (if defined with <code>set_macro_model</code>). If the CPF model definition specifies module (using <code>set_design -modules</code>) or cell names (using <code>set_macro_model -cells</code>), then only instantiations of modules or macro cells whose names match those in the definitions can be bound.</p>


<p>
  <a name="1052791"> </a>Power design definitions are scope sensitive.</p>

<ul>
  <a name="1052796"></a><li><p>It is legal to have CPF models created with the same name in different scopes.</p>

  <a name="1052808"></a><li><p>If multiple power designs are created with the same name in the same scope, the first definition will be used and all other definitions will be ignored (see <a href="hier_flow.html#1043827">Example&nbsp;5-4</a> and <a href="hier_flow.html#1052570">Example&nbsp;5-8</a>). </p>
<dl>
<p>
<strong>Note:&nbsp;</strong>
<a name="1045233"> </a>In CPF 1.1, the power intent was appended using additional <code>set_design</code> commands with the same name in the same scope. In CPF 2.0, this is accomplished using the <a href="reference.html#1477410">update_design</a> command.
</p>

</dl></ul>
<p>
  <a name="1052930"> </a>Macro model definitions are <strong>not</strong> scope sensitive.</p>

<ul>
  <a name="1052932"></a><li><p>If multiple macro cell models are created with the same name, the first definition will be used and all other definitions will be ignored (see <a href="hier_flow.html#1045253">Example&nbsp;5-3</a>). </p>
</ul>
<p>
  <a name="1045313"> </a>The power intent specified by update_design shall be treated as part of the original power design specification and be applied to all set_instance commands that use this power design model, including the set_instance commands that precede update_design (see <a href="hier_flow.html#1052533">Example&nbsp;5-7</a>).</p>


  <a name="1052850"> </a><table border="0"><tr><td valign="top"><img src="../support/tip.gif"></td><td>To prevent warnings in environments where the same CPF file might get included multiple times, coding techniques such as the use of Tcl <code>if</code> constructs and environment variables can be used to prevent duplicate CPF model definitions.</td></table>


<p>
  <a name="1052839"> </a>In the following examples, assume <code>foo</code> is a power design for a Verilog module instantiated as <code>I1</code>, <code>I2</code>, and <code>I3</code> in RTL. After synthesis uniquifies the module, the module name for I1, I2 and I3 may no longer be <code>foo</code>.</p>


  <a name="1044417"> </a><h4>
Example 5-1   </h4>


<pre><a name="1039342"></a><nobr>set_design foo ;# model 1 for foo<br>...<br>end_design</nobr></pre>

<pre><a name="1039349"></a><nobr>set_instance I1 -design foo -domain_mapping ...<br>set_instance I2 -design foo -domain_mapping ...</nobr></pre>

<p>
  <a name="1039365"> </a><code>I1</code> and <code>I2</code> will be bound to the power design model foo. </p>


  <a name="1039680"> </a><h4>
Example 5-2   </h4>


<pre><a name="1039685"></a><nobr>set_design foo ;# model 1 for foo<br>...<br>end_design<br>set_instance I1 -design foo -domain_mapping ...<br>set_instance I2 -domain_mapping ...<br>set_design foo ;# model 2 for foo<br>...<br>end_design<br>set_instance I3 -design foo -domain_mapping ...</nobr></pre>

<p>
  <a name="1044425"> </a><code>I1</code> and <code>I3</code> will be bound to the first model of <code>foo</code>, while <code>I2</code> will be bound to the second model. In this case, the second definition of <code>foo</code> belongs to the scope of I2.</p>


  <a name="1045253"> </a><h4>
Example 5-3   </h4>


<pre><a name="1045361"></a><nobr>set_macro_model foo ;# model 1 for foo<br>...<br>end_macro_model<br>set_macro_model foo ;# model 2 for foo<br>...<br>end_macro_model<br>set_instance I1 -model foo -domain_mapping ...</nobr></pre>

<p>
  <a name="1045263"> </a><code>I1</code> will be bound to the first CPF macro model for foo. The second macro model is ignored and a warning will be issued.</p>


  <a name="1043827"> </a><h4>
Example 5-4   </h4>


<pre><a name="1043832"></a><nobr>set_design foo ;# first definition of model foo<br>create_power_domain -name PD1 -default<br>...<br>end_design<br>set_design foo ;# second definition of model foo<br>update_power_domain -name PD1 -primary_power_net VDD1<br>...<br>end_design<br>set_instance I1 -design foo -domain_mapping ...</nobr></pre>

<p>
  <a name="1052481"> </a><code>I1</code> is linked to the first model for <code>foo</code>. The second model for <code>foo</code> is ignored and a warning is issued.</p>


<p>
<strong>Note:&nbsp;</strong>
<a name="1052482"> </a>In CPF1.1, when the <a href="reference.html#1477410">update_design</a> command did not exist, the second model of <code>foo</code> would have been appended to the first.
</p>

  <a name="1052495"> </a><h4>
Example 5-5   </h4>


<pre><a name="1052496"></a><nobr>set_design foo ;# first definition of model foo<br>create_power_domain -name PD1 -default<br>...<br>end_design<br>update_design foo ;# append to definition of model foo<br>update_power_domain -name PD1 -primary_power_net VDD1<br>...<br>end_design<br>set_instance I1 -design foo -domain_mapping ...</nobr></pre>

<p>
  <a name="1052506"> </a>In this example, the content of the second definition of model foo is appended to the content of the first definition of model foo and instance<code> I1</code> is bound to the resulting model. The following is the equivalent CPF:</p>


<pre><a name="1052507"></a><nobr>set_design foo ;<br>create_power_domain -name PD1 -default<br>...<br>update_power_domain -name PD1 -primary_power_net VDD1<br>...<br>end_design<br>set_instance I1 -design foo -domain_mapping ...</nobr></pre>

  <a name="1052473"> </a><h4>
Example 5-6   </h4>


<pre><a name="1052474"></a><nobr>set_instance I1 -domain_mapping ...</nobr></pre>

<pre><a name="1045392"></a><nobr>set_design foo ;# model 1 for foo<br>...<br>end_design<br>set_instance I2 -design foo -domain_mapping ...</nobr></pre>

<pre><a name="1045394"></a><nobr>set_design foo ;# model 2 for foo<br>...<br>end_design</nobr></pre>

<p>
  <a name="1045396"> </a>This CPF generates an error because CPF model <code>foo</code> does not exist in the scope where and when <code>I2</code> is instantiated. The first model of <code>foo</code> belongs to the scope of <code>I1</code> and is not accessible outside of that scope. The second model of <code>foo</code> is defined after the instantiation of <code>I2.</code></p>


  <a name="1052533"> </a><h4>
Example 5-7   </h4>


<pre><a name="1052546"></a><nobr>set_design top<br>set_design foo<br>...<br>end_design foo<br>set_instance I1 -design foo -domain_mapping ...<br>...<br>update_design foo<br>...<br>end_design foo<br>...<br>set_instance I2 -design foo -domain_mapping ...<br>...<br>end_design top</nobr></pre>

<p>
  <a name="1052544"> </a>The original power design foo is appended with power intent defined in the <code>update_design</code> command. Both <code>I1</code> and <code>I2</code> are bound to the fully updated definition of power design <code>foo</code>.</p>


  <a name="1052570"> </a><h4>
Example 5-8   </h4>


<pre><a name="1052571"></a><nobr>set_design top<br>set_design foo ;# first definition of model foo<br>...<br>end_design foo<br>set design nested_design <br>...<br>set_design foo ;# second definition of model foo<br>...<br>end_design foo<br>...<br>end_design nested_design<br>set_instance I1 -design foo -domain_mapping ...<br>...<br>end_design top</nobr></pre>

<p>
  <a name="1052537"> </a>The second definition of <code>foo</code> is ignored and a warning is issued because two power designs with the same name <code>foo</code> were defined in the top scope. (Only <code>set_instance</code> causes a scope change.) Instance <code>I1</code> refers to the first definition of power design <code>foo</code>.</p>


  <a name="1052620"> </a><h4>
Example 5-9   </h4>


<pre><a name="1052621"></a><nobr>set_design top<br>set_design foo ;# first definition of model foo<br>...<br>end_design foo</nobr></pre>

<pre><a name="1052624"></a><nobr><code><strong>set_instance N1 -domain_mapping </strong></code>...<br>set design nested_design <br>...<br>set_design foo ;# second definition of model foo<br>...<br>end_design foo<br>...<br>end_design nested_design<br>set_instance I1 -design foo -domain_mapping ...<br>...<br>end_design top</nobr></pre>

<p>
  <a name="1052535"> </a>This example is similar to <a href="hier_flow.html#1052570">Example&nbsp;5-8</a>, but has a <code>set_instance</code> command inserted before the <code>set design nested_design</code> command. The <code>set_instance</code> command causes a scope change and as a result the two definitions of power design <code>foo </code>are valid. The first definition belongs to the scope <code>top</code>, while the second definition belongs to the scope <code>N1</code>. I1 will be bound to the first definition.</p>


<br><br><br>
<h2>
  <a name="1039735"> </a>Handling Boundary Port Domain Definition at Top Level</h2>


<p>
  <a name="1050542"> </a>In a hiearchical design flow, each boundary port of an IP block will be assigned to a power domain. This implies that the logic that is outside the IP block and that is connected to this port is powered by the power supply of this domain. This will enable the tools to verify and implement the IP block using the block-level CPF. When the IP block is instantiated at the top level, the block-level boundary port becomes a hierarchical pin at the top level. By default, the hierarchical pin is not associated with any power domain. In a bottom-up hierarchical design flow, designers sometimes want to treat the block-level CPF as a golden specification. The power domain association with the boundary port (at block level) is part of this golden specification. In other words, designers expect that after the top-level implementation the hiearchical pin connection should be consistent with the block-level boundary port domain association.</p>


<p>
  <a name="1039969"> </a>To support this expectation, the <code>-honor_boundary_port_domain</code> option is added to the <a href="reference.html#1267927">set_design</a> command. The option has the following implications:</p>

<ol type="1">
  <li value="1"><p><a name="1039938"> </a>This option only applies to the primary input and output ports of the current design (specified by the <code>set_design</code> command)</p>
  <li value="2"><p><a name="1039939"> </a>If this option is specified, each association of a boundary port with a power domain becomes a design constraint at the top level after the block is instantiated at the top. At the top level, each corresponding hierarchical pin becomes a virtual leaf-level driver or leaf-level load for power-domain traversal purposes where the power domain is the power domain definition for the boundary port. </p>
  <li value="3"><p><a name="1039851"> </a>If this option is not specified, the boundary port domain definition does not treat the hierarchical pin as a leaf-level driver or leaf-level load. The tools should traverse through the hierarchical pin when traversing the net connected to the pin till they find the leaf-level driver or leaf-level load.</p>
  <li value="4"><p><a name="1042592"> </a>For custom models, each boundary port definition should automatically be treated as a design constraint. </p>
</ol>

<p>
  <a name="1040049"> </a>In the following example, module <code>mod1</code> is an IP block with a default switchable domain. Also, the output port <code>O</code> is declared as part of a virtual domain which is unswitched.</p>


<p>
  <a name="1040057"> </a><img src="images/hier_flowx1.png" border="0">
</p>


<pre><a name="1040062"></a><nobr>set_design mod1 <code><strong>-honor_boundary_port_domain</strong></code></nobr></pre>

<pre><a name="1040064"></a><nobr>create_power_domain -name PDVirtual -boundary_ports O</nobr></pre>

<pre><a name="1040065"></a><nobr>create_power_domain -name PDCore -default -shutoff_condition en \<br>&nbsp; &nbsp;	 -base_domains PDVirtual</nobr></pre>

<pre><a name="1040067"></a><nobr>end_design</nobr></pre>

<pre><a name="1040069"></a><nobr>set_design top</nobr></pre>

<pre><a name="1040070"></a><nobr>create_power_domain -name PDAO default</nobr></pre>

<pre><a name="1040071"></a><nobr>create_power_domain -name PD2 -shutoff_condition en2 -instances I2</nobr></pre>

<pre><a name="1040072"></a><nobr>set_instance I1 -design mod1 -domain_mapping {{PDVirtual PDAO}}</nobr></pre>

<pre><a name="1040083"></a><nobr>end_design</nobr></pre>

<p>
  <a name="1040150"> </a>When module <code>mod1</code> is instantiated at the top, block-level domain <code>PDVirtual</code> is mapped to top-level domain <code>PDAO</code>. Since block <code>mod1</code> is specified with the <code>-honor_boundary_port_domain</code> option, then at top level, even though the hierarchical pin <code>I1/O</code> has leaf-level driver <code>I1/S/Z</code> in domain <code>I1/PDCore</code> and leaf-level load <code>I2/D/A</code> in domain <code>PD2</code>, the boundary domain association of <code>O</code> with <code>PDAO</code> (due to the domain mapping) should be treated as a design constraint. As a result, the implementation tool may insert a buffer for the top net x within power domain <code>PDAO</code> to meet the design requirement.</p>


<br><br><br>
<h2>
  <a name="1044080"> </a><a name="Power Mode Control Groups"></a>Power Mode Control Groups</h2>


<p>
  <a name="1047337"> </a>A power mode control group is a set of power domains with an associated set of power modes and mode transitions that apply to this group only. All power modes defined for this group can only reference power domains within this group. All power mode transitions can only reference power modes defined for this group. </p>


<p>
  <a name="1051195"> </a>A power domain can belong to more than one power mode control group. However, each power mode control group must have one and only one default power mode.</p>


<p>
  <a name="1049281"> </a>A power mode group can contain other power mode groups. If a power mode control group has another power mode control group as its member and the other power mode control group is not referenced in any power mode definition, the other power mode control group is assumed to be in the default power mode of that group.</p>


<p>
  <a name="1049288"> </a>The <code>create_analysis_view</code> command is also extended to be able to create a top-level analysis view by using block-level analysis views created within a power mode control group. This enables the reuse of the block level CPF analysis view. For example, the operating corner assignment for the block-level power domains can be reused at the top level in the implementation flow.</p>


<p>
  <a name="1049289"> </a>If a power mode control group in a lower scope is not referred to by another power mode or analysis view in an upper scope, the power mode or analysis view at the block level will be ignored at the top level. However, if a power mode control group in a lower scope is referred by some other power mode or analysis view in an upper scope, but not by all, the power mode control group is supposed to be in the default mode in those modes in the upper scope where it is not referenced.</p>




<h4>
  <a name="1044088"> </a>Default Power Mode Control Group</h4>


<p>
  <a name="1048911"> </a>A <em>default</em> power mode control group is automatically created for each CPF scope. The default power mode control group has no name.To reference the default power mode control group of a scope, use the hierarchical path from the current scope to the targeted scope. </p>


<p>
  <a name="1049218"> </a>The default power mode control group for a scope contains all those power domains defined in this scope that are not declared as members of an explicitly defined power mode control group. In other words, if all power domains of a scope belong to an explicitly defined power mode control group, the default power mode control group has no members.</p>




<h4>
  <a name="1048913"> </a>User-Created Power Mode Control Group</h4>


<p>
  <a name="1049211"> </a>The <a href="reference.html#1400924">set_power_mode_control_group</a> and <a href="reference.html#1339318">end_power_mode_control_group</a> commands define the start and end of an explicit power mode control group definition. </p>


<p>
  <a name="1049212"> </a>To declare another power mode control group as a group member of a power mode control group, use the <code>-groups</code> option of the <code>set_power_mode_control_group</code> command.</p>


<p>
  <a name="1052780"> </a>Within a scope, you can create one or more power mode control groups. A power mode control group can be referenced by its hierarchical name in top-level CPF commands.</p>


<p>
  <a name="1044091"> </a>A power domain that is not part of any power mode definition within a power mode control group is assumed to be powered down.</p>


  <a name="1044094"> </a><h4>
Example 5-10   Using Default Power Control Group</h4>


<p>
  <a name="1044126"> </a><img src="images/hier_flowx2.png" border="0">
</p>


<p>
  <a name="1044130"> </a><code>BLOCKA</code> in Example <a href="hier_flow.html#1044094">5-9</a> is a hierarchical block. The CPF file at the top right defines the power domains, power modes, and power mode transitions for this block. The power modes and power mode transitions are defined with respect to the power domains at this level of hierarchy in the design.</p>


<p>
  <a name="1044131"> </a>Since no explicit power mode control group is created for <code>BLOCKA</code>, the default power mode control group contains the two power domains of <code>BLOCKA</code>. In this group, power domain <code>PD_C2</code> is not referenced in mode <code>M3</code>. Therefore, domain <code>PD_C2 </code>is assumed to be in the <code>off</code> state. When the block is instantiated, the hierarchical scope name of the block must be used to refer to the default power mode control group, <code>INST_A</code> in this case.</p>


<p>
  <a name="1044132"> </a>The CPF file for design TOP has its own power mode control group (<code>top</code>) which includes power domain <code>PD_B</code> and power mode control group <code>INST_A</code>. When defining a power mode for design TOP, you can use the <code>-domain_conditions</code> option for any power domains at this level of hierarchy, but to refer to the power mode of <code>BLOCKA </code>you must use the <code>-group_modes</code> option: </p>


<pre><a name="1044133"></a><nobr>create_power_mode -name T2 -domain_conditions {PD_B@off} -group_modes {INST_A@M2}</nobr></pre>

<p>
  <a name="1045700"> </a>In this case, top-level mode <code>T2</code> is created with domain <code>PD_B</code> at nominal condition <code>off</code> and power mode control group of <code>BLOCKA</code> (<code>INST_A</code>) in power mode <code>M2</code>, in which both block-level domains <code>PD_C1</code> and <code>PD_C2</code> are <code>on</code>.</p>


<p>
  <a name="1045703"> </a>Top-level mode <code>T1</code> is created with domain <code>PD_B</code> at nominal condition <code>on.</code> Since the power mode control group (<code>INST_A</code>) is not referenced in this top-level mode, it is assumed to be in the default mode of the power mode control group, which is mode <code>M1</code>.</p>


  <a name="1052691"> </a><h4>
Example 5-11   Use of Explicitly Created Power Mode Control Groups</h4>


<pre><a name="1052693"></a><nobr># from file BLOCKQ.cpf</nobr></pre>

<pre><a name="1052695"></a><nobr>set_design BLOCKQ<br>create_power_domain -name PDA1<br>create_power_domain -name PDA2<br>create_power_domain -name PDB1<br>create_power_domain -name PDB2</nobr></pre>

<pre><a name="1052700"></a><nobr># PDA1 and PDA2 belong in PMCGA<br>set_power_mode_control_group -name PMCGA -domains {PDA1 PDA2}<br>create_power_mode -name MA1 -domain_conditions {PDA1@on PDA2@on } -default<br>create_power_mode -name MA2 -domain_conditions {PDA1@on PDA2@off}<br>create_power_mode -name MA3 -domain_conditions {PDA1@off PDA2@on }<br>create_power_mode -name MA4 -domain_conditions {PDA1@off PDA2@off}<br>end_power_mode_control_group</nobr></pre>

<pre><a name="1052711"></a><nobr># PDB1 and PDB2 belong in PMCGB<br>set_power_mode_control_group -name PMCGB -domains {PDB1 PDB2}<br>create_power_mode -name MB1 -domain_conditions {PDB1@on PDB2@on } -default<br>create_power_mode -name MB2 -domain_conditions {PDB1@on PDB2@off}<br>create_power_mode -name MB3 -domain_conditions {PDB1@off PDB2@on }<br>create_power_mode -name MB4 -domain_conditions {PDB1@off PDB2@off}<br>end_power_mode_control_group</nobr></pre>

<pre><a name="1052719"></a><nobr>end_design</nobr></pre>

<p>
  <a name="1052720"> </a>The power mode control group allows you to concisely specify power modes. In this example, the result of creating two power mode control groups with four power modes each is equivalent to explicitly creating 16 power modes.</p>


  <a name="1052661"> </a><h4>
Example 5-12   Explicit Power Mode Control Group Hierarchical References</h4>


<pre><a name="1052663"></a><nobr>set_design TOP</nobr></pre>

<pre><a name="1052665"></a><nobr>create_power_domain -name PD1</nobr></pre>

<pre><a name="1052666"></a><nobr>set_instance INST_Q<br>include BLOCKQ.cpf</nobr></pre>

<pre><a name="1052668"></a><nobr># assumes INST_Q/PMCGA and INST_Q/PMCGB are in the respective default<br># power modes (MA1 and MB1)<br>create_power_mode -name T1 -domain_conditions {PD1@on} -default</nobr></pre>

<pre><a name="1052671"></a><nobr># assumes INST_Q/PMCGB is in its default power mode MB1</nobr></pre>

<pre><a name="1052672"></a><nobr>create_power_mode -name T2 -domain_conditions {PD1@off} \<br>-group_modes {INST_Q/PMCGA@MA2}</nobr></pre>

<pre><a name="1052674"></a><nobr># assumes INST_A/PMCGA is in its default power mode MA1</nobr></pre>

<pre><a name="1052675"></a><nobr>create_power_mode -name T3 -domain_conditions {PD1@on} \<br>-group_modes {INST_Q/PMCGB@MB3}</nobr></pre>

<pre><a name="1052677"></a><nobr>end_design</nobr></pre>

<p>
  <a name="1052678"> </a>This example uses the instantiation of <code>BLOCKQ</code> from Example <a href="hier_flow.html#1052691">5-9</a> and illustrates references to the power mode control groups within <code>BLOCKQ</code>.</p>


  <a name="1052657"> </a><h4>
Example 5-13   User-Created Power Control Groups with Domains in Multiple Groups</h4>


<p>
  <a name="1052658"> </a>Assume a design with power domains, <code>CPF</code>, <code>GPU</code>, and <code>MEM</code>. The power modes specify a relationship between two out of the three domains: <code>CPF</code> and <code>GPU</code>, <code>CPU</code> and <code>MEM</code>.</p>


<p>
  <a name="1051211"> </a>To describe the above intent, you can create two power mode control groups, one containing domains <code>CPU</code> and <code>GPU</code>, and one containing domains <code>CPU</code> and <code>MEM</code>. Note that domain <code>CPU</code> belongs to two groups. </p>


<pre><a name="1051212"></a><nobr>set_power_mode_control_group -name PU -groups {CPU GPU}<br>&nbsp; &nbsp;	 create_power_mode -name PU_1 -group_modes {CPU@C1 GPU@C2 }<br>&nbsp; &nbsp;	 create_power_mode -name PU_2 -group_modes {CPU@C3 GPU@C1 }<br>end_power_mode_control_group<br>set_power_mode_control_group -name CMEM -groups {CPU MEM}<br>&nbsp; &nbsp;	 create_power_mode -name CMEM_1 -group_modes {CPU@C1 MEM@C2 }<br>&nbsp; &nbsp;	 create_power_mode -name CMEM_2 -group_modes {CPU@C3 MEM@C1 }<br>end_power_mode_control_group</nobr></pre>

<p>
  <a name="1051213"> </a>Now, if the current state has <code>CPU@C3, GPU@C1,</code>and <code>MEM@C1</code>, it can be determined that for group <code>PU</code>, the mode is <code>PU_2</code> and for group <code>CMEM</code> the mode is <code>CMEM_2</code>. Each power mode control group can define the mode transitions and check if the transition is legal. A transition in one group can cause an illegal transition to be reported in another group. For instance, if <code>PU</code> group has a <code>PU_1</code> to <code>PU_2</code> transition, and <code>CMEM</code> group does not have a <code>CMEM_1</code> to <code>CMEM_2</code> transition, then the <code>CPU</code> domain would go from condition <code>C1</code> to <code>C3</code> and an error would be flagged for the <code>CMEM</code> group.</p>


<pre><a name="1051220"></a><nobr></nobr></pre>

  

</blockquote>

<br>
<a href="#pagetop">Return to top of page</a>
<hr>
<p>
<!-- Begin Buttons -->
<table border="0" cellpadding="0" cellspacing="0" width="650">
<tr>
  <td height="20" width="59"><a href="javascript:openLibrary()"><img src="../support/nav2_library.gif" border="0" alt="View Library" height="20" width="59"></a></td>
  <td height="20" width="73"><a href="cpf_refTOC.html"><img src="../support/nav2_toc.gif" border="0" alt="View Table Of Contents" height="20" width="73"></a></td>
  <td height="20" width="46"><a href="cpf_refIX.html"><img src="../support/nav2_index.gif" border="0" alt="View Index for This Manual" height="20" width="46"></a></td>
  <td height="20" width="83"><a href="domains_and_modes.html"><img src="../support/nav2_previous.gif" border="0" alt="View Previous Chapter in Book" height="20" width="83"></a></td>
  <td height="20" width="59"><a href="rules.html"><img src="../support/nav2_next.gif" border="0" alt="View Next Chapter in Book" height="20" width="59"></a></td>
  <td height="20" width="114"><a href="cpf_ref.pdf"><img src="../support/nav2_print.gif" border="0" alt="Open PDF to print book" height="20" width="114"></a></td>
  <td height="20" width="61"><a href="/search.htm"><img src="../support/nav2_search.gif" border="0"  alt="Search Cadence Library" height="20" width="61"></a></td>
  <td height="20" width="76"><a href="/feedback.htm"><img src="../support/nav2_feedback.gif" border="0" alt="Email Comments" height="20" width="76"></a></td>
  <td height="20" width="43"><a href="../cdsuser/help.html"><img src="../support/nav2_help.gif" border="0" alt="Help Using Documentation" height="20" width="43"></a></td>
  <td height="20" width="37"><a href="/exitsearch.htm"><img src="../support/nav2_exit.gif" border="0" alt="Shut Down Cadence Documentation Server" height="20" width="37"></a></td>
</tr>
</table>
<!-- End Buttons -->
<p>
<p>


<!-- NOTES; -->

<!-- /address -->
<p>
<br>
<font size="-1">
For support, see <a href=http://www.cadence.com/support>http://www.cadence.com/support</a>
or try Cadence's <a href=http://sourcelink.cadence.com target=_blank>SourceLink</a> service.
<br><br>
<i>Copyright &#169; 2013, <a href=http://www.cadence.com>Cadence Design Systems, Inc.</a></i> 
<br>
All rights reserved.
<br>
<a href="titlecopy.html">Legal notices and trademark attributions</a>
<br>
<!-- This file was created with Quadralay WebWorks Publisher AutoMap 6.0.7 -->
<!-- -->
<!-- Last updated: Wed Jul 17 14:09:11 2013 -->
</font>
</body>
</html>


