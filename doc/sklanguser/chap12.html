
<html><head><title>SKILL Code Optimization</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="parula" />
<meta name="CreateDate" content="2023-08-23" />
<meta name="CreateTime" content="1692797216" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the SKILL language to new users and helps them understand advanced topics, encourages sound SKILL programming methods, and introduces the SKILL++ language" />
<meta name="DocTitle" content="Cadence SKILL Language User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="SKILL Code Optimization" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-4.0.0" />
<meta name="Keyword" content="sklanguser" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-08-23" />
<meta name="ModifiedTime" content="1692797216" />
<meta name="NextFile" content="chap13.html" />
<meta name="Group" content="SKILL Language" />
<meta name="Platform" content="Cadence Shared Tools" />
<meta name="PrevFile" content="chap11.html" />
<meta name="c_product" content="Virtuoso Layout Suite,Virtuoso Schematic Editor,Virtuoso Analog Design Environment" />
<meta name="Product" content="SKILL" />
<meta name="ProductFamily" content="SKILL" />
<meta name="ProductVersion" content="IC23.1" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Cadence SKILL Language User Guide -- SKILL Code Optimization" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="0" />
<meta name="Version" content="IC23.1" />
<meta name="SpaceKey" content="sklanguserIC231" />
<meta name="webflare-version" content="2.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" />


  <script>/*<![CDATA[*/
 document.addEventListener("DOMContentLoaded", function(event) {  document.querySelectorAll("img").forEach((img, index) => {
if (img.hasAttribute("usemap")){return;}else{img.classList.add("cursorclass");} img.addEventListener("click", (e) => {if(img.hasAttribute("usemap")){            img.setAttribute("style","cursor:none;");return;};document.querySelector("#cad_image_modal").classList.add("opac");document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0;margin: auto;max-height:95%;"  src="${e.target.src}">`;});});});
/*]]>*/</script> 




 <style>/*<![CDATA[*/
.cursorclass{cursor:pointer;}#cad_image_modal{position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;}#cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;}#cad_image_modal span{position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;}
/*]]>*/</style> 
</head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="sklanguserTOC.html">Contents</a></li><li><a class="prev" href="chap11.html" title="Writing Style">Writing Style</a></li><li style="float: right;"><a class="viewPrint" href="sklanguser.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap13.html" title="About SKILL++ and SKILL">About SKILL++ and SKILL</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Cadence SKILL Language User Guide<br />Product Version IC23.1, September 2023</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<h1>12
<a id="pgfId-1005655"></a></h1>
<h1>
<a id="pgfId-1008199"></a><hr />
SKILL<a id="marker-1011422"></a> Code Optimization<hr />
</h1>

<p>
<a id="pgfId-1011655"></a>Before you embark on optimizing your SKILL code, your SKILL program should work. You might waste time if you try to optimize the performance of a program that has not yet met its functional requirements.</p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1011779"></a>In this chapter, you can find information about techniques for modifying your programs to run faster. You will not learn how to create better algorithms: You need to design algorithmic performance into your programs from the outset.</div>
<p>
<a id="pgfId-1011230"></a>When optimizing your SKILL code, you should do the following:</p>
<ul><li>
<a id="pgfId-1011404"></a>Focus your efforts<br />
<a id="pgfId-1011236"></a>Before optimizing, you should determine what you need to optimize. If 80% of the time is spent in 20% of the code, you should focus your efforts on optimizing that small portion of the program where there is a performance bottle-neck. <br />
<a id="pgfId-1011237"></a>Always measure the benefit gained after you modify your code. You should leave well-written and well-structured code untouched if the changes do not yield significant performance improvements. </li><li>
<a id="pgfId-1011238"></a>Use <a actuate="user" class="URL" href="../skillide/skillideTOC.html#firstpage" show="replace" xml:link="simple">profiling tools</a> to measure code performance<br /><div class="webflare-information-macro webflare-macro-information">
<a id="pgfId-1011626"></a>
You should expect reduced execution speed when profiling and gathering performance data because these operations are necessarily intrusive in nature. The measurements you gather should take this into account. When profiling, you should think of code performance in terms of percentages rather than absolute values. See <a href="chap9.html#62651">&#8220;Printing Summary Statistics&#8221;</a> for information on the how to obtain and interpret a summary of memory allocation.</div><br />
<a id="pgfId-1011239"></a>You can optimize your SKILL code for time spent and memory used.<ul><li>
<a id="pgfId-1011240"></a><a id="marker-1011484"></a>Time: You can use the SKILL Profiler to find out where most of the time is spent in your program. You can gather global statistical information about time spent in functions called in a given session. The profiler takes a sample of the runtime stack at pre-specified intervals and presents timing information as call graphs identifying the critical paths. You can use this information to direct your effort.<br />
<a id="pgfId-1011244"></a>You can use <code>measureTime</code><a id="marker-1011243"></a> to evaluate specific expressions and get timing results. You can also add your own more deterministic instrumentation to the code to collect relevant information about your algorithms and structures. </li><li>
<a id="pgfId-1011245"></a>Memory: You can use the SKILL Profiler to track m<a id="marker-1011246"></a>emory usage in your program. SKILL has an automatic memory manager and programs can be written to generate excessive amounts of memory. Before you optimize for time, make sure to profile memory usage to see if that is where you need to spend your effort. A good indicator that memory usage needs optimizing is if the function <code>gc</code> (garbage collection) appears high among functions profiled for time.</li></ul></li></ul>













<h2>
<a id="pgfId-1011309"></a><a id="11428"></a>Optimizing Techniques</h2>

<p>
<a id="pgfId-1011310"></a>You can try the following techniques to optimize your code. Not all techniques are effective in all circumstances. You should experiment and measure performance gain. </p>
<ul><li>
<a id="pgfId-1011346"></a><a href="chap12.html#77482">Macros</a></li><li>
<a id="pgfId-1011354"></a><a href="chap12.html#24294">Caching</a></li><li>
<a id="pgfId-1011359"></a><a href="chap12.html#14355">Mapping and Qualifying</a></li><li>
<a id="pgfId-1011368"></a><a href="chap12.html#30693">Write Protection</a></li><li>
<a id="pgfId-1011369"></a><a href="chap12.html#89967">Minimizing Memory</a></li></ul>





<h3>
<a id="pgfId-1008228"></a><a id="77482"></a>Macros<a id="marker-1011383"></a></h3>

<p>
<a id="pgfId-1008230"></a>In many situations, you can improve the performance of your code by replacing function calls with <h-hot><a actuate="user" class="URL" href="../sklanguser/chap9.html#Macros" show="replace" xml:link="simple">macros</a></h-hot>. However, because macros are in-line expanded, they can grow the size of the code at runtime. So there is a balance as to what kind of functions can be written as macros. </p>
<p>
<a id="pgfId-1008231"></a>For example, functions small in size that are likely to be used a lot are good candidates. Expressions that can be reduced at compile time leaving smaller subexpressions to be evaluated at run time are also good candidates.</p>

<h3>
<a id="pgfId-1008232"></a><a id="24294"></a>Caching</h3>

<p>
<a id="pgfId-1008234"></a><a id="marker-1008233"></a>Caching is a technique used to save the results of costly computations in a fast access cache structure. You have to balance the benefit of time saved versus amount of memory used for the cache structure.</p>
<p>
<a id="pgfId-1008236"></a>A good data structure to use for caches is the <a id="marker-1008235"></a>association table. For example, if you called a compute-intensive function, say factorial or fibonacci, many times in a session, you might consider caching the results so a second call to the function with same argument will run faster. To do this, you first need to create an assoc table and store it as a property on the symbol for the function, for example:</p>
<p>
<a id="pgfId-1008239"></a>The fibonacci function described in <a href="chap17.html#17751">&#8220;Fibonacci Function&#8221;</a>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008241"></a>myFib.cache = makeTable(&quot;fibonacciTable&quot; nil)<br />procedure( myFib(num)<br />(let ((res myFib.cache[num]))<br />      cond( !res myFib.cache[num]= fibonacci(num))<br />            ( t res)<br />))</pre>

<p>
<a id="pgfId-1008242"></a>You could write the function <code>myFib</code> as a macro:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008243"></a>defmacro( myFib (num)<br />      &#8216;or(myFib.cache[,num] <br />            myFib.cache[,num] = fibonacci(,num)<br />))</pre>

<p>
<a id="pgfId-1008244"></a>For example, compare the following timing numbers (in seconds).</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008245"></a>            fibonacci(25)myFib(25)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008246"></a>1st call 23 23<br />2nd call 23 0.009 </pre>
<h3>
<a id="pgfId-1008247"></a><a id="14355"></a>Mapping and Qualifying</h3>

<p>
<a id="pgfId-1008248"></a>Mapping functions (<code>map, mapcar,</code> <code>maplist</code>, and so forth) have been described in detail in <a href="chap8.html#16206">&#8220;Advanced List Operations&#8221;</a> When manipulating lists, you can achieve significant <a id="marker-1008252"></a>performance gains if you use map* functions instead of loops that directly manipulate the lists. The same argument applies to qualifiers like <code>foreach</code>, <code>setof </code>and<code> exists</code>. The qualifiers are generic in nature in that they apply to lists as well as to association tables. </p>
<p>
<a id="pgfId-1008253"></a>Consider the following two examples performing the same operation of adding consecutive numbers in two equal length lists and returning a list of the results. The example using <code>mapcar</code> is at least twice as fast. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008254"></a>L1 = &#39;(1 2 3 4 5 &#8230; 100)<br />L2 = &#39;(100 99 98 .. 1)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008255"></a>mapcar(lambda((x y) x+y) L1 L2)<br />
(let (res) 
&#160;&#160;    while(      car(L1) <br />                  res=cons(car(L1)+car(L2) res)<br />                  L1 = cdr(L1)<br />                  L2 = cdr(L2)<br />      ) res<br />)</pre>
<h3>
<a id="pgfId-1008256"></a><a id="30693"></a>Write Protection </h3>

<p>
<a id="pgfId-1008257"></a>Ensuring that all of your functions and data structures that are static in nature are write protected reduces the amount of work the garbage collector has to perform whenever it is triggered. Usually, all functions can be <a id="marker-1008258"></a>write protected because they are not likely to be over-written at run time. Some data structures, like lookup tables, whose contents are not likely to be modified at run time, can also be write protected. </p>
<p>
<a id="pgfId-1008259"></a>It is highly recommended that SKILL code destined for production be packaged in contexts and that all contexts are built with the status flag <code>writeProtect</code> set to <code>t</code> (see <a href="chap10.html#92795">&#8220;Protecting Functions and Variables&#8221;</a>). To set write protection on global variables use <code>setVarWriteProtect</code>. </p>
<p>
<a id="pgfId-1008263"></a>When SKILL memory is write protected, the garbage collector does not touch it, thus considerably reducing the amount paging and work done at run time. </p>

<h3>
<a id="pgfId-1008264"></a><a id="89967"></a>Minimizing Memory</h3>

<p>
<a id="pgfId-1008265"></a>The way memory is used in SKILL is by <code>cons</code>ing (the basic list building operation), creating strings, arrays, and so forth, or by generating instances of defstructs and user types. The goal of memory optimizing is to reduce the overall amount of memory used. This reduction<a id="marker-1008266"></a></p>
<ul><li>
<a id="pgfId-1008267"></a>Saves on run-time page swapping that an operation has to perform when physical memory resources are scarce </li><li>
<a id="pgfId-1008268"></a>Reduces the work load on the garbage collector </li></ul>


<h4>
<a id="pgfId-1008269"></a>Run the SKILL Profiler in Memory Mode</h4>

<p>
<a id="pgfId-1008270"></a>To start optimizing memory usage, use the SKILL profiler in memory mode to discover the functions responsible for the largest amount of memory used. From there start tweaking the functions. You should be aware of the nature of the utilities and library calls you use. </p>
<p>
<a id="pgfId-1008271"></a>For example, removing elements from lists using <code>remove</code> makes a copy of the original list minus the element removed. You should check to see if that is the desired behavior. If you can use a destructive remove instead, such as <code>remd</code>, you can cut down memory use considerably on this particular operation. Experiment.</p>

<h4>
<a id="pgfId-1008272"></a>Ways to Minimize</h4>

<p>
<a id="pgfId-1008273"></a>When generating large data structures in memory from information on disk, you should ask yourself whether you need to generate the whole image in memory if all of it is not likely to be used. Use the technique known as lazy evaluation to expand your structures on demand rather than at start-up. </p>
<p>
<a id="pgfId-1008274"></a>For example, you can embed <code>lambda</code> constructs in your data structures to retrieve information on demand (see <a href="chap9.html#27967">&#8220;Declaring a Function Object (lambda)&#8221;</a> for a description of <code>lambda</code> constructs). Experiment. </p>
<p>
<a id="pgfId-1008278"></a>If you know from the outset the amount of memory your application is likely to need at run time, you can preallocate that memory to reduce the number of times the garbage collector is triggered. There is a delicate balance you have to make here between total memory allocated and garbage collection. </p>
<p>
<a id="pgfId-1008279"></a>Remember, preallocating memory is not a substitute for fine tuning memory use in your program. </p>
<p>
<a id="pgfId-1008280"></a>Only preallocate memory when you have tuned the program and determined the minimum amount of memory needed to run efficiently. Read <a href="chap9.html#68393">&#8220;Memory Management (Garbage Collection)&#8221;</a> to better understand the nature of automatic memory management. </p>

<h3>
<a id="pgfId-1008284"></a><a id="tail_call"></a>Tail-Call Optimization</h3>

<p>
<a id="pgfId-1012551"></a>When a function is called, its return address is pushed to the call stack. Each recursive call to the function results in a new stack frame being pushed to the call stack. Since the call stack has limited memory, recursive calls to a function can result in stack overflow. SKILL uses tail-call optimization to keep runtime stack-overflow errors in check.</p>
<p>
<a id="pgfId-1013695"></a>If the last thing a function does before it returns is call another function, rather than allocating a new stack frame for the called function, tail-call optimization allows you to reuse the stack frame of the calling function. By using tail-call optimization, you can eliminate all intermediate return calls and implement recursion as a simple iteration. </p>
<p>
<a id="pgfId-1013696"></a>To implement tail-call optimization in SKILL, set the <code>optimizeTailCall</code> variable to <code>t</code>, that is</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012682"></a><code>sstatus(optimizeTailCall t)</code></pre>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1014200"></a>Tail-call optimization is applicable to SKILL code with lexical scoping (scheme/<code>.ils</code> files). The <code>.il</code> files (dynamic scoping) use the runtime stack to store the function call&#39;s arguments, and therefore, the tail-call optimization is not applicable for <code>.il</code> files. In addition, tail call optimization does not work in the debug mode. Ensure that <code>debugMode</code> switch is set to <code>nil</code> before compiling the function and setting <code>optimizeTailCall</code> switch.</div>
<p>
<a id="pgfId-1012693"></a>You can run the following examples and verify how tail-recursion is eliminated when you use tail-call optimization:</p>

<h4>
<a id="pgfId-1012712"></a>Example 1:</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013766"></a>toplevel(&#39;ils) ;; in SCHEME mode</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013965"></a>sstatus(debugMode nil) ;; turn off debugMode</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012713"></a>tracef t ;; set trace = on</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012714"></a>defun(test ()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012715"></a>  let( ()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012716"></a>  --x</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012717"></a>  if(x &gt; 0 then</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012718"></a>    test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012719"></a>    )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012720"></a>  )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012721"></a>) ;; recursive call to test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012723"></a>ILS-&lt;2&gt;x = 4</pre>

<p>
<a id="pgfId-1012724"></a>Calling <code>test()</code> without setting <code>optimizeTailCall</code>:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012725"></a> test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012726"></a>   (3 &gt; 0)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012727"></a>   greaterp --&gt; t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012728"></a>   test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012729"></a>     (2 &gt; 0)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012730"></a>     greaterp --&gt; t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012731"></a>     test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012732"></a>       (1 &gt; 0)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012733"></a>       greaterp --&gt; t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012734"></a>       test()</pre>

<p>
<a id="pgfId-1012567"></a>Calling <code>test()</code> after setting <code>optimizeTailCall</code>:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013141"></a>ILS-&lt;2&gt; sstatus(optimizeTailCall t)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013142"></a>ILS-&lt;2&gt; x = 4 ;; set x</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013143"></a>ILS-&lt;2&gt; test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013144"></a> test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013145"></a>   (3 &gt; 0)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013146"></a>   greaterp --&gt; t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013147"></a> test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013148"></a>   (2 &gt; 0)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013149"></a>   greaterp --&gt; t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013150"></a> test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013151"></a>   (1 &gt; 0)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013152"></a>   greaterp --&gt; t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013153"></a> test()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013154"></a>   (0 &gt; 0)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013155"></a>   greaterp --&gt; nil</pre>

<p>
<a id="pgfId-1013132"></a>When you call <code>test()</code> by setting <code>optimizeTailCall</code>, the stack-overflow errors are eliminated as the existing stack frame is reused. </p>

<h4>
<a id="pgfId-1013780"></a>Example 2:</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013805"></a>toplevel(&#39;ils) ;; in SCHEME mode</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013806"></a>ILS-&lt;2&gt; defun(a (x)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013807"></a>  if(x &gt; 0</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013808"></a>    b(x)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013809"></a>  )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013810"></a>)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013811"></a>a</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013812"></a>ILS-&lt;2&gt; defun(b (x)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013813"></a>  a(--x)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013814"></a>)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013815"></a>b</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013816"></a>;this implements a simple delay:</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013817"></a>ILS-&lt;2&gt; a(1000000)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013818"></a>*Error* b: Runtime Stack Overflow!</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013876"></a>ILS-&lt;2&gt; sstatus optimizeTailCall t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013820"></a>a(1000000)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013821"></a>=&gt;nil ; no stack overflow</pre>

<p>
<a id="pgfId-1013644"></a>Benefits of using tail-call optimization:</p>
<ul><li>
<a id="pgfId-1013645"></a>Functions execute faster since recursive push and pop operations are reduced.</li><li>
<a id="pgfId-1013646"></a>Stack-overflow errors are eliminated.</li></ul>

<p>
<a id="pgfId-1013647"></a>Limitations of using tail-call optimization:</p>
<ul><li>
<a id="pgfId-1013612"></a>Debugging and tracing of optimized code is difficult as the intermediate return calls are eliminated.</li></ul>

<h2>
<a id="pgfId-1012537"></a><a id="21955"></a>General Optimizing Tips<a id="marker-1011795"></a></h2>

<p>
<a id="pgfId-1008286"></a>See the following sections for general optimizing tips:</p>
<ul><li>
<a id="pgfId-1011809"></a><a href="chap12.html#35080">Element Comparison</a></li><li>
<a id="pgfId-1011822"></a><a href="chap12.html#75326">List Accessing</a></li><li>
<a id="pgfId-1011825"></a><a href="chap12.html#90948">List Building</a></li><li>
<a id="pgfId-1011830"></a><a href="chap12.html#40710">List Searching</a></li><li>
<a id="pgfId-1011835"></a><a href="chap12.html#49049">List Sorting</a></li><li>
<a id="pgfId-1011840"></a><a href="chap12.html#97376">Element Removal and Replacing</a></li><li>
<a id="pgfId-1011845"></a><a href="chap12.html#83272">Alternatives to Lists</a></li></ul>







<h3>
<a id="pgfId-1008287"></a><a id="35080"></a>Element Comparison</h3>

<p>
<a id="pgfId-1008288"></a>In SKILL, there are two basic functions used to compare values. These functions are <a id="marker-1008289"></a><code>eq</code> and <code>equal</code><a id="marker-1008290"></a> (also known as the infix operator, <code>==</code>). </p>
<p>
<a id="pgfId-1008291"></a>It is important to understand the difference between these two functions, because both are useful in particular circumstances. There are several functions in SKILL which have alternative implementations depending on whether the user wants to compare using the <code>eq</code> or <code>equal</code> function. For example, the two functions <code>memq</code> and <code>member</code> are used to search a list for an object. <code>memq</code> uses the <code>eq</code> function for comparison and <code>member</code> uses the <code>equal</code> function.</p>
<p>
<a id="pgfId-1008292"></a>The <code>eq</code> function is far stricter in its comparison than the <code>equal</code> function. There are objects which <code>equal</code> would consider to be the same, but which <code>eq</code> considers to be different. </p>
<p>
<a id="pgfId-1008293"></a>You can compare the following objects using <code>eq</code>:</p>
<ul><li>
<a id="pgfId-1008294"></a>SKILL symbols </li><li>
<a id="pgfId-1008295"></a>Small integers (<code>-2**29 &lt;= i &lt;= 2**28</code>) </li><li>
<a id="pgfId-1008296"></a>List objects (NOT their contents) </li><li>
<a id="pgfId-1008297"></a>Any pointers </li><li>
<a id="pgfId-1008298"></a>Characters (NOT strings) </li><li>
<a id="pgfId-1008299"></a>Ports </li></ul>





<p>
<a id="pgfId-1008300"></a>The important things that cannot be reliably compared by <code>eq</code> are strings and lists, unless they are identical objects referenced by the same pointer. In many situations SKILL tries to optimize memory use by caching certain objects and reusing them. For example, there is a string caching mechanism that saves SKILL from generating the same string multiple times. Code and data segments in static (write-protected) memory are also cached so they are reused within the static space. </p>
<p>
<a id="pgfId-1008301"></a>The following are some examples of the more unexpected differences between the comparison operations:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008302"></a>x = &#39;(1 2 3)<br />y = &#39;(1 2 3)<br />eq(x y)              =&gt; nil<br />equal(x y)&#160;&#160;         =&gt; t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008303"></a>s1 = &quot;string&quot;<br />s2 = &quot;string&quot;<br />s3 = s2<br />eq(s1 s2)            =&gt; t    ; unreliable<br />equal(s1 s2)         =&gt; t    ; reliable<br />eq(s3 s2)            =&gt; t    ; reliable<br />equal(s3 s2)&#160;&#160;       =&gt; t    ; reliable</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008304"></a>eq(12345 12345)      =&gt; nil<br />l = &#39;(12345)<br />eq(car(l) car(l))    =&gt; t<br />l = &#39;(&quot;string&quot;)<br />eq(car(l) car(l))&#160;&#160;  =&gt; t</pre>

<p>
<a id="pgfId-1008305"></a>To understand more about <code>equal</code> and <code>eq</code>, keep in mind how they are implemented. The following are pseudo-code definitions of the two functions (they are implemented in C):</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008306"></a>eq(A B)<br /> if A is the same object as B<br /> then t<br /> else nil<br />end eq</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008307"></a>equal(A B)<br /> if eq(A B)<br /> then t<br /> else<br />       if the contents of A and B are &#8216;equal&#8217;<br />       then t<br />       else nil<br />end equal</pre>

<p>
<a id="pgfId-1008308"></a>Suppose the two functions are used to compare two SKILL objects, A and B. If A and B are in fact the same object then <code>eq</code> will immediately return <code>t</code>. Because the first thing that <code>equal</code> does is call <code>eq</code>, it too will immediately return<code> t</code> in this case. Now suppose that A and B represent distinct objects. In this case, <code>eq</code> will immediately return <code>nil</code>. <code>equal</code>, however, goes on to try to establish if the <code>contents</code> of the two objects are the same, (for example, if the objects are lists, <code>equal</code> compares each element of the two lists for equality) and this process involves a large overhead. To summarize this behavior:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008309"></a>eq(&#39;a &#39;a)&#160;&#160;          =&gt; t        (fast)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008310"></a>equal(&#39;a &#39;a)         =&gt; t        (fast)<br />eq(&#39;a &#39;b)            =&gt; nil      (fast)<br />equal(&#39;a &#39;b)&#160;&#160;       =&gt; nil      (SLOW)</pre>

<p>
<a id="pgfId-1008311"></a>If in doubt about which of <code>eq</code> and <code>equal</code> to use, observe the following rules:</p>
<ul><li>
<a id="pgfId-1008312"></a>If the objects are simple (symbols, small integers, pointers, characters), use <code>eq</code> because <code>eq</code> is faster than <code>equal</code>.</li><li>
<a id="pgfId-1008313"></a>If the objects are compound or complex (lists or strings, for example), consider what functionality is needed. To test whether two strings contain the same characters, use <code>equal</code>; To test whether two strings are in fact the same <code>object</code>, use <code>eq</code>.</li></ul>

<p>
<a id="pgfId-1008314"></a>Some common tests can be more efficiently implemented by using the built-in SKILL functions, or by using the fact that in SKILL, any non-<code>nil</code> object is true, not just <code>t</code>. Examples of some simple transformations are:</p>

<p>
<a id="pgfId-1009682"></a></p>
<table class="webflareTable" id="#id1009686">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1009688">
<a id="pgfId-1009688"></a>Original Test</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1009690">
<a id="pgfId-1009690"></a>Improved Test</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009692"></a>a == 0 </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009694"></a>zerop(a)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009696"></a>a == 1</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009698"></a>onep(a)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009700"></a>strcmp(a,&quot;teststring&quot;) == 0</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009702"></a>a == &quot;teststring&quot;</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009704"></a>a != nil </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009706"></a>a</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009708"></a>a == nil</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009710"></a>!a</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009712"></a>!null(a)</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009714"></a>a</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1008323"></a>For <code>a != nil</code>, providing a Boolean value is all that is required, for example,</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008324"></a>if( a != nil ) can be coded as if( a )</pre>

<p>
<a id="pgfId-1008325"></a>For <code>!null(a),</code> providing a Boolean value is all that is required, for example,</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008326"></a>if( !null(a)) can be coded as if( a )</pre>
<h3>
<a id="pgfId-1008327"></a><a id="75326"></a>List Accessing</h3>

<p>
<a id="pgfId-1008329"></a>The basic <a id="marker-1008328"></a>list accessing operations of SKILL (<code>car</code>, <code>cdr</code> and so forth) are fast, and their performance is predictable. The <code>nth</code> and <code>nthcdr</code> functions are significantly faster than the equivalent number of basic operations (because they avoid procedure call overhead) and should be used if lists are long. The operation that should be used with the most care is the <code>last</code> operation. This function must traverse the entire list to find the last element, so a large overhead is incurred for long lists.</p>

<h3>
<a id="pgfId-1008330"></a><a id="90948"></a>List Building</h3>

<p>
<a id="pgfId-1008332"></a>There are two main methods of <a id="marker-1008331"></a>building lists: iteratively, either as part of a program&#8217;s operation or when all the elements are the same type and non-iteratively when the format and number of elements are known. List building is an area that is open to abuse, and it is important that the processes involved are clearly understood.</p>

<h4>
<a id="pgfId-1008333"></a>Iterative List Creation</h4>

<p>
<a id="pgfId-1008334"></a>The standard function for adding an element to the start of a list is the <code>cons</code> function, which is efficient and has predictable performance. New users often find <code>cons</code> difficult to use because elements are added to the <code>front </code>of the list, giving a result that is &#8220;back to front&#8221;. There are several methods of producing a list in the &#8220;right&#8221; order, which vary in efficiency:</p>
<p>
<a id="pgfId-1008336"></a>Use <a id="marker-1008335"></a><code>append1</code> to add each element to the end of the list rather than to the start.</p>
<p>
<a id="pgfId-1008337"></a>This is the most inefficient method, and lists should never be iteratively created in this way. As each element is added, the <code>append1</code> function makes a copy of the original list, with the new element on the end. If a list of n elements is built using this method, then on the order of n<sup>2</sup> list cells are created, and most of them are promptly discarded again. </p>
<p>
<a id="pgfId-1008339"></a>Use <a id="marker-1008338"></a><code>nconc</code> to add each element to the end of the list rather than to the start.</p>
<p>
<a id="pgfId-1008340"></a>This method is also inefficient, and lists should never be iteratively created in this way. Because <code>nconc</code> is a &#8220;destructive&#8221; append, only <code>n</code> list cells need to be created to form the list. However, on the order of n<sup>2</sup> list cells must be traversed to build the list.</p>
<p>
<a id="pgfId-1008343"></a>Use <a id="marker-1008341"></a><code>cons</code> to build the list backwards, and then use <code>reverse</code><a id="marker-1008342"></a> to turn the list around.</p>
<p>
<a id="pgfId-1008344"></a>This is a much more efficient and easily understood method. To create a list of <code>n </code>elements,<code> 2n</code> list cells are created, but half of them are immediately discarded.</p>
<p>
<a id="pgfId-1008346"></a>Use the <a id="marker-1008345"></a><code>tconc</code> structure and function to build the list in the right order.</p>
<p>
<a id="pgfId-1008347"></a>This is the most efficient method in terms of storage requirements. To create a list of <code>n</code> elements, only<code> n+1</code> list cells are created. Because creation of list cells is relatively time consuming, this means that using <code>tconc</code> to build a long list is faster than using <code>cons</code> and <code>reverse</code>. A slight disadvantage is that the code is less intuitive.</p>
<p>
<a id="pgfId-1008348"></a>In general, if the code is not time critical, it might be better to build the list backwards using <code>cons</code> and then apply <code>reverse</code>. If the code is in a time critical part of the program, then the <code>tconc</code> method should be used, along with some detailed commenting. From a memory usage point of view, if the list being built is long, then it is better to use the <code>tconc</code> method to prevent the garbage collector being called unnecessarily.</p>
<p>
<a id="pgfId-1013952"></a>To build lists that are derived from existing lists, it is far better to use the mapping functions, possibly coupled with the <code>foreach</code> function. This is discussed in detail later.</p>

<h4>
<a id="pgfId-1013956"></a>Non-Iterative List Creation</h4>

<p>
<a id="pgfId-1008354"></a>To build lists of known format, use one of the <code>list</code>, <code>quote</code>, or <code>backquote</code> functions as follows:</p>
<ul><li>
<a id="pgfId-1008356"></a>Use <a id="marker-1008355"></a><code>list</code> when all elements of the result must be evaluated (in other words, none of the list members are known constants).</li><li>
<a id="pgfId-1008358"></a>Use <a id="marker-1008357"></a><code>backquote</code> when the list contains a mixture of known constants and evaluated entries.</li><li>
<a id="pgfId-1008360"></a>Use <a id="marker-1008359"></a><code>quote</code> when the list consists entirely of known constants.</li></ul>


<p>
<a id="pgfId-1008361"></a>For example, suppose we have the three variables, a, b, and c such that: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008362"></a>a = 1 <br />b = &quot;a string&quot; <br />c = &#39;(A B C D E)</pre>

<p>
<a id="pgfId-1008363"></a>If we wanted to make a disembodied property list (dpl) of symbol-value pairs using these variables then we could use <code>list</code> or a mixture of <code>quote</code> and <a id="marker-1008364"></a><code>backquote</code>, as follows:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008365"></a>/* These are identical in function. */<br />dpList1 = list(&#39;a a &#39;b b &#39;c c) <br />dpList2 = &#8216;(a ,a b ,b c ,c) </pre>

<p>
<a id="pgfId-1008366"></a>In the second case, some items are preceded with commas (with no space after the comma) and some are not. Those <code>not</code> preceded with commas are treated as literals, as if this was a normal quoted list. Those preceded by commas are evaluated, as if the list was declared using <code>list</code>.</p>
<p>
<a id="pgfId-1008367"></a>If this was the only use of <code>backquote</code>, it would be of little use. However, there are two useful extra features. The first is that you can splice in entire <code>lists</code> by using the <code>,@</code> (comma-at) specifier, as follows:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008368"></a>&#8216;(a ,a b ,b c ,@c) =&gt; (a 1 b &quot;a string&quot; c A B C D E) </pre>

<p>
<a id="pgfId-1008369"></a>Here, the five elements <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, and <code>E</code> have been used in place of the placeholder <code>,@c</code>. This cannot be done easily using <code>list</code>. The second useful feature is that the expansion can descend hierarchically. Suppose that instead of a dpl we wanted to create an assoc list. To do this using just <code>list</code>, would require the following: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008370"></a>list( list(&#39;a a) list(&#39;b b) list(&#39;c c) )<br />=&gt; ((a 1) (b &quot;a string&quot;) (c (A B C D E))) </pre>

<p>
<a id="pgfId-1008371"></a>Using <code>backquote</code> simplifies this to: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008372"></a>&#8216;((a ,a) (b ,b) (c ,c)) <br />=&gt; ((a 1) (b &quot;a string&quot;) (c (A B C D E))) </pre>

<p>
<a id="pgfId-1008373"></a>The last element can still be flattened using ,@ if required: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008374"></a>&#8216;((a ,a) (b ,b) (c ,@c)) <br />=&gt; ((a 1) (b &quot;a string&quot;) (c A B C D E)) </pre>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1008375"></a>Care should be taken with lists defined using <code>quote</code>. These lists form part of the program code, and if edited using the destructive list operations the program code will be changed. This is particularly important when building <code>tconc</code> lists. It is tempting to initialize a <code>tconc</code> structure to <code>&#39;(nil nil)</code>, but this is wrong. If this is done, then as each element is added the program itself is being modified. </div>
<p>
<a id="pgfId-1008376"></a>Consider the following naive list copy:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008377"></a>procedure(copylist(inputList)<br />      let( ((tc &#39;(nil nil)))<br />            foreach(element inputList<br />                  tconc(tc element)<br />            )<br />            car(tc)<br />      ) /* let */<br />) /* copylist */</pre>

<p>
<a id="pgfId-1008378"></a>This works the first time it is called, but the list assigned to <code>tc</code> in the variable declaration part is being modified as part of the program, so the next time the function is called, the copied list will be appended to the list that was copied in the first call:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008379"></a>copylist(&#39;(1 2 3)) =&gt; (1 2 3)<br />copylist(&#39;(a b c)) =&gt; (1 2 3 a b c)</pre>

<p>
<a id="pgfId-1008380"></a>The list should be initialized by using either <code>list(nil nil)</code> or <code>tconc(nil nil)</code>. The second method makes it more obvious that the variable is being initialized as a <code>tconc</code> structure, but in this case the return value would be <code>cdar(tc)</code> rather than <code>car(tc)</code>. </p>

<h3>
<a id="pgfId-1008381"></a><a id="40710"></a>List Searching</h3>

<p>
<a id="pgfId-1008383"></a>There are two methods for <a id="marker-1008382"></a>searching a list, depending on its structure. For a simple list, the functions <code>memq</code> and <code>member</code> can be used to search the list. The <code>memq</code> function is faster because it uses the <code>eq</code> function for comparison and is therefore preferred whenever the list contains elements for which the <code>eq</code> function is suitable. </p>
<p>
<a id="pgfId-1008384"></a>If the list is an assoc list, that is, it is a list of key-value pairs, then the functions <code>assoc</code> and <code>assq</code> should be used to do the searching. Again, <code>assq</code> is faster because it uses the <code>eq</code> function for the comparison. It is therefore worthwhile, when building assoc lists, trying to ensure that the key elements are suitable for use with the <code>eq</code> function. In particular, when building an assoc list that would normally have keys that are strings, it may be worthwhile using the <code>concat</code> function to turn these strings into symbols, and then using those symbols as the keys in the list. This will then allow the <code>assq</code> rather than the <code>assoc</code> function to be used. </p>
<p>
<a id="pgfId-1008385"></a>There are, however, two disadvantages with this method. The first disadvantage is that symbols in SKILL use memory and are not garbage collected (they are persistent), so creating many symbols uses up memory. Garbage collection is also slowed because the speed of this is directly related to the number of symbols. The second disadvantage is that the <code>concat</code> function is itself slow, so the overhead of this might outweigh any gains from using <code>assq</code> instead of <code>assoc</code>.</p>

<h3>
<a id="pgfId-1008386"></a><a id="49049"></a>List Sorting</h3>

<p>
<a id="pgfId-1008388"></a>The <code>sort</code> and <code>sortcar</code> functions<a id="marker-1008387"></a> for lists are based on a recursive merge sort and are thus reasonably efficient. The list is sorted in-place, with no new list elements created, thus the list returned replaces the one passed as argument, and the one passed as argument should no longer be used.</p>

<h3>
<a id="pgfId-1008389"></a><a id="97376"></a>Element Removal and Replacing</h3>

<p>
<a id="pgfId-1008391"></a>Two non-destructive functions are <a id="marker-1008390"></a>provided for removal of elements from a list, <code>remq</code> and <code>remove</code>. The equivalent but destructive functions are <code>remd</code> and <code>remdq</code> These functions remove all elements from the list which match a given value, using the <code>eq</code> and <code>equal</code> function respectively. The <code>remq</code> function is faster than the <code>remove</code> function.</p>
<p>
<a id="pgfId-1008392"></a>The function <code>subst</code> is provided for replacement of all elements of a list matching a particular value with another value. This function uses<code> equal</code> and so should be used sparingly.</p>
<p>
<a id="pgfId-1008393"></a>It should be noted that the non-destructive functions return a <code>copy</code> of the original list with the matching elements removed. This means that these functions should not be used within a loop in order to remove a large number of elements. If a number of different elements must be removed from a list, then it is more efficient to generate a new list by traversing the old one just once, selecting only the required elements for the new list.</p>

<h3>
<a id="pgfId-1008394"></a><a id="83272"></a>Alternatives to Lists</h3>

<p>
<a id="pgfId-1008396"></a>In many cases, there are faster and more compact <a id="marker-1008395"></a>alternatives to list structures. For example, if you need a property list that is likely to remain small in contents and most of the properties are known, consider using a <code>defstruct</code><a id="marker-1008397"></a>. </p>
<p>
<a id="pgfId-1008398"></a>If you need an assoc or property list whose contents are likely to be large (in the order of tens at least), then consider using assoc tables. Assoc tables offer much faster access time and for a large set of key-value pairs memory usage is more efficient. Assoc tables are not ordered (they are implemented as hash tables).</p>

<h2>
<a id="pgfId-1008399"></a><a id="40603"></a>Miscellaneous Comparative Timings</h2>

<p>
<a id="pgfId-1008401"></a>This section gives <a id="marker-1008400"></a>comparative timings for various pieces of SKILL code to further demonstrate and reinforce the comments made in the previous sections. The examples are listed in an order that matches the structure of the preceding sections.</p>
<p>
<a id="pgfId-1008402"></a>The timings were ascertained using the SKILL <code>profile</code> command and are expressed in ratios of the first example. In producing the timings, every effort has been made to compare like with like.</p>

<h3>
<a id="pgfId-1008403"></a>Element Comparison</h3>

<p>
<a id="pgfId-1008406"></a>The difference in speed between the <a id="marker-1008404"></a><code>eq</code> and <code>equal</code><a id="marker-1008405"></a> functions can be demonstrated using the following functions:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008407"></a>procedure(equal_test()<br />      equal(&#39;fred &#39;joe)<br />      equal(&#39;fred &#39;fred)<br />) /* end equal_test */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008408"></a>procedure(eq_test() <br />      eq(&#39;fred &#39;joe) <br />      eq(&#39;fred &#39;fred)<br />) /* end eq_test */</pre>

<p>
<a id="pgfId-1008409"></a>Each procedure has two comparisons, one failing and one succeeding. The comparative times for these were:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008410"></a>equal_test 1.00<br />eq_test&#160;&#160;  0.92</pre>

<p>
<a id="pgfId-1008411"></a>Further tests demonstrated that it is when the symbols are <code>not</code> equal that the <code>eq</code> function gains over the <code>equal</code> function. This means that if the test is expected to succeed on most occasions, there is little difference between the two functions.</p>

<h3>
<a id="pgfId-1008412"></a>List Building</h3>

<p>
<a id="pgfId-1008414"></a>As noted, there are several methods for <a id="marker-1008413"></a>building a list. The following examples attempt to build a list of the first 50 integers. The last example builds the list in descending order; the others build the list in ascending order.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008415"></a>procedure(list1()<br /> let( (returnList)<br />            for(i 1 50<br />                  returnList = append1(returnList i)<br />            )<br />            /* return */<br />            returnList<br /> ) /* end let */<br />) /* end list1 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008416"></a>procedure(list2()<br /> let( ((returnList list(nil nil))<br />            )<br />            for(i 1 50<br />                  tconc(returnList i)<br />            )<br />            car(returnList)<br /> ) /* end let */<br />) /* end list2 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008417"></a>procedure(list3()<br /> let( (returnList)<br />            for(i 1 50<br />                  returnList = cons(i returnList)<br />            )<br />            reverse(returnList) <br />      ) /* end let */<br />) /* end list3 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008418"></a>procedure(list4()<br /> let( (returnList)<br />            for(i 1 50<br />                  returnList = cons(i returnList)<br />            )<br />            returnList<br /> ) /* end let */<br />) /* end list4 */</pre>

<p>
<a id="pgfId-1008419"></a>The outcome of this test depends on the length of the list being built. These examples use a medium length list, and the results of running these examples are:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008420"></a>list1 1.00<br />list2 0.14<br />list3 0.11<br />list4 0.10</pre>

<p>
<a id="pgfId-1008421"></a>These results demonstrate that with this size of list there is little difference between using the <a id="marker-1008422"></a><code>tconc</code> method and the <code>cons </code><a id="marker-1008423"></a>and<code> reverse</code><a id="marker-1008424"></a> method. In fact, there will be little difference between these methods for any length of list because they both have to carry out the same basic functions. The only difference is that the <code>reverse</code> method must find twice as many list elements as the <code>tconc</code> method. This gives a greater chance of the garbage collector being called, which might cause the program to slow down, especially for large lists.</p>

<h3>
<a id="pgfId-1008425"></a>Mapping Functions</h3>

<p>
<a id="pgfId-1008427"></a>To demonstrate the relative speeds of the <a id="marker-1008426"></a>mapping functions, consider the following implementations of a function that picks every even integer out of a list of integers, returning the list of even integers in the same order as the originals.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008428"></a>procedure(map1(intList)<br />      let( (res)<br />            while(intList<br />                  when(evenp(car(intList))<br />                              res = cons(car(intList) res)<br />                  )<br />                  intList = cdr(intList)<br />            ) /* end while */<br />            reverse(res)<br />      ) /* end let */<br />) /* end map1 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008429"></a>procedure(map2(intList)<br />      let( (res)<br />            foreach(i intList<br />                  when(evenp(i)<br />                        res = cons(i res)<br />                  )<br />            ) /* end foreach */<br />            reverse(res)<br />      ) /* end let */<br />) /* end map2 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008430"></a>procedure(map3(intList)<br />      foreach(mapcan i intList<br />            when(evenp(i)<br />                  ncons(i)<br />            )<br />      ) /* end foreach */<br />) /* end map3 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008431"></a>procedure(map4(intList)<br />      mapcan((lambda (i) when(evenp(i) ncons(i)))<br />            intList<br />      )<br />) /* end map4 */</pre>

<p>
<a id="pgfId-1008432"></a>The relative timings for these are:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008433"></a>map1    1.00<br />map2    0.68<br />map3    0.64<br />map4&#160;&#160;  0.29</pre>

<p>
<a id="pgfId-1008435"></a>This shows that the version using a <a id="marker-1008434"></a><code>lambda</code> function along with the basic mapping function is the fastest. However, this is the least readable of these functions and should only be used with a great deal of caution, and a large number of comments.</p>

<h3>
<a id="pgfId-1008436"></a>Data Structures</h3>

<p>
<a id="pgfId-1008438"></a>It is difficult to give meaningful comparisons between the <a id="marker-1008437"></a>data structure functions because they are all suitable for different tasks. The following two examples attempt to compare the time taken to access and change one element of a data structure stored as an array, simple list, assoc list, defstruct and property list.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008439"></a>elem_number = 9<br />elem_symbol = &#39;j</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008440"></a>procedure(access1(array)<br />      array[elem_number]<br />) /* end access1 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008441"></a>procedure(access2(list)<br /> nth(elem_number list)<br />) /* end access2 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008442"></a>procedure(access3(assoc_list)<br /> cadr(assq(elem_symbol assoc_list))<br />) /* end access3 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008443"></a>procedure(access4(dstruct)<br /> get(dstruct elem_symbol)<br />) /* end access4 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008444"></a>procedure(access5(plist)<br /> get(plist elem_symbol)<br />) /* end access5 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008445"></a>procedure(access6(assocTable)<br /> assocTable[elem_symbol]<br />) /* end access */</pre>

<p>
<a id="pgfId-1008446"></a>The comparative timings for these are:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008447"></a>access1    1.00<br />access2    1.3<br />access3    1.47<br />access4    1.08<br />access5    1.55<br />access6&#160;&#160;  1.11</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008448"></a>procedure(set1(array val)<br /> array[elem_number] = val<br />) /* end set1 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008449"></a>procedure(set2(list val)<br /> rplaca(nthcdr(elem_number list) val)<br />) /* end set2 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008450"></a>procedure(set3(assoc_list val)<br /> rplaca(cdr(assq(elem_symbol assoc_list)) val)<br />) /* end set3 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008451"></a>procedure(set4(dstruct val)<br /> putprop(dstruct val elem_symbol)<br />) /* end set4 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008452"></a>procedure(set5(plist val)<br /> putprop(plist val elem_symbol)<br />) /* end set5 */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008453"></a>procedure(set6(assocTable val)<br /> assocTable[elem_symbol] = val<br />) /* end set6 */</pre>

<p>
<a id="pgfId-1008454"></a>The comparative timings for these are:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008455"></a>set1    1.00<br />set2    1.14<br />set3    1.09<br />set4    0.93<br />set5    1.71<br />set6&#160;&#160;  1.2</pre>

<p>
<a id="pgfId-1008456"></a>No comment will be made about the readability of these functions because access procedures should be made available for all data structure access anyway. It is clear from these results that there is little to be gained, in terms of speed from the choice of data structure, although arrays do seem to be fastest overall. When choosing data structures it is more important to consider the other factors mentioned in the data structures section of this document.</p>
<p>
<a id="pgfId-1008457"></a>Because the structures used contained a small number of elements, the experiment is naturally biased. You can repeat this experiment using <code>measureTime</code><a id="marker-1008458"></a> to find out how effective your data structure accesses are for a given volume of data. For example, for sets of hundreds of elements, association tables will be significantly faster to access than property lists and assoc lists. For large sets it would be impractical to use arrays or defstructs. </p>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap11.html" id="prev" title="Writing Style">Writing Style</a></em></b><b><em><a href="chap13.html" id="nex" title="About SKILL++ and SKILL">About SKILL++ and SKILL</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
 

 <div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160;⠀ </center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div> 

</body></html>