
<html><head><title>Advanced List Operations</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="parula" />
<meta name="CreateDate" content="2023-08-23" />
<meta name="CreateTime" content="1692797224" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the SKILL language to new users and helps them understand advanced topics, encourages sound SKILL programming methods, and introduces the SKILL++ language" />
<meta name="DocTitle" content="Cadence SKILL Language User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="Advanced List Operations" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-4.0.0" />
<meta name="Keyword" content="sklanguser" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-08-23" />
<meta name="ModifiedTime" content="1692797224" />
<meta name="NextFile" content="chap9.html" />
<meta name="Group" content="SKILL Language" />
<meta name="Platform" content="Cadence Shared Tools" />
<meta name="PrevFile" content="chap7.html" />
<meta name="c_product" content="Virtuoso Layout Suite,Virtuoso Schematic Editor,Virtuoso Analog Design Environment" />
<meta name="Product" content="SKILL" />
<meta name="ProductFamily" content="SKILL" />
<meta name="ProductVersion" content="IC23.1" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Cadence SKILL Language User Guide -- Advanced List Operations" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="0" />
<meta name="Version" content="IC23.1" />
<meta name="SpaceKey" content="sklanguserIC231" />
<meta name="webflare-version" content="2.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" />


  <script>/*<![CDATA[*/
 document.addEventListener("DOMContentLoaded", function(event) {  document.querySelectorAll("img").forEach((img, index) => {
if (img.hasAttribute("usemap")){return;}else{img.classList.add("cursorclass");} img.addEventListener("click", (e) => {if(img.hasAttribute("usemap")){            img.setAttribute("style","cursor:none;");return;};document.querySelector("#cad_image_modal").classList.add("opac");document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0;margin: auto;max-height:95%;"  src="${e.target.src}">`;});});});
/*]]>*/</script> 




 <style>/*<![CDATA[*/
.cursorclass{cursor:pointer;}#cad_image_modal{position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;}#cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;}#cad_image_modal span{position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;}
/*]]>*/</style> 
</head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="sklanguserTOC.html">Contents</a></li><li><a class="prev" href="chap7.html" title="I/O and File Handling">I/O and File Handling</a></li><li style="float: right;"><a class="viewPrint" href="sklanguser.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap9.html" title="Advanced Topics">Advanced Topics</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Cadence SKILL Language User Guide<br />Product Version IC23.1, September 2023</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<h1>8
<a id="pgfId-1005655"></a></h1>
<h1>
<a id="pgfId-1008199"></a><hr />
<a id="16206"></a>Advanced List Operations<hr />
</h1>

<p>
<a id="pgfId-1016380"></a><a href="chap1.html#18267">&#8220;Cadence SKILL Language&#8221;</a> introduces you to building Cadence&#174; SKILL language lists. Information in this chapter helps you perform more advanced list operations.</p>
<p>
<a id="pgfId-1016381"></a>It is helpful to understand how lists are stored in virtual memory so that you can understand how SKILL functions such as <code>car</code> and <code>cdr</code> manipulate lists and the issues behind building long lists efficiently (see <a href="chap8.html#42632">&#8220;Conceptual Background&#8221;</a>).</p>
<p>
<a id="pgfId-1009896"></a>You can read more about the following topics:</p>
<ul><li>
<a id="pgfId-1016422"></a><a href="chap8.html#21569">Summary of List Operations</a> </li><li>
<a id="pgfId-1010052"></a><a href="chap8.html#29329">Altering List Cells</a>  </li><li>
<a id="pgfId-1010058"></a><a href="chap8.html#10891">Accessing Lists</a>  </li><li>
<a id="pgfId-1010066"></a><a href="chap8.html#38897">Building Lists Efficiently</a>  </li><li>
<a id="pgfId-1010555"></a><a href="chap8.html#42576">Reorganizing a List</a> </li><li>
<a id="pgfId-1010561"></a><a href="chap8.html#41945">Searching Lists</a>  </li><li>
<a id="pgfId-1010569"></a><a href="chap8.html#42497">Copying Lists</a>  </li><li>
<a id="pgfId-1010547"></a><a href="chap8.html#39896">Filtering Lists</a>  </li><li>
<a id="pgfId-1010100"></a><a href="chap8.html#10794">Removing Elements from a List</a>  </li><li>
<a id="pgfId-1010106"></a><a href="chap8.html#79147">Substituting Elements</a>  </li><li>
<a id="pgfId-1010108"></a><a href="chap8.html#12426">Transforming Elements of a Filtered List</a>  </li><li>
<a id="pgfId-1010110"></a><a href="chap8.html#11630">Validating Lists</a>  </li><li>
<a id="pgfId-1010116"></a><a href="chap8.html#39466">Using Mapping Functions to Traverse Lists</a>  </li><li>
<a id="pgfId-1010134"></a><a href="chap8.html#34099">List Traversal Case Studies</a>  </li></ul>














<h2>
<a id="pgfId-1008211"></a><a id="42632"></a>Conceptual Background</h2>
<h3>
<a id="pgfId-1008214"></a>How Lists Are Stored in Virtual Memory</h3>

<p>
<a id="pgfId-1008216"></a>SKILL functions that manipulate <a id="marker-1008215"></a>lists and symbols deal with memory pointers. When you assign a list to a variable, the variable is internally assigned a pointer to the head of the list. When a list is taken apart by functions such as <code>car</code> and <code>cdr</code>, only pointers to various parts of the list are returned and no new list cells are created.</p>
<p>
<a id="pgfId-1008217"></a>SKILL suppresses your awareness of pointers by how it displays lists and symbols. In general, when SKILL displays a supported data type, it uses a characteristic syntax to suppress irrelevant detail and focus on the essentials of the data. This syntax has implications for list and symbol data types. Instead of displaying memory addresses, SKILL displays</p>
<ul><li>
<a id="pgfId-1008218"></a>The elements of a list surrounded by parentheses</li><li>
<a id="pgfId-1008219"></a>The name of a symbol</li></ul>


<h4>
<a id="pgfId-1008220"></a>A SKILL List as a List Cell</h4>

<p>
<a id="pgfId-1008222"></a>SKILL represents a list by means of a <a id="marker-1008221"></a>list cell. A list cell occupies two locations in virtual memory. </p>
<ul><li>
<a id="pgfId-1008223"></a>The first location holds a reference to the first element in the list. </li><li>
<a id="pgfId-1008224"></a>The second location holds a reference to the tail of the list, that is, another list cell or <code>nil</code>. </li></ul>

<p>
<a id="pgfId-1008251"></a>The expression <code>aList = &#39;( 2 3 4 )</code> allocates the following three list cells. </p>

<p>
<a id="pgfId-1010716"></a></p>
<div class="webflare-div-image">
<img width="502" height="110" src="images/chap8-2.gif" /></div>

<p>
<a id="pgfId-1008252"></a>The <code>car</code> function returns the contents of the first location of a list cell. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008253"></a>car( aList) =&gt; 2</pre>

<p>
<a id="pgfId-1008254"></a>The <code>cdr</code> function returns the contents of the second location of a list cell.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008255"></a>cdr( aList) =&gt; (3 4)</pre>
<h4>
<a id="pgfId-1008257"></a>Lists C<a id="marker-1008256"></a>ontaining Sublists</h4>

<p>
<a id="pgfId-1008303"></a>The expression <code>bList = &#39;( 1 ( 2 3 4 ) 5 )</code> allocates the following list cells. </p>

<p>
<a id="pgfId-1010753"></a></p>
<div class="webflare-div-image">
<img width="511" height="204" src="images/chap8-3.gif" /></div>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008304"></a>cadr(bList) =&gt; (2 3 4)</pre>
<h4>
<a id="pgfId-1008306"></a><a id="marker-1008305"></a>Lists Containing Symbols</h4>

<p>
<a id="pgfId-1008376"></a>The expression <code>bList = &#39;( 1 ( 2 a a ) b )</code> allocates the following list cells. </p>

<p>
<a id="pgfId-1010809"></a></p>
<div class="webflare-div-image">
<img width="520" height="284" src="images/chap8-4.gif" /></div>

<p>
<a id="pgfId-1008377"></a>Internally the expression <code>&#39;a</code> returns the pointer to the symbol <code>a</code> in the symbol table.</p>

<h3>
<a id="pgfId-1008378"></a>Destructive versus Non-Destructive Operations</h3>
<h4>
<a id="pgfId-1008379"></a>Non-Destructive Operations</h4>

<p>
<a id="pgfId-1008381"></a>The term <a id="marker-1008380"></a><code>non-destructive modification</code> refers to any operation that allocates a copy of a list that reflects the desired alteration. The original list is not altered. It is your responsibility to update any variables that need to reflect the operation.</p>
<p>
<a id="pgfId-1008382"></a>Such operations are usually easier for you to implement than destructive operations that do alter the original list. The disadvantage is that making an altered copy of the original list might be significantly time-consuming.</p>

<h4>
<a id="pgfId-1008383"></a>Destructive Operations</h4>

<p>
<a id="pgfId-1008385"></a>The term <code>destructive list modification</code><a id="marker-1008384"></a> refers to any operation that alters either the car or cdr of a list cell. Destructive modification functions do not need to create new list structures. They are therefore considerably faster than equivalent nondestructive modification functions. </p>
<p>
<a id="pgfId-1008386"></a>Depending on the operation, any variable referring to the original list can be affected. Many subtle problems can arise when these functions are used without a thorough understanding of the implications. </p>

<div class="webflare-information-macro webflare-macro-warning">
<a id="pgfId-1008387"></a>
You should only use the destructive modification functions described in this chapter with a very good understanding of how the SKILL language represents lists in virtual memory. </div>
<h2>
<a id="pgfId-1008388"></a><a id="21569"></a>Summary of List Operations</h2>

<p>
<a id="pgfId-1008390"></a>The following table summarizes<a id="marker-1008389"></a> the list operations that are discussed in this chapter. Use the destructive modification functions with great care.</p>

<p>
<a id="pgfId-1011167"></a></p>
<table class="webflareTable" id="#id1011171">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1011173"></a>List Operations</div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011181">
<a id="pgfId-1011181"></a>Operation</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011183">
<a id="pgfId-1011183"></a>Function</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011185">
<a id="pgfId-1011185"></a>Non-destructive</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011187">
<a id="pgfId-1011187"></a>Destructive</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011189"></a>Altering List Cells</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011191"></a>rplaca, rplacd</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011193"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011195"></a>x</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011197"></a>Accessing a List </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011199"></a>nthelem, nthcdr, last</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011201"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011203"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="2">
<p>
<a id="pgfId-1011205"></a>Building a List </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011207"></a>cons, ncons, xcons, append1</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011209"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011211"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011215"></a>tconc, nconc, lconc</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011217"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011219"></a>x</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="2">
<p>
<a id="pgfId-1011221"></a>Reorganizing a List</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011223"></a>reverse</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011225"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011227"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011231"></a>sort, sortcar</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011233"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011235"></a>x</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="2">
<p>
<a id="pgfId-1011237"></a>Removing Elements</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011239"></a>remove, remq</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011241"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011243"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011247"></a>remd, remdq </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011249"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011251"></a>x</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011253"></a>Searching Lists</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011255"></a>member, memq,<br />exists</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011257"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011259"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011261"></a>Filtering Lists</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011263"></a>setof</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011265"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011267"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011269"></a>Substituting</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011271"></a>subst</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011273"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011275"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1012702"></a>Traversal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1012704"></a>mapc, map, mapcar, maplist, mapcan</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1012706"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1012708"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011277"></a>Traversal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011279"></a>mapcan</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011281"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011283"></a>x</p>
</td>
</tr>
</tbody></table>
<h2>
<a id="pgfId-1008504"></a><a id="29329"></a>Altering List Cells </h2>

<p>
<a id="pgfId-1008506"></a>The most <a id="marker-1008505"></a>fundamental destructive operations concern altering a list cell. You can change either the <code>car</code> cell or the <code>cdr</code> cell. <code>rplac</code>a and <code>rplacd</code> are destructive operations. Starting from IC6.1.6, a new function, <code>setf</code>, has been introduced for altering a list cell.</p>

<h3>
<a id="pgfId-1008507"></a>The rplaca Function</h3>

<p>
<a id="pgfId-1008509"></a>Use the <a id="marker-1008508"></a><code>rplaca</code> function to replace the first element of a list.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008510"></a>aList = &#39;( 1 2 3) =&gt; ( 1 2 3 )<br />bList = rplaca( aList 4 ) =&gt; ( 4 2 3 )<br />aList =&gt; ( 4 2 3 )<br />eq( aList bList ) =&gt; t </pre>
<p>
<a id="pgfId-1010885"></a></p>
<div class="webflare-div-image">
<img width="502" height="108" src="images/chap8-6.gif" /></div>
<h3>
<a id="pgfId-1008545"></a>The rplacd Function</h3>

<p>
<a id="pgfId-1008547"></a>Use the <a id="marker-1008546"></a><code>rplacd</code> function to replace the tail of a list.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008548"></a>aList = &#39;( 1 2 3 ) =&gt; ( 1 2 3 )<br />bList = rplacd( aList &#39;( 4 5 ) ) =&gt; ( 1 4 5 )<br />aList =&gt; ( 1 4 5 )<br />eq( aList bList ) =&gt; t</pre>
<p>
<a id="pgfId-1010926"></a></p>
<div class="webflare-div-image">
<img width="532" height="183" src="images/chap8-7.gif" /></div>

<p>
<a id="pgfId-1008589"></a>Notice that the <code>rplacd</code> function returns a list with the desired modifications. An important point to remember about destructive operations is that the modified list is literally the same list in virtual memory as the original list. To verify this fact, use the <code>eq</code> function, which returns <code>t</code> if both arguments are the same object in virtual memory.</p>

<h3>
<a id="pgfId-1017501"></a>The setf function</h3>

<p>
<a id="pgfId-1018492"></a>The <code>setf</code> function assigns a new value to an existing storage location, destroying the value that was previously in that location. Basically, the function expands into an update form that takes the first argument as a <em>reference location</em>,<em> </em>evaluates the second argument, and stores the result of evaluating the second argument (new value) in the <em>reference location</em>. For example, </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017654"></a>x = &#39;(a b c d e)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018947"></a>setf((car x) 42) </pre>

<p>
<a id="pgfId-1018960"></a>displays the following return value:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018961"></a><code>(42 b c d e)</code></pre>

<p>
<a id="pgfId-1018705"></a>A main objective of the <code>setf</code> function is to allow you to write your own <code>setf</code> expanders/functions defines as <code>setf_&lt;expanders&gt;</code>) so that you can use it with your macros and functions. This means that if you want to write a<code> setf</code> function to work with a method, you need to write a defmethod form. Also, in SKILL, a generic function must be named by a symbol, so setf_ is concatenated to the getter function name, such as <code>setf_GetRandomVal</code> in the example given below. </p>
<p>
<a id="pgfId-1018990"></a></p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018991"></a>defgeneric(GetRandomVal (obj))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018992"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018987"></a>defclass( Random () ())</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018596"></a>defclass( SemiRandom (Random)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018597"></a>  (nextval( @initform nil)))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018598"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018599"></a>defmethod( GetRandomVal ((self Random))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018600"></a>  (random))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018601"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018602"></a>defmethod( GetRandomVal ((self SemiRandom))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018603"></a> if( self-&gt;nextval</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018604"></a>      (prog1</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018605"></a>  self-&gt;nextval</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018606"></a>       self-&gt;nextval = nil)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018607"></a>      (callNextMethod))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1020594"></a>)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018608"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018609"></a>defmethod( setf_GetRandomVal (value (self Random))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018610"></a> error( &quot;Random objects may not have their random value set&quot;))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018611"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018612"></a>defmethod( setf_GetRandomVal ((value fixnum) (self SemiRandom))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018613"></a>  self-&gt;nextval = value</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1020607"></a>)</pre>

<p>
<a id="pgfId-1020373"></a>The list of <code>setf_ expanders</code> available in SKILL Language are as follows: setf helpers: (public functions)</p>
<p>
<a id="pgfId-1020441"></a></p>
<table class="webflareTable" id="#id1020374">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020376"></a><code>setf_car </code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020378"></a><code>setf_cdr </code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020380"></a><code>setf_cadr</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020382"></a><code>setf_caar</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020384"></a><code>setf_cdar</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020386"></a><code>setf_cddr</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020388"></a><code>setf_caaar</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020390"></a><code>setf_caadr</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020392"></a><code>setf_cadar</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020394"></a><code>setf_cdaar</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1020396"></a><code>setf_caddr</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020398"></a><code>setf_cddar</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020400"></a><code>setf_cdadr</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020402"></a><code>setf_cdddr</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020404"></a><code>setf_last </code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020406"></a><code>setf_arrayref</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020408"></a><code>setf_nth</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020410"></a><code>setf_nthelem</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020412"></a><code>setf_nthcdr</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020414"></a><code>setf_xCoord</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020416"></a><code>setf_yCoord</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020418"></a><code>setf_leftEdge</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020420"></a><code>setf_rightEdge</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020422"></a><code>setf_bottomEdge</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020424"></a><code>setf_topEdge</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020426"></a><code>setf_upperRight</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020428"></a><code>setf_lowerLeft</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020430"></a><code>setf_getd</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020432"></a><code>setf_get</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020434"></a><code>setf_getq</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020436"></a><code>setf_getSGq</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020438"></a><code>setf_slotValue</code></p>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1020440"></a><code>setf_getShellEnvVar</code></p>

</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1019034"></a>Consider an example of using the <code>setf_cadr</code> helper function: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1020284"></a>data = list(1 2 3 4 5)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1020285"></a>setf((cadr data) 42) </pre>

<p>
<a id="pgfId-1020286"></a>The return value is: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1020287"></a>(1 42 3 4 5)</pre>

<p>
<a id="pgfId-1020272"></a></p>

<h2>
<a id="pgfId-1018204"></a><a id="10891"></a>Accessing Lists</h2>

<p>
<a id="pgfId-1008592"></a>The following <a id="marker-1008591"></a>functions are convenient variations and extensions of the <code>cdr </code>and<code> nth</code> functions introduced in <a href="chap1.html#18267">&#8220;Cadence SKILL Language&#8221;</a>. </p>

<h3>
<a id="pgfId-1008596"></a>Selecting an Indexed Element from a List (nthelem)</h3>

<p>
<a id="pgfId-1008598"></a><code>nthelem</code><a id="marker-1008597"></a> returns an indexed element of a list, assuming a one-based index. Thus <code>nthelem(1 l_list)</code> is the same as <code>car(l_list)</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1021033"></a>nthelem( 1 &#39;( a b c ) )     =&gt; a<br />z = &#39;( 1 2 3 )<br />nthelem( 2 z )&#160;&#160;                           =&gt; 2</pre>
<h3>
<a id="pgfId-1021040"></a>Applying cdr to a List a Given Number of Times (nthcdr)</h3>

<p>
<a id="pgfId-1008602"></a>You supply the iteration <a id="marker-1008601"></a>count and the list of elements.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008603"></a>nthcdr( 3 &#39;( a b c d ))     =&gt; (d)<br />z = &#39;( 1 2 3 )<br />nthcdr( 2 z )&#160;&#160;                             =&gt; ( 3 )</pre>
<h3>
<a id="pgfId-1008604"></a>Getting the Last List Cell in a List (last)</h3>

<p>
<a id="pgfId-1008606"></a><code>last</code><a id="marker-1008605"></a> returns the last list cell in a list. The <code>car</code> of the last list cell is the last element in the list. The <code>cdr</code> of the last list cell is <code>nil</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008607"></a>last( &#39;(a b c) ) =&gt; (c)<br />z = &#39;( 1 2 3 )<br />last( z )&#160;&#160;      =&gt; (3)</pre>
<h2>
<a id="pgfId-1008608"></a><a id="38897"></a>Building Lists Efficiently</h2>

<p>
<a id="pgfId-1008610"></a>To build <a id="marker-1008609"></a>lists efficiently, you must understand how lists are constructed. Using a function like <code>append</code> involves searching for the end of a list, which can be unacceptably slow for large lists.</p>

<h3>
<a id="pgfId-1008611"></a>Adding Elements to the Front of a List (cons, xcons)</h3>

<p>
<a id="pgfId-1008612"></a>If order is unimportant, the easiest way to build a list is to repeatedly call <code>cons</code> to add new elements at the head of the list. </p>
<p>
<a id="pgfId-1008614"></a>The <a id="marker-1008613"></a><code>cons</code> function allocates a new list cell consisting of two memory locations. It stores its first argument in the first location and its second argument in the second location. </p>
<p>
<a id="pgfId-1008615"></a>The <code>cons</code> function returns a list whose first element is the one you supplied (1 below) and whose <code>cdr</code> is the list you supplied (aList below). The expressions</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008616"></a>aList = &#39;( 2 3 4 )<br />aList = cons( 1 aList ) =&gt; (1 2 3 4 )</pre>

<p>
<a id="pgfId-1008654"></a>allocate the following. </p>

<p>
<a id="pgfId-1010973"></a></p>
<div class="webflare-div-image">
<img width="518" height="198" src="images/chap8-8.gif" /></div>

<p>
<a id="pgfId-1008656"></a><code>xcons</code><a id="marker-1008655"></a> accepts the same arguments as the <code>cons</code> function, but in reverse order. <code>xcons</code> adds an element to the beginning of a list, which can be <code>nil</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008657"></a>xcons( &#39;( b c ) &#39;a ) =&gt; ( a b c )</pre>
<h3>
<a id="pgfId-1008658"></a>Building a List with a Given Element (ncons)</h3>

<p>
<a id="pgfId-1008660"></a>ncons<a id="marker-1008659"></a> builds a list by adding the <code>element</code> you supply to the beginning of an empty list. It is equivalent to <code>cons( g_element nil )</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008661"></a>ncons( &#39;a )      =&gt; ( a )         ;;; equivalent to cons( &#39;a nil )<br />z = &#39;( 1 2 3 )<br />ncons( z )&#160;&#160;    =&gt; ( ( 1 2 3 ) ) ;;; equivalent to cons( z nil )</pre>
<h3>
<a id="pgfId-1008662"></a>Adding Elements to the End of a List (tconc)</h3>

<p>
<a id="pgfId-1008663"></a>Because lists are singly linked in only one direction, searching for the end of a list typically requires the traversal of every list cell in the list, which can be slow with a long list containing many list cells. This long traversal poses a problem when you want to build a list by adding elements at the end of a list. If a list must be built by adding new elements at the end of the list, the most efficient way is to use <code>tconc</code>. </p>
<p>
<a id="pgfId-1008665"></a>The <a id="marker-1008664"></a><code>tconc</code> function creates a list cell (known as a <code>tconc</code> structure) whose <code>car</code> points to the head of the list being built and whose <code>cdr</code> points to the last element of the list. </p>

<p>
<a id="pgfId-1008688"></a></p>
<div class="webflare-div-image">
<img width="492" height="174" src="images/chap8-9.gif" /></div>

<p>
<a id="pgfId-1008689"></a>The <code>tconc</code> structure allows subsequent calls to <code>tconc</code> to find the end of a list instantly without having to traverse the entire list. For this reason, call <code>tconc</code> once to initialize a special list cell and pass this special list cell to subsequent calls on <code>tconc</code>. Finally, to obtain the value of the list you have been building, take the <code>car</code> of this special list cell. The typical steps required to use <code>tconc</code> are as follows:</p>
<ol><li>
<a id="pgfId-1008690"></a>Create the <code>tconc</code> structure by calling <code>tconc</code> with <code>nil</code> as its first argument and the first element of the list being built as the second argument. <br /><pre class="webflare-pre-block webflare-courier-new" id="#id1008691">
<a id="pgfId-1008691"></a>x = tconc(nil 1 )</pre></li><li>
<a id="pgfId-1008692"></a>Repeatedly call <code>tconc</code> with other elements to be added to the end of the list, each time giving the <code>tconc</code> structure as the first argument to <code>tconc</code>. There is no need to assign the value returned by <code>tconc</code> to a variable because <code>tconc</code> modifies the <code>tconc</code> structure. For example:<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1008693">
<a id="pgfId-1008693"></a>tconc(x 2 ), tconc(x 3 ) &#8230;</pre></li><li>
<a id="pgfId-1008694"></a>After the list has been built, take the <code>car</code> of the <code>tconc</code> structure to get the value of the list being built. For example:<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1008695">
<a id="pgfId-1008695"></a>x = car(x)</pre></li></ol>






<h3>
<a id="pgfId-1008697"></a><a id="marker-1008696"></a>Appending Lists</h3>
<h4>
<a id="pgfId-1008698"></a>The nconc Function</h4>

<p>
<a id="pgfId-1008700"></a>Use the <a id="marker-1008699"></a><code>nconc</code> function to quickly append lists destructively. The <code>nconc</code> function takes two or more lists as arguments. Only the last argument list is unaltered.</p>

<p>
<a id="pgfId-1011017"></a></p>
<div class="webflare-div-image">
<img width="532" height="257" src="images/chap8-10.gif" /></div>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008764"></a>cList = &#39;( 1 2 )<br />dList = &#39;( 3 4 5 )<br />eList = &#39;( 6 7 )<br />nconc( cList dList eList ) =&gt; ( 1 2 3 4 5 6 7 )<br />cList =&gt; ( 1 2 3 4 5 6 7 )<br />dList =&gt; ( 3 4 5 6 7 )<br />eList =&gt; ( 6 7 ) </pre>

<p>
<a id="pgfId-1008766"></a>Use the <a id="marker-1008765"></a><code>apply</code> function and the <code>nconc</code> function to append a list of lists.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008767"></a>apply( &#39;nconc &#39;( ( 1 2 ) ( 3 4 5 ) ( 6 7 )) )<br />=&gt; (1 2 3 4 5 6 7 )</pre>
<h4>
<a id="pgfId-1008768"></a>The lconc Function</h4>

<p>
<a id="pgfId-1008769"></a><code>lconc</code> uses a <code>tconc</code> structure to efficiently splice lists to the end of lists. The <code>tconc</code> structure must initially be created using the <code>tconc</code><a id="marker-1008770"></a> function. See the example below.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008771"></a>x = tconc(nil 1)             ; x is initialized ((1) 1)<br />lconc(x &#39;(2 3 4))            ; x is now ((1 2 3 4) 4)<br />lconc(x nil)                 ; Nothing is added to x.<br />lconc(x &#39;(5))                ; x is now ((1 2 3 4 5) 5)<br />x = car( x )&#160;&#160;               ; x is now (1 2 3 4 5)</pre>
<h2>
<a id="pgfId-1008772"></a><a id="42576"></a>Reorganizing a List</h2>

<p>
<a id="pgfId-1008774"></a>SKILL provides several functions that <a id="marker-1008773"></a>reorganize a list. Sometimes the most efficient way to build a list is to reverse it or sort it after you have built it incrementally with the <code>cons</code> function. These functions change the sequence of the top-level elements of your list.</p>

<h3>
<a id="pgfId-1008775"></a>Reversing a List</h3>

<p>
<a id="pgfId-1008776"></a>The following is a non-destructive operation.</p>

<h4>
<a id="pgfId-1008778"></a>Reversing the Order of Elements in a List (<a id="marker-1008777"></a>reverse)</h4>

<p>
<a id="pgfId-1008779"></a><code>reverse</code> returns the top-level elements of a list in reverse order. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008780"></a>aList = &#39;( 1 2 3 )<br />aList = reverse( aList ) =&gt; ( 3 2 1 )<br />anotherList = &#39;( 1 2 ( 3 4 5 ) 6 )<br />reverse( anotherList ) =&gt; ( 6 ( 3 4 5 ) 2 1 )</pre>

<p>
<a id="pgfId-1008781"></a>Although <code>reverse( anotherList )</code> returns the list in reverse order, the value of <code>anotherList</code>, the original list, is not modified. It is your responsibility to update any variables that you want to reflect this reversal.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008782"></a>anotherList =&gt; ( 1 2 ( 3 4 5 ) 6 )</pre>
<h3>
<a id="pgfId-1008783"></a>Sorting Lists</h3>

<p>
<a id="pgfId-1008784"></a>The following functions are helpful when you must sort lists according to various criteria and locate elements within lists. They are destructive operations.</p>

<h4>
<a id="pgfId-1008785"></a>The sort Function</h4>

<p>
<a id="pgfId-1008786"></a>The syntax statement for the <code>sort</code> function is</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008787"></a>sort( l_data u_comparefn ) =&gt; l_result</pre>

<p>
<a id="pgfId-1008789"></a><code>sort</code> sorts a list of objects (<code>l_data</code>) according to the <code>sort</code><a id="marker-1008788"></a> function (<code>u_comparefn</code>) you supply. <code>u_comparefn( g_x g_y )</code> returns non-<code>nil</code> if <code>g_x</code> can precede <code>g_y</code> in sorted order and <code>nil</code> if <code>g_y</code> must precede <code>g_x</code>. If <code>u_comparefn</code> is <code>nil</code>, alphabetical order is used. The algorithm in <code>sort</code> is based on recursive merge sort.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011346"></a>sort( &#39;(4 3 2 1) &#39;lessp )         =&gt; (1 2 3 4)<br />sort( &#39;(d b c a) &#39;alphalessp) =&gt; (a b c d)</pre>
<h4>
<a id="pgfId-1011347"></a>The sortcar Function</h4>

<p>
<a id="pgfId-1008793"></a><code>sortcar</code><a id="marker-1008792"></a> is similar to <code>sort</code> except that only the <code>car</code> of each element in a list is used for comparison by the sort function.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008794"></a>sortcar( &#39;((4 four) (3 three) (2 two)) &#39;lessp )<br />=&gt; ((2 two) (3 three) (4 four)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008795"></a>sortcar( &#39;((d 4) (b 2) (c 3) (a 1)) nil )<br />=&gt; ((a 1) (b 2) (c 3) (d 4))</pre>

<p>
<a id="pgfId-1008796"></a>The list is modified in place and no new storage is allocated. Pointers previously pointing to the list might not be pointing at the head of the sorted list.</p>

<h2>
<a id="pgfId-1008798"></a><a id="41945"></a>Searching L<a id="marker-1008797"></a>ists</h2>

<p>
<a id="pgfId-1008799"></a>SKILL provides several functions for locating elements within a list that satisfy a criterion. The most basic criterion is equality, which in SKILL can mean either <code>value equality</code> or <code>memory address equality</code>. </p>

<h3>
<a id="pgfId-1008800"></a>The member Function </h3>

<p>
<a id="pgfId-1008805"></a>The <a id="marker-1008801"></a><code>member</code> function is briefly discussed in <a href="chap1.html#18267">&#8220;Cadence SKILL Language&#8221;</a>. It uses the <code>equal</code> function as the basis for finding a top-level element in a list. The <code>member</code> function </p>
<ul><li>
<a id="pgfId-1008806"></a>Returns <code>nil</code> if the element is not equal to any top-level element in the list. </li><li>
<a id="pgfId-1008807"></a>Returns the first tail of the list that starts with the element.</li></ul>

<p>
<a id="pgfId-1008808"></a>Some examples include</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008809"></a>member( 3 &#39;( 2 3 4 3 5 )) =&gt; (3 4 3 5)<br />member( 6 &#39;( 2 3 4 3 5 )) =&gt; nil</pre>

<p>
<a id="pgfId-1008810"></a>The <code>member</code> function resembles the <code>cdr</code> function in that it internally returns a pointer to a list cell. The <code>car</code> of the list cell is equal to the element. You can use the <code>member</code> function with the <code>rplaca</code> function to destructively substitute one element for the first top-level occurrence of another in a list. For example, find the first occurrence of 3 and replace it with 6:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008811"></a>rplaca( <br />      member( 3 &#39;( 2 3 4 3 5 )) <br />      6 )</pre>

<p>
<a id="pgfId-1008812"></a>SKILL provides a non-destructive <code>subst</code> function for substituting an element at all levels of a list. See <a href="chap8.html#79147">&#8220;Substituting Elements&#8221;</a>. </p>

<h3>
<a id="pgfId-1008816"></a>The memq Function</h3>

<p>
<a id="pgfId-1008818"></a>The <a id="marker-1008817"></a><code>memq</code> function is the same as the <code>member</code> function except that it uses the <code>eq</code> function for finding the element. Because the <code>eq</code> function is more efficient than the <code>equal</code> function, use <code>memq</code> whenever possible based on the nature of the data. For example, if the list to search contains only symbols, then using the <code>memq</code> function is more efficient than using the <code>member</code> function.</p>

<h3>
<a id="pgfId-1008819"></a>The exists Function</h3>

<p>
<a id="pgfId-1008821"></a>The <a id="marker-1008820"></a><code>exists</code> function can use an application-specific testing function to locate the first occurrence of an element in a list. The <code>exists</code> function generalizes the <code>member</code> and <code>memq</code> functions, which locate the first occurrence of an element in a list based on equality.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008822"></a>exists( x &#39;( 2 4 7 8 ) oddp( x ) ) =&gt; ( 7 8 )<br />exists( x &#39;( 2 4 6 8 ) evenp( x ) ) =&gt; ( 2 4 6 8 )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1021028"></a>exists( x &#39;(1 2 3 4) (x &gt; 1) )&#160;&#160;&#160;&#160;=&gt; (2 3 4)
exists( x &#39;(1 2 3 4) (x &gt; 4) )&#160;&#160;&#160;&#160;=&gt; nil</pre>
<h3>
<a id="pgfId-1021053"></a>The lindex Function</h3>

<p>
<a id="pgfId-1021055"></a>The<code> lindex</code><a id="marker-1021054"></a> function returns the index number of the given element in a list. <code>lindex(l_list g_element)</code>returns <code>nil</code> if the given element is not present in the list.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1021056"></a>lindex(&#39;(1 2 3 4) 2)&#160;&#160;   =&gt; 2</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1021057"></a>lindex(&#39;(1 6 4 5) 4)&#160;&#160;   =&gt; 3</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1021058"></a>lindex(&#39;(1 4 6 7) 3)&#160;&#160;   =&gt; nil</pre>
<h2>
<a id="pgfId-1021030"></a><a id="42497"></a>Copying Lists</h2>

<p>
<a id="pgfId-1008825"></a>Sometimes it is more efficient to apply a destructive operation to a copy of a list than it is to apply a non-destructive operation. First determine whether a shallow copy of only the top-level elements is sufficient.</p>

<h3>
<a id="pgfId-1008826"></a>The copy Function</h3>

<p>
<a id="pgfId-1008829"></a><code>copy</code><a id="marker-1008827"></a> returns a copy of a list. <a id="marker-1008828"></a>copy only duplicates the top-level list cells. All lower-level objects are still shared. You should consider making a copy of any list before using a destructive modification on the list.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008830"></a>z = &#39;(1 (2 3) 4)  =&gt; (1 (2 3) 4)<br />x = copy(z)       =&gt; (1 (2 3) 4)<br />equal(z x)&#160;&#160;      =&gt; t</pre>

<p>
<a id="pgfId-1008831"></a>z and x have the same value.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008832"></a>eq(z x)&#160;&#160;        =&gt; nil</pre>

<p>
<a id="pgfId-1008833"></a>z and x are not the same list.</p>

<h3>
<a id="pgfId-1008835"></a>Copying a List <a id="marker-1008834"></a>Hierarchically </h3>

<p>
<a id="pgfId-1008836"></a>The following function recursively copies a list.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008837"></a>procedure( trDeepCopy( arg )<br />      cond( <br />            ( !arg nil )<br />            ( listp( arg );;; argument is a list <br />                  cons( <br />                        trDeepCopy( car( arg ) )<br />                        trDeepCopy( cdr( arg ) )<br />                        )<br />                  )<br />            ( t arg ) ;;; return the argument itself<br />            ) ; cond<br />      ) ; procedure</pre>
<h2>
<a id="pgfId-1008839"></a><a id="39896"></a>F<a id="marker-1008838"></a>iltering Lists</h2>

<p>
<a id="pgfId-1008840"></a>Many list operations can be abstractly considered as making a filtered copy of a list. The filter can be any function that accepts a single argument. If the filter function returns non-<code>nil,</code> the element is included in the new list. If the filter function returns <code>nil</code>, the element is excluded from the new list. </p>
<p>
<a id="pgfId-1008843"></a><code>setof</code><a id="marker-1008842"></a> makes a filtered copy of the top-level elements of a list, including all elements that satisfy a given criteria. For example, contrast the following two approaches to computing the intersection of two lists. </p>
<ul><li>
<a id="pgfId-1008844"></a>One way to proceed is to use the <code>cons</code> function as follows:<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1008845">
<a id="pgfId-1008845"></a>procedure( trIntersect( list1 list2 )
      let( ( result )
            foreach( element1 list1
                  when( member( element1 list2 )
                        result = cons( element1 result )
                        ) ; when
                  ) ; foreach
            result
            ) ; let
      ) ; procedure</pre></li><li>
<a id="pgfId-1008846"></a>The more efficient way is as follows:<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1008847">
<a id="pgfId-1008847"></a>procedure( trIntersect( list1 list2 )
      setof( 
            element list1 
            member( element list2 ) )
      ) ; procedure</pre></li></ul>



<p>
<a id="pgfId-1008848"></a>The criteria is used to decide whether to include each element of the list. The copied element is not transformed. </p>

<h2>
<a id="pgfId-1008850"></a><a id="marker-1008849"></a><a id="10794"></a>Removing Elements from a List</h2>

<p>
<a id="pgfId-1008851"></a>SKILL has several functions that remove all top-level occurrences of an element from a list.</p>

<p>
<a id="pgfId-1011088"></a></p>
<table class="webflareTable" id="#id1011096">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1011098"></a>The Removal Function</div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011104">
<a id="pgfId-1011104"></a></span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011106">
<a id="pgfId-1011106"></a>Non-destructive</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011108">
<a id="pgfId-1011108"></a>Destructive</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011110"></a>Uses equal</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011112"></a>remove</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011114"></a>remd</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011116"></a>Uses eq</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011118"></a>remq</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011120"></a>remdq</p>
</td>
</tr>
</tbody></table>
<h3>
<a id="pgfId-1008877"></a>Non-Destructive Operations</h3>
<h4>
<a id="pgfId-1008879"></a>The <a id="marker-1008878"></a>remove Function </h4>

<p>
<a id="pgfId-1008880"></a><code>remove</code> returns a copy of an argument with all top-level elements equal to a given SKILL object removed. The <code>equal</code> function, which implements the = operator, is used to test for equality.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008881"></a>aList = &#39;( 1 2 3 4 5 )<br />remove( 3 aList ) =&gt; ( 1 2 4 5 )<br />aList =&gt; ( 1 2 3 4 5 )</pre>

<p>
<a id="pgfId-1008882"></a>It is your responsibility to make the appropriate assignment so that <code>aList</code> reflects the removal.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008883"></a>aList = remove( 3 aList )</pre>

<p>
<a id="pgfId-1008884"></a>The element to remove can itself be a list. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008885"></a>remove( &#39;( 1 2 ) &#39;( 1 ( 1 2 ) 3 )) =&gt; ( 1 3 )</pre>
<h4>
<a id="pgfId-1008887"></a>The<a id="marker-1008886"></a> remq Function</h4>

<p>
<a id="pgfId-1008888"></a><code>remq</code> returns a copy of an argument list with all top-level elements equal to a given SKILL object removed. The <code>eq</code> function is used to test for equality. This function is faster than the <code>remove</code> function because the <code>eq</code> equality test is faster than the <code>equal</code> equality test. However, the <code>eq</code> test is only meaningful for certain data types, such as symbols and lists. The <code>remq</code> function is appropriate, for example, when dealing with a list of symbols.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008889"></a>remq( &#39;x &#39;( a b x d f x g ) ) =&gt; ( a b d f g )</pre>

<p>
<a id="pgfId-1008890"></a>The <code>remq</code> function does not work on association tables.</p>

<h3>
<a id="pgfId-1008891"></a>Destructive Operations</h3>
<h4>
<a id="pgfId-1008893"></a>The <a id="marker-1008892"></a>remd Function</h4>

<p>
<a id="pgfId-1008894"></a>remd removes all top-level elements equal to a given SKILL object from a list. remd uses equal for comparison. This is a destructive removal.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008895"></a>remd( &quot;x&quot; &#39;(&quot;a&quot; &quot;b&quot; &quot;x&quot; &quot;d&quot; &quot;f&quot;)) =&gt; (&quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;f&quot;)</pre>
<h4>
<a id="pgfId-1022658"></a>Example</h4>

<p>
<a id="pgfId-1022659"></a>In order to remove the first element from the original list, use the same variable (that holds the original list) to hold the updated list.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1022660"></a>y = &#39;(&quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;f&quot;)&#160;&#160;    =&gt;  (&quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;f&quot;)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1022661"></a>y=remd(&quot;a&quot; y)&#160;&#160;             =&gt;  (&quot;b&quot; &quot;d&quot; &quot;f&quot;)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1022662"></a>y&#160;&#160;                         =&gt;  (&quot;b&quot; &quot;d&quot; &quot;f&quot;)</pre>
<h4>
<a id="pgfId-1008897"></a>The <a id="marker-1008896"></a>remdq Function</h4>

<p>
<a id="pgfId-1008898"></a><code>remdq</code> removes all top-level elements equal to the first argument from a list. <code>remdq</code> uses eq instead of equal for comparison. This is a destructive removal.</p>
<p>
<a id="pgfId-1008899"></a>remdq(&#39;x &#39;(a b x d f x g)) =&gt; (a b d f g)</p>

<h2>
<a id="pgfId-1008902"></a><a id="marker-1008900"></a><a id="79147"></a>Substituting Elements</h2>

<p>
<a id="pgfId-1008903"></a>The <code>subst</code> function is a non-destructive operation. It is your responsibility to update any variables that you want to reflect this substitution.</p>

<h4>
<a id="pgfId-1008904"></a>Substituting One Object for Another Object in a List (subst)</h4>

<p>
<a id="pgfId-1008906"></a><code>subst</code> returns the result of substituting the <code>new object</code><a id="marker-1008905"></a> (first argument) for all equal occurrences of the <code>previous object </code>(second argument) at all levels in a list.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008907"></a>aList = &#39;( a b c )            =&gt; ( a b c )<br />subst( &#39;a &#39;b aList )          =&gt; ( a a c )<br />anotherList = &#39;( a b y ( d y ( e y )))<br />subst(&#39;x &#39;y anotherList )&#160;&#160;   =&gt; ( a b x ( d x ( e x )))</pre>

<p>
<a id="pgfId-1008908"></a>Although <code>subst(&#39;x &#39;y anotherList )</code> returns a list reflecting the desired substitutions, the value of <code>anotherList</code>, the original list, is not modified. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008909"></a>anotherList =&gt; ( a b y ( d y ( e y )))</pre>
<h2>
<a id="pgfId-1008910"></a><a id="12426"></a>Transforming Elements of a Filtered List</h2>

<p>
<a id="pgfId-1008912"></a>Many<a id="marker-1008911"></a> list operations can be modeled as a filtering pass followed by a transformational pass. For example, suppose you are given a list of integers and you want to build a list of the squares of the odd integers.</p>

<h4>
<a id="pgfId-1008913"></a>Phase I: Filter the odd integers into a list.</h4>

<p>
<a id="pgfId-1008914"></a>You can use the <code>setof</code> function here.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008915"></a>setof( x &#39;( 1 2 3 4 5 6 ) oddp(x)) =&gt; ( 1 3 5 )</pre>
<h4>
<a id="pgfId-1008916"></a>Phase II: Square each element of the list.</h4>

<p>
<a id="pgfId-1008917"></a>You can use the <code>mapcar</code> function together with a function that squares its argument:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008918"></a>mapcar( <br />      lambda( (x) x*x ) ;; square my argument<br />      &#39;( 1 3 5 ) <br />      ) =&gt; ( 1 9 25 )</pre>

<p>
<a id="pgfId-1008919"></a>or use the <code>foreach</code> function:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008920"></a>foreach( mapcar x &#39;( 1 3 5 ) x*x ) =&gt; ( 1 9 25 )</pre>

<p>
<a id="pgfId-1008921"></a>The <code>trListOfSquares</code> function summarizes this approach.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008922"></a>procedure( trListOfSquares( aList )<br />      let( ( filteredList )<br />            filteredList = <br />                  setof( element aList oddp( element ))<br />            foreach( mapcar element filteredList<br />                  element * element<br />                  ) ; foreach<br />            ) ; foreach<br />      ) ; procedure<br />
trListOfSquares( &#39;( 1 2 3 4 5 6 )) =&gt; ( 1 9 25 )</pre>
<h2>
<a id="pgfId-1008924"></a><a id="marker-1008923"></a><a id="11630"></a>Validating Lists</h2>

<p>
<a id="pgfId-1008925"></a>A predicate is a function that validates that a single SKILL object satisfies a criterion. SKILL provides many basic predicates. (Refer to <a href="chap5.html#37476">&#8220;SKILL Predicates&#8221;</a> and <a href="chap5.html#22570">&#8220;Type Predicates&#8221;</a>.) Predicates return <code>t </code>or<code> nil</code>.</p>
<p>
<a id="pgfId-1008935"></a>SKILL provides the <code>forall</code> function and the <code>exists</code> function so you can check whether all elements or some elements in a list satisfy a criterion. These two functions correspond to quantifiers in mathematical logic. </p>
<ul><li>
<a id="pgfId-1008936"></a><code>forall</code> is represented mathematically as ∀. </li><li>
<a id="pgfId-1008937"></a><code>exists</code> is represented mathematically as ∃.</li></ul>

<p>
<a id="pgfId-1008938"></a>The criterion is represented by a SKILL expression with a single argument that you identify as the first argument to the <code>forall</code> or <code>exists</code> function.</p>

<h3>
<a id="pgfId-1008939"></a>The forall Function</h3>

<p>
<a id="pgfId-1008940"></a><code>forall</code> verifies that an expression remains true for every element in a list. The <a id="marker-1008941"></a><code>forall</code> function can also be used to verify that an expression remains true for every key/value pair in an association table. (Refer to <a href="chap4.html#36049">&#8220;Association Tables&#8221;</a> for further details.)</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008945"></a>forall( x &#39;( 2 4 6 8 ) evenp( x ) ) =&gt; t<br />forall( x &#39;( 2 4 7 8 ) evenp( x ) ) =&gt; nil </pre>
<h3>
<a id="pgfId-1008946"></a>The exists Function</h3>

<p>
<a id="pgfId-1008947"></a><code>exists</code> can use an application-specific testing function to locate the first occurrence of an element in a list based on equality. The <code>exists</code><a id="marker-1008948"></a> function generalizes the <code>member</code> and <code>memq</code> functions, which locate the first occurrence of an element in a list based on equality.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008949"></a>exists( x &#39;( 2 4 7 8 ) oddp( x ) ) =&gt; ( 7 8 )<br />exists( x &#39;( 2 4 6 8 ) evenp( x ) ) =&gt; ( 2 4 6 8 )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008950"></a>exists( x &#39;(1 2 3 4) (x &gt; 1) )&#160;&#160;&#160;&#160;=&gt; (2 3 4)
exists( x &#39;(1 2 3 4) (x &gt; 4) )&#160;&#160;&#160;&#160;=&gt; nil</pre>
<h2>
<a id="pgfId-1008951"></a><a id="39466"></a>Using Mapping Functions to Traverse Lists</h2>

<p>
<a id="pgfId-1008953"></a>SKILL provides a family of <a id="marker-1008952"></a>powerful functions for iterating over lists. For historical reasons, these are called mapping functions. The mapping functions are <code>map</code>, <code>mapc</code>, <code>mapcar</code>, <code>mapcan</code>, <code>maplist</code>, and <code>mapcon</code>. </p>
<p>
<a id="pgfId-1008954"></a>All <code>map</code>* functions have the same arguments.</p>
<ul><li>
<a id="pgfId-1008955"></a>A function, which must take a single argument</li><li>
<a id="pgfId-1008956"></a>A list</li></ul>


<h3>
<a id="pgfId-1008957"></a>Using lambda with the map* Functions</h3>

<p>
<a id="pgfId-1008959"></a>It is often convenient to use the <a id="marker-1008958"></a><code>lambda</code> construct to define a nameless function to be used as the first argument. </p>
<p>
<a id="pgfId-1008960"></a>For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008961"></a>mapcar( <br />      lambda( ( x ) list( x x**2 )) ;;; return pair of x x**x<br />      &#39;(0 1 2 3 ))<br />      =&gt; ( (0 0) (1 1) (2 4) (3 9) )</pre>

<p>
<a id="pgfId-1008964"></a>Refer to <a href="chap3.html#92010">&#8220;Syntax Functions for Defining Functions&#8221;</a> for further details on the <code>lambda</code> construct.</p>

<h3>
<a id="pgfId-1008966"></a>Using the map* Functions with the foreach Function</h3>

<p>
<a id="pgfId-1008967"></a>Alternatively, you can use each mapping function as an option to the <code>foreach</code><a id="marker-1008968"></a> function. Often, using the <code>foreach</code> function results in more understandable code.</p>
<p>
<a id="pgfId-1008969"></a>For example, the following are equivalent.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008970"></a>foreach( mapcar x &#39;( 0 1 2 3 )<br />      list( x x**2 ) ;;; build 2 element list of a x and x*x<br />      ) <br />      =&gt; ( (0 0) (1 1) (2 4) (3 9) )<br />
mapcar( 
&#160;&#160;    lambda( ( x ) list( x x**2 )) ;;; return pair of x x**x<br />      &#39;(0 1 2 3 ))</pre>

<p>
<a id="pgfId-1008971"></a>The relationship between the two usages of the mapping functions is tight. When you use the <code>foreach</code> function, SKILL incorporates the expressions within the <code>foreach</code> body in a <code>lambda</code> function as illustrated below. This <code>lambda</code> function is passed to the mapping function. For example, the following are equivalent:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008972"></a>foreach( mapcar x aList <br />      exp1()<br />      exp2()<br />      exp3()<br />      )<br />
mapcar( 
&#160;&#160;    lambda( ( x ) <br />            exp1() <br />            exp2() <br />            exp3() <br />            )<br />      aList<br />      )</pre>

<p>
<a id="pgfId-1008973"></a>The following descriptions illustrate both approaches to using each mapping function. </p>

<h3>
<a id="pgfId-1008974"></a>The mapc Function</h3>

<p>
<a id="pgfId-1008976"></a>The <a id="marker-1008975"></a><code>mapc</code> function is the default mapping function used by the <code>foreach</code> macro. When used with the <code>foreach</code> function </p>
<ul><li>
<a id="pgfId-1008977"></a>The <code>foreach</code> function iterates over each element of the argument list.</li><li>
<a id="pgfId-1008978"></a>At each iteration, the current element is available in the loop variable of the <code>foreach</code>. </li><li>
<a id="pgfId-1008979"></a>The <code>foreach</code> function returns the original argument list as a result. </li></ul>


<p>
<a id="pgfId-1008980"></a>For example: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008981"></a>foreach( mapc x &#39;(1 2 3 4 5) <br />      println(x)<br />) </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008982"></a>mapc( <br />      lambda( ( x ) println( x ) ) <br />      &#39;( 1 2 3 4 5 )<br />      ) </pre>

<p>
<a id="pgfId-1008983"></a>displays the following:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008984"></a>1 <br />2 <br />3 <br />4 <br />5 </pre>

<p>
<a id="pgfId-1008985"></a>The return value is <code>(1 2 3 4 5)</code>.</p>

<h3>
<a id="pgfId-1008986"></a>The map Function</h3>

<p>
<a id="pgfId-1008988"></a>The <a id="marker-1008987"></a><code>map</code> function is useful for processing each list cell because it uses <code>cdr</code> to step down the argument list. When used with the <code>foreach</code> function </p>
<ul><li>
<a id="pgfId-1008989"></a>The <code>foreach</code> function iterates over each list cell of its argument.</li><li>
<a id="pgfId-1008990"></a>At each iteration, the current list cell is available in the loop variable of the <code>foreach</code>.</li><li>
<a id="pgfId-1008991"></a>The <code>foreach</code> function returns the original argument list as a result. </li></ul>


<p>
<a id="pgfId-1008992"></a>For example, suppose you want to make substitutions at the top-level of a list using a look-up table such as the following:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008993"></a>trLookUpList = &#39;(<br />      ( 1 &quot;one&quot; )<br />      ( 2 &quot;two&quot; )<br />      ( 3 &quot;three&quot; ))</pre>

<p>
<a id="pgfId-1008994"></a>By using the <code>map</code> function, you gain access to each successive list cell, allowing you to use the <code>rplaca</code><a id="marker-1008995"></a> function to make the desired substitution. Notice that the lookup list is an association list so that you can use the <code>assoc</code><a id="marker-1008996"></a> function to retrieve the appropriate substitution.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008997"></a>assoc( 2 trLookUpList ) =&gt; ( 2 &quot;two&quot; ) <br />assoc( 5 trLookUpList ) =&gt; nil</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008998"></a>procedure( trTopLevelSubst( aList aLookUpList )<br />      let( ( currentElement substValue )<br />            foreach( map listCell aList<br />                  currentElement = car( listCell )<br />                  substValue = cadr( <br />                        assoc( currentElement aLookUpList ) )<br />                  when( substValue<br />                        rplaca( listCell substValue )<br />                        ) ; when<br />                  ) ; foreach<br />            aList<br />            ) ; let<br />      ) ; procedure</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008999"></a>trList = &#39;( 1 4 5 3 3 )<br />trTopLevelSubst( trList trLookUpList ) =&gt;<br />            (&quot;one&quot; 4 5 &quot;three&quot; &quot;three&quot;)</pre>
<h3>
<a id="pgfId-1009000"></a>The mapcar Function</h3>

<p>
<a id="pgfId-1009002"></a>The <a id="marker-1009001"></a><code>mapcar</code> function is useful for building a list whose elements can be derived one-for-one from the elements of an original list. When used with the <code>foreach</code> function</p>
<ul><li>
<a id="pgfId-1009003"></a>The <code>foreach</code> function iterates over each element of the argument list. </li><li>
<a id="pgfId-1009004"></a>At each iteration, the current element is available in the loop variable of the <code>foreach</code>. </li><li>
<a id="pgfId-1009005"></a>Each iteration produces a result value.</li><li>
<a id="pgfId-1009006"></a>These values are returned in a list as the result of the function. </li></ul>



<p>
<a id="pgfId-1009007"></a>For example: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009008"></a>foreach(mapcar x &#39;(1 2 3 4 5) <br />      println(x) <br />      x*3<br />) </pre>

<p>
<a id="pgfId-1009009"></a>displays the following:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009010"></a>1 <br />2 <br />3 <br />4 <br />5</pre>

<p>
<a id="pgfId-1009011"></a>The return value is <code>(3 6 9 12 15).</code></p>

<h3>
<a id="pgfId-1009012"></a>The maplist Function</h3>

<p>
<a id="pgfId-1009014"></a>The <a id="marker-1009013"></a><code>maplist</code> function is useful for processing each list cell because it uses<code> cdr</code> to step down the argument list. Like the <code>mapcar</code> function, it returns the list of results that it collects for each iteration. When used with the <code>foreach</code> function</p>
<ul><li>
<a id="pgfId-1009015"></a>The <code>foreach</code> function iterates over each list cell of the argument list.</li><li>
<a id="pgfId-1009016"></a>At each iteration, the current list cell is available in the loop variable of the <code>foreach</code>. </li><li>
<a id="pgfId-1009017"></a>Each iteration produces a result value, and these values are returned in a list as the result of the <code>foreach</code> function. </li></ul>


<p>
<a id="pgfId-1009018"></a>For example, consider the substitution example illustrating the <code>map</code> function. In addition to making the substitutions, suppose that the function must display a message giving the number of substitutions made.</p>
<p>
<a id="pgfId-1009019"></a>By using <code>maplist</code> instead of <code>map</code> you can build a list of 1s and Os reflecting the substitutions made. Use the <a id="marker-1009020"></a><code>apply</code> function with <code>plus</code> to add up the numbers to produce the desired count.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009021"></a>procedure( trTopLevelSubst( aList aLookUpList )<br />            let( ( currentElement substValue substCountList )<br />            substCountList = foreach( maplist listCell aList<br />                  currentElement = car( listCell )<br />                  substValue = cadr( <br />                        assoc( currentElement aLookUpList ) )<br />                  if( substValue<br />                        then<br />                              rplaca( listCell substValue )<br />                              1<br />                        else<br />                              0<br />                        ) ; if<br />                  ) ; foreach<br />            printf( &quot;There were %d substitutions\n&quot; <br /></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009022"></a>                  apply( &#39;plus substCountList ) <br />                  )<br />            aList<br />            ) ; let<br />      ) ; procedure <br />trList = &#39;( 1 4 5 3 3 )<br />trTopLevelSubst( trList trLookUpList ) =&gt;<br />      (&quot;one&quot; 4 5 &quot;three&quot; &quot;three&quot;)<br />There were 3 substitutions</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017848"></a></pre>
<h3>
<a id="pgfId-1017863"></a>The mapcon Function</h3>

<p>
<a id="pgfId-1017864"></a>Like the <code>maplist</code> function, the <code>mapcon</code> function is useful for processing each list cell because it uses<code> cdr</code> to step down the argument list. It returns a concatenated list of results that it collects after each iteration. When used with the <code>foreach</code> function:</p>
<ul><li>
<a id="pgfId-1017865"></a>The <code>foreach</code> function iterates over each list cell of the argument list.</li><li>
<a id="pgfId-1017866"></a>At each iteration, the current list cell is available in the loop variable of the <code>foreach</code>. </li><li>
<a id="pgfId-1017867"></a>Each iteration produces a result value, and these values are returned as a concatenated list as the result of the <code>foreach</code> function. </li></ul>


<p>
<a id="pgfId-1017961"></a>An example of the <code>mapcon</code> function used with foreach is as follows:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017962"></a>foreach(mapcon x &#39;(1 2 3 4) list(x))</pre>

<p>
<a id="pgfId-1017997"></a>The return value is:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018026"></a>((1 2 3 4) </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017999"></a>    (2 3 4) </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018000"></a>    (3 4) </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018001"></a>    (4)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017986"></a>)</pre>

<p>
<a id="pgfId-1017868"></a>You can use the <code>mapcon</code> function with more than one list argument. In this case, the supplied function argument is applied to successive sublists of the lists. This means that the supplied function is first applied to the lists themselves, and then to the <code>cdr</code> of each list, and then to the <code>cdr</code> of the <code>cdr</code> of each list, and so on.</p>
<p>
<a id="pgfId-1017869"></a>A <code>mapcon</code> function example with a lambda function with one list argument:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017870"></a>mapcon((lambda (x)<br />(printf &quot;x = %L\n&quot; x)<br />(list (car x) (add1 (car x)))) &#39;(1 2 3 4))</pre>

<p>
<a id="pgfId-1017871"></a>displays the following</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017872"></a>x = (1 2 3 4)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017873"></a>x = (2 3 4)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017874"></a>x = (3 4)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017875"></a>x = (4)</pre>

<p>
<a id="pgfId-1017876"></a>The return value is: <code>(1 2 2 3 3 4 4 5)</code></p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017877"></a></pre>

<p>
<a id="pgfId-1017878"></a>A <code>mapcon</code> function example with a lambda function with two list arguments:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017879"></a>mapcon((lambda (x y) (printf &quot;x = %L y = %L\n&quot; x y)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017880"></a>  (list (car x) (add1 (car y))))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017881"></a>  &#39;(1 2 3 4)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017882"></a>  &#39;(4 3 2 1)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017883"></a>)</pre>

<p>
<a id="pgfId-1017884"></a>displays the following</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017885"></a>x = (1 2 3 4) y = (4 3 2 1)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017886"></a>x = (2 3 4) y = (3 2 1)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017887"></a>x = (3 4) y = (2 1)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017888"></a>x = (4) y = (1)</pre>

<p>
<a id="pgfId-1017889"></a>The return value is: <code>(1 5 2 4 3 3 4 2)</code></p>

<h3>
<a id="pgfId-1017931"></a>The mapcan Function</h3>

<p>
<a id="pgfId-1009025"></a>Like the <code>mapcar</code> function, the <code>mapcan</code><a id="marker-1009024"></a> function is useful for building a list by transforming the elements of the original list. However, instead of collecting the intermediate results into a list as <code>mapcar</code> does, <code>mapcan</code> appends them. The intermediate results must be lists. Notice that the resulting list need not be in 1-1 correspondence with the original list. </p>
<p>
<a id="pgfId-1009026"></a>The <code>mapcan</code> function iterates over each element of the argument list. When used with the <code>foreach</code> function</p>
<ul><li>
<a id="pgfId-1009027"></a>At each iteration, the current element is available in the loop variable of the <code>foreach</code>. </li><li>
<a id="pgfId-1009028"></a>Each iteration produces a result value, which must be a list. These lists are then concatenated by the destructive modification function <a id="marker-1009029"></a><code>nconc</code>, and the new list is returned as the result of the function as a whole. </li></ul>

<p>
<a id="pgfId-1009030"></a>For example, flattening a list of lists can be done with:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009031"></a>foreach( mapcan x &#39;( ( 1 2 ) ( 3 4 5 ) ( 6 7 ) )<br />      x <br />      ) =&gt; ( 1 2 3 4 5 6 7 )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009032"></a>mapcan(<br />      lambda( ( x ) x )<br />      &#39;( ( 1 2 ) ( 3 4 5 ) ( 6 7 ) )<br />      ) =&gt; ( 1 2 3 4 5 6 7 ) </pre>

<p>
<a id="pgfId-1009033"></a>For another example, the following builds a list of squares of the odd integers in the list <code>( 1 2 3 4 5 6 )</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009034"></a>foreach( mapcan x &#39;( 1 2 3 4 5 6 )<br />      when( oddp( x )<br />            list( x )<br />            )<br />      ) =&gt; ( 1 3 5 )      <br />
mapcan( 
&#160;&#160;    lambda( ( x ) when( oddp( x ) list( x )) )<br />      &#39;( 1 2 3 4 5 6 )<br />      ) =&gt; ( 1 3 5 )</pre>
<h3>
<a id="pgfId-1021099"></a>The mapinto Function</h3>

<p>
<a id="pgfId-1021106"></a>Like the <code>mapcar</code> function, the <code>mapinto</code> function is useful for building a list by transforming the elements of the original list. However, instead of allocating a new list, <code>mapinto</code> reuses the preallocated list. The first argument of <code>mapinto</code> is a sequence that receives the results of the mapping. It is because of this difference in behavior with the other <code>map*</code> functions, <code>mapinto</code> cannot be used along with <code>foreach</code>.</p>
<p>
<a id="pgfId-1017465"></a>For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1021270"></a>procedure( myFunc(x)<br />x<br />) ;procedure</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1021274"></a>mapinto( &#39;(&quot;a&quot; &quot;b&quot; &quot;c&quot;) &#39;myFunc &#39;(1 2) )<br />=&gt; (1 2 &quot;c&quot;)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1021320"></a>mapinto(&#39;(&quot;a&quot; &quot;b&quot; &quot;c&quot;) &#39;plus &#39;(1 2) &#39;(3 4))<br />=&gt; (4 6 &quot;c&quot;)</pre>
<h3>
<a id="pgfId-1017472"></a>Summarizing the <a id="marker-1017471"></a>List Traversal Operations</h3>

<p>
<a id="pgfId-1009037"></a>The table below summarizes how the mapping functions work. The term <code>Function</code> refers to the function you pass to the mapping function. Each table entry is a mapping function that behaves according to the row and column headings. In one case, there is no such mapping function. </p>

<p>
<a id="pgfId-1011126"></a></p>
<table class="webflareTable" id="#id1011131">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1011133"></a>Summary of the Mapping Functions </div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011139">
<a id="pgfId-1011139"></a>Mapping Function
Return Value</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011141">
<a id="pgfId-1011141"></a>Function
is Passed Successive Elements</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011143">
<a id="pgfId-1011143"></a>Function
is Passed Successive 
List Cells</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011145"></a>Ignores the result of each iteration. Returns the original list.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011147"></a>mapc<br />(default option)</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011149"></a>map</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011151"></a>Collects the result of each iteration. Returns the list of results.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011153"></a>mapcar</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011155"></a>maplist</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011157"></a>Collects the result of each iteration. Uses nconc to append the result of each iteration.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011159"></a>mapcan</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1011161"></a>No such <br />function</p>
</td>
</tr>
</tbody></table>
<h2>
<a id="pgfId-1009072"></a><a id="marker-1009071"></a><a id="34099"></a>List Traversal Case Studies</h2>

<p>
<a id="pgfId-1009073"></a>The most useful mapping functions are <code>mapc</code>, <code>mapcar</code>, and <code>mapcan</code>. A good understanding of these functions simplifies most list handling operations in SKILL. </p>

<h3>
<a id="pgfId-1009074"></a>Handling a List of Strings</h3>

<p>
<a id="pgfId-1009075"></a>Suppose you need to calculate the length of each string in a list of strings so that the lengths are returned in a new list. That is, the function should perform the following transformation:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009076"></a>( &quot;sam&quot; &quot;francis&quot; &quot;nick&quot; ) =&gt; ( 3 7 4 )</pre>

<p>
<a id="pgfId-1009077"></a>Someone not familiar with the <code>mapcar</code> option to <code>foreach</code> might code this as follows:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009078"></a>procedure( string_lengths( stringList )<br />      let( (result)<br />            foreach( element stringList<br />                  result = cons( strlen(element) result)<br />                  ) ; foreach<br />            reverse( result )<br />            ) ; let<br />      ) ; procedure</pre>

<p>
<a id="pgfId-1009080"></a>Using the <a id="marker-1009079"></a><code>mapcar</code> function allows this code to be written as</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009081"></a>procedure(string_lengths(stringList)<br />      foreach(mapcar element stringList<br />            strlen(element)<br />            ) ; foreach<br />      ) ; procedure</pre>

<p>
<a id="pgfId-1009082"></a>In fact, the <code>foreach</code> function is implemented as a macro that expands to one of the mapping functions, so the same example can be written using the mapping function directly as follows:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009083"></a>procedure(string_lengths(stringList)<br />      mapcar( &#39;strlen stringList)<br />      ) ; procedure</pre>
<h3>
<a id="pgfId-1009084"></a>Making Every List Element into a Sublist </h3>

<p>
<a id="pgfId-1009085"></a>You can perform this operation with either version of the <code>trMakeSublists</code> function.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009086"></a>procedure( trMakeSublists( aList )<br />      foreach( mapcar element aList<br />            list( element )<br />            ) ; foreach <br />      ) ; procedure</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009087"></a>procedure( trMakeSublists( aList )<br />      mapcar( <br />            &#39;ncons               ;;; return argument in a list <br />            aList<br />      ) <br />) ; procedure</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009088"></a>trMakeSublists( &#39;(1 2 3)) =&gt; ( ( 1 ) ( 2 ) ( 3 ) )</pre>
<h3>
<a id="pgfId-1009090"></a>Using mapcan for <a id="marker-1009089"></a>List Flattening</h3>

<p>
<a id="pgfId-1009092"></a>The <a id="marker-1009091"></a><code>mapcan</code> function is useful when a new list is derived from an old one, and each member of the old list produces a <code>number </code>of members in the new list. (Using <code>mapcar</code> allows <code>only a one-to-one mapping</code>). One application of <code>mapcan</code> is in list flattening. Suppose we have a list that contains lists of numbers:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009093"></a>x = &#39;( (1 2 3) (4) (5 6 7 8) () (9) )</pre>

<p>
<a id="pgfId-1009094"></a>This list can be flattened using the following procedure:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009095"></a>procedure(flatten(numberList)<br />      foreach( mapcan element numberList<br />            element<br />            ) ; foreach<br />      ) ; procedure<br />
flatten(x) =&gt; ( 1 2 3 4 5 6 7 8 9 )</pre>

<p>
<a id="pgfId-1009096"></a>This function concatenates all sublists of the argument. Remember that <code>nconc</code> is a <code>destructive</code> modification function, so variable <code>x</code> no longer holds useful information after the call. </p>
<p>
<a id="pgfId-1009097"></a>To preserve the value of <code>x</code>, each sublist should be <code>copied</code> within the <code>foreach</code> function to produce a new sublist that can be harmlessly modified:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012409"></a>procedure( flatten( numberList )<br />      foreach( mapcan element numberList<br />            copy(element)<br />            ) ; foreach<br />      ) ; procedure</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009099"></a>x = &#39;( (1 2 3) (4) (5 6 7 8) () (9) )<br />flatten(x) =&gt; ( 1 2 3 4 5 6 7 8 9 )<br />x =&gt; ((1 2 3) (4) (5 6 7 8) nil (9))</pre>
<h3>
<a id="pgfId-1009100"></a>Flattening a List with Many Levels</h3>

<p>
<a id="pgfId-1009101"></a>By using a type predicate and a recursive step, this procedure can be modified to flatten a list <a id="marker-1009102"></a>with many levels:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009103"></a>procedure(flatten(numberList)<br />      foreach(mapcan element numberList<br />            if( listp( element )<br />                  flatten(copy(element)) ;; then<br />                  ncons(element)<br />                  ) ; if<br />            ) ; foreach<br />      ) ; procedure </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009104"></a>x = &#39;((1) ((2 (3) 4 ((5)) () 6) ((7 8 ()))) 9)<br />flatten(x)       =&gt; (1 2 3 4 5 6 7 8 9)<br />x&#160;&#160;              =&gt; ((1) ((2 (3) 4 ((5)) nil 6) ((7 8 nil))) 9)</pre>

<p>
<a id="pgfId-1009105"></a>The body of the <code>foreach</code> first checks the type of the current list member. </p>
<ul><li>
<a id="pgfId-1009106"></a>If the member is a list, the result is a list obtained by flattening a copy of it. </li><li>
<a id="pgfId-1009107"></a>If the member is not a list, it cannot be flattened further, and the result is a <code>one-element list</code> containing the member. </li></ul>

<p>
<a id="pgfId-1009108"></a>Remember that when using <code>mapcan</code>, the result of each iteration must be a list so that the results can be concatenated using <code>nconc</code>.</p>

<h3>
<a id="pgfId-1009109"></a>Manipulating an Association List</h3>

<p>
<a id="pgfId-1009110"></a>Mapping functions can be powerful when used together. For example, suppose there is a database of names and extension numbers:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009111"></a>thePhoneDB = &#39;(<br />            (&quot;eric&quot; 2345 6472 8857)<br />            (&quot;sam&quot; 4563 8857)<br />            (&quot;julie&quot; 7765 9097 5654 6653)<br />            (&quot;francis&quot;)<br />            (&quot;pat&quot; 5527)<br />            )</pre>

<p>
<a id="pgfId-1009112"></a>The database is stored as a list with one entry for each person. An entry consists of a list of the person&#8217;s name followed by a list of extensions at which the person can be reached. This type of list is known as an <a id="marker-1009113"></a>association list. Some people can be reached at several extensions, and some people at none at all. An automated dialing system has been introduced that accepts only name-number pairs: in other words, it requires data in the following format:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009114"></a>((&quot;eric&quot; 2345)<br /> (&quot;eric&quot; 6472)<br /> (&quot;eric&quot; 8857)<br /> (&quot;sam&quot; 4563)<br /> . . . . . .</pre>

<p>
<a id="pgfId-1009115"></a>How can the information be transformed from one format to another? Each <code>person</code> entry in the original database can produce several entries in the new database, so <code>mapcan</code><a id="marker-1009116"></a> must be used to traverse person entries. Each <code>number</code> in the old database produces a single entry in the new database, so <code>mapcar</code><a id="marker-1009117"></a> can be used to traverse the numbers. </p>
<p>
<a id="pgfId-1009118"></a>From this information, a function can be written to translate the database:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009119"></a>procedure( translate( phoneDB )<br />      let((name)<br />            foreach(mapcan personEntry phoneDB<br />                  name = car( personEntry )<br />                  foreach( mapcar number cdr( personEntry )<br />                        list( name number )<br />                        ) ; foreach<br />                  ) ; foreach <br />            ) ; let<br />      ) ; procedure</pre>

<p>
<a id="pgfId-1009120"></a>To show that this works, consider the innermost<code> foreach</code> loop first. This loop is called for each person entry in the database. Suppose that the entry <code>(&quot;sam&quot; 4563 8857)</code> is being processed. In this case, <code>name</code> is set to <code>&quot;sam&quot;</code> and the <code>foreach</code> iterates over the list of numbers <code>(4563 8857)</code>. </p>
<p>
<a id="pgfId-1009121"></a>Because this iteration is a <code>mapcar</code>, the result of the <code>foreach</code> is a new list with one entry for each number in the old list. Each entry in this new list is a name-number pair constructed by the expression <code>list(name number)</code>. Hence, the result of this <code>foreach</code> is the list </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009122"></a>((&quot;sam&quot; 4563) (&quot;sam&quot; 8857))</pre>

<p>
<a id="pgfId-1009123"></a>The outermost<code> foreach</code> concatenates these lists of name-number pairs: it works like the first example of <code>flatten</code> given previously. Notice that there is no need to copy the elements before concatenating them (as was the case in <code>flatten</code>) because they have just been created.</p>

<h3>
<a id="pgfId-1009125"></a>Using <a id="marker-1009124"></a>the exists Function to Avoid Explicit List Traversal </h3>

<p>
<a id="pgfId-1009126"></a>SKILL provides a large number of list iteration functions. The most basic of these is the <code>foreach</code> function, which traverses all elements of a list. This traversal is useful, but often what is required is to traverse just part of a list, to check for a certain condition. In this situation, correct use of the <code>exists</code><a id="marker-1009127"></a>,<code> forall</code>, and <code>setof</code> functions can greatly improve your code. Usually, the alternatives are less efficient. </p>
<p>
<a id="pgfId-1009128"></a>Consider writing a simple function that iterates over all integers in a list and checks whether there is any even integer. There are several approaches. </p>
<p>
<a id="pgfId-1009130"></a>One approach is to use a <a id="marker-1009129"></a><code>while</code> loop that explicitly tests a Boolean variable found.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009131"></a>procedure( contains_even( list )<br /> let( (found)<br />          while( list &amp;&amp; !found<br />                  when( evenp( car(list) )<br />                   found = t<br />             )<br />             list = cdr(list)<br />             ) /* end while */<br />          /* Return whether found. */<br />          found<br /> ) /* end let */<br />) /* end contains_pass */</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009132"></a>contains_even( &#39;(1 2 3 4 )) =&gt; t<br />contains_even( &#39;(1 7 3 9 )) =&gt; nil<br />contains_even( nil ) =&gt; nil</pre>

<p>
<a id="pgfId-1009133"></a>Another approach is to jump out of the <code>while</code> loop:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009134"></a>procedure(contains_even( list )<br />      prog( ()<br />            while(list<br />                  if( evenp( car(list) )<br />            return(t)<br />                  )<br />                  list = cdr(list)<br />            ) /* end while */<br />            return(nil)<br /> ) /* end prog */<br />) /* end contains_pass */</pre>

<p>
<a id="pgfId-1009135"></a>This approach might appear to be better because there is no need for the local variable. </p>
<p>
<a id="pgfId-1009136"></a>A third approach involves jumping out of a <code>foreach</code> loop:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009137"></a>procedure(contains_even(list)<br />      prog( ()<br />      foreach(element list<br />                  if( evenp(element)<br />                        return(t)<br />                  )<br />            ) /* end foreach */<br />            return(nil)<br /> ) /* end prog */<br />) /* end contains_pass */</pre>

<p>
<a id="pgfId-1009138"></a>But this approach still requires the <code>prog</code> to allow the jump out of the <code>foreach</code> loop once the element has been found. </p>
<p>
<a id="pgfId-1009139"></a>A much simpler way of writing this procedure is as follows:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009140"></a>procedure(contains_even(list)<br />      when( exists( element list evenp( element ))<br />            t<br />      ) /* when */<br />) /* end contains_pass */</pre>

<p>
<a id="pgfId-1009141"></a>This approach has neither the <code>prog</code> nor any local variables, and is just as intuitive. The <code>exists</code> function terminates as soon as a matching list member has been found, so this example is just as efficient in this respect as the previous ones (which had to use <code>return</code> to achieve this result). The result of an <code>exists</code> is <code>nil</code> if no matching entry is found. Otherwise the result is the sublist of the argument that contains the matching member as its head. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009142"></a>exists( x &#39;( 1 2 3 4 ) evenp( x ) ) =&gt; ( 2 3 4 )</pre>

<p>
<a id="pgfId-1009143"></a>Because SKILL considers <code>nil</code> to be equivalent to false and non-<code>nil</code> to be equivalent to true, the result of an <code>exists</code> can be treated as a boolean if desired. If the <code>contains_even</code> function was defined to return either <code>nil</code> or non-<code>nil</code> (rather than <code>t</code>), it could be further simplified to</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009144"></a>procedure( contains_even( list )<br />      exists( element list evenp( element ))<br />) /* end contains_pass */</pre>

<p>
<a id="pgfId-1009145"></a>As with all the other iterative functions, there is no need to declare the loop variable for <code>exists</code> because the loop variable is local to the function and automatically declared.</p>

<h3>
<a id="pgfId-1009147"></a>Commenting <a id="marker-1009146"></a>List Traversal Code</h3>

<p>
<a id="pgfId-1009148"></a>The examples above demonstrate the power of these mapping functions. Usually, wherever a <code>foreach</code> loop is used to build a list, a mapping function can usually be used instead. Because the mapping functions collect all the results and apply a single list building operation, they are faster than the equivalent iterative function and often look more succinct.</p>
<p>
<a id="pgfId-1009149"></a>However, the mapping functions all look similar, and it is often difficult to see what a piece of code using a mapping function is trying to do. For this reason whenever a mapping function is used, you should write a comment detailing what the function is expected to return.</p>
<p>
<a id="pgfId-1008201"></a></p>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap7.html" id="prev" title="I/O and File Handling">I/O and File Handling</a></em></b><b><em><a href="chap9.html" id="nex" title="Advanced Topics">Advanced Topics</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
 

 <div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160;⠀ </center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div> 

</body></html>