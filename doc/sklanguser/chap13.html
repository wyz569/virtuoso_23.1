
<html><head><title>About SKILL++ and SKILL</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="parula" />
<meta name="CreateDate" content="2023-08-23" />
<meta name="CreateTime" content="1692797217" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the SKILL language to new users and helps them understand advanced topics, encourages sound SKILL programming methods, and introduces the SKILL++ language" />
<meta name="DocTitle" content="Cadence SKILL Language User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="About SKILL++ and SKILL" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-4.0.0" />
<meta name="Keyword" content="sklanguser" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-08-23" />
<meta name="ModifiedTime" content="1692797217" />
<meta name="NextFile" content="chap14.html" />
<meta name="Group" content="SKILL Language" />
<meta name="Platform" content="Cadence Shared Tools" />
<meta name="PrevFile" content="chap12.html" />
<meta name="c_product" content="Virtuoso Layout Suite,Virtuoso Schematic Editor,Virtuoso Analog Design Environment" />
<meta name="Product" content="SKILL" />
<meta name="ProductFamily" content="SKILL" />
<meta name="ProductVersion" content="IC23.1" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Cadence SKILL Language User Guide -- About SKILL++ and SKILL" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="0" />
<meta name="Version" content="IC23.1" />
<meta name="SpaceKey" content="sklanguserIC231" />
<meta name="webflare-version" content="2.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" />


  <script>/*<![CDATA[*/
 document.addEventListener("DOMContentLoaded", function(event) {  document.querySelectorAll("img").forEach((img, index) => {
if (img.hasAttribute("usemap")){return;}else{img.classList.add("cursorclass");} img.addEventListener("click", (e) => {if(img.hasAttribute("usemap")){            img.setAttribute("style","cursor:none;");return;};document.querySelector("#cad_image_modal").classList.add("opac");document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0;margin: auto;max-height:95%;"  src="${e.target.src}">`;});});});
/*]]>*/</script> 




 <style>/*<![CDATA[*/
.cursorclass{cursor:pointer;}#cad_image_modal{position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;}#cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;}#cad_image_modal span{position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;}
/*]]>*/</style> 
</head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="sklanguserTOC.html">Contents</a></li><li><a class="prev" href="chap12.html" title="SKILL Code Optimization">SKILL Code Optimization</a></li><li style="float: right;"><a class="viewPrint" href="sklanguser.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap14.html" title="Using SKILL++">Using SKILL++</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Cadence SKILL Language User Guide<br />Product Version IC23.1, September 2023</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<h1>13
<a id="pgfId-1005655"></a></h1>
<h1>
<a id="pgfId-1008199"></a><hr />
<a id="35957"></a>About SKILL++ and SKILL<hr />
</h1>

<p>
<a id="pgfId-1012082"></a><a id="marker-1012137"></a>Cadence&#174; SKILL++ is the second generation extension language for Cadence software. SKILL++ combines the ease-of-use of the SKILL environment with the power of the Scheme programming language. The major power brought in from Scheme<a id="marker-1012087"></a> is its use of <a id="marker-1012088"></a>lexical scoping and functions with lexically-closed environments called closures:</p>
<ul><li>
<a id="pgfId-1012196"></a>Lexical scoping makes reliable and modular programming more easily achievable, because you have total control over the use and reference of variables for any code without worrying about accidental corruptions caused by the use of the same variable name in a remote place.</li><li>
<a id="pgfId-1012090"></a>Closures are powerful entities that only exist in the more advanced programming languages. They encapsulate the code and related data into a single unit, with total control on the exported interface. Many modern programming idioms and paradigms, such as message-passing and objects with inheritance, can be implemented elegantly using <a id="marker-1012091"></a>closures. </li></ul>

<p>
<a id="pgfId-1012431"></a>Other advantages of SKILL++ include the following:</p>
<ul><li>
<a id="pgfId-1012415"></a>SKILL++ provides environments as first-class objects. With closures and first-class <a id="marker-1012416"></a>environments, you can create your own module or package systems. You are no longer restricted to SKILL&#8217;s single flat name space model. Instead, you can organize the code into a hierarchy of name spaces.</li><li>
<a id="pgfId-1012096"></a>In addition to Scheme semantics, SKILL++ includes an object layer that makes explicit object-oriented style programming possible. The object layer supports classes, generic functions, methods, and multiple inheritance.</li><li>
<a id="pgfId-1012099"></a>Because SKILL++ and SKILL can coexist harmoniously in the same environment, <a id="marker-1012098"></a>backward compatibility and interoperability are not an issue. All existing SKILL code can still run without any changes, and all or part of any SKILL package can be migrated to SKILL++. Code developed in SKILL++ and SKILL can call each other and share the same data structures transparently.</li></ul>



<h2>
<a id="pgfId-1012100"></a><a id="31755"></a>Background Information about SKILL and Scheme</h2>

<p>
<a id="pgfId-1012102"></a><a id="marker-1012101"></a>SKILL was originally based on a flavor of Lisp called &#8220;Franz Lisp.&#8221; Franz Lisp and all other flavors of Lisp were eventually superceded by an ANSI standard for Lisp called &#8220;Common Lisp.&#8221; The semantics and nature of SKILL make it ideal for scripting and fast prototyping. But the lack of modularity and good data abstraction, or its general openness, make it harder to apply modern software engineering principles especially for large endeavors. Since its inception, SKILL has been used for writing very large systems within the Cadence tools environments. To this end Cadence chose to offer Scheme within the SKILL environment.</p>
<p>
<a id="pgfId-1012106"></a><a id="marker-1012105"></a>Scheme is a Lisp-like language developed originally for teaching computer science at the Massachusetts Institute of Technology and is now a popular language in computer science and sometimes EE curriculums. Scheme is a modern language whose semantics empower engineers to develop sound software systems. There is an IEEE standard for Scheme. Scheme was also the choice of the CAD Framework Initiative (CFI) for an extension language base. Cadence supplies major <a id="marker-1012108"></a>Scheme functionality as part of the SKILL environment. Benefits include the following:</p>
<ul><li>
<a id="pgfId-1012111"></a>New programs written in <a id="marker-1012110"></a>Scheme can coexist and call procedures in existing programs written in SKILL without paying penalties in performance or functionality.</li><li>
<a id="pgfId-1012113"></a>Scheme and SKILL will share the <a id="marker-1012112"></a>run-time environment so structures allocated in Scheme programs can be passed without modification to SKILL programs and visa-versa.</li><li>
<a id="pgfId-1012115"></a>Suppliers and consumers can choose to migrate to <a id="marker-1012114"></a>Scheme independently of each other. For example, a Cadence-supplied layer can choose to remain written in SKILL while users of that layer can switch to using Scheme. The converse is also true.</li></ul>



<h2>
<a id="pgfId-1008239"></a><a id="29985"></a>SKILL++ Relation to IEEE and CFI Standard Scheme</h2>

<p>
<a id="pgfId-1008241"></a>CFI has <a id="marker-1008240"></a>chosen IEEE standard Scheme as the base of their proposed CAD Framework extension language. Because the intended use was as a CAD tool extension language, which must be embeddable within large applications in a mixed language environment, CFI relaxed the requirement for the support of full &#8220;call-with-current-continuation&#8221; and the full numeric tower (only numbers equivalent to C&#39;s long and double are required). </p>
<p>
<a id="pgfId-1008242"></a>For the same reason, CFI added a few extensions such as exception handling and functions for evaluating Scheme code, as well as a specification on the foreign function interface APIs, to their proposal. </p>
<p>
<a id="pgfId-1008244"></a>SKILL++ is designed with <a id="marker-1008243"></a>IEEE Scheme and CFI Scheme compliance in mind, but due to its SKILL heritage and compatibility, it is not fully compliant with either standard. </p>
<p>
<a id="pgfId-1008245"></a>The following sections describe the differences between SKILL++ and the standard Scheme language.</p>

<h3>
<a id="pgfId-1008246"></a>Syntax Differences</h3>

<p>
<a id="pgfId-1008248"></a><a id="marker-1008247"></a>SKILL++ uses the same familiar SKILL syntax with the following restrictions and extensions.</p>

<h4>
<a id="pgfId-1008249"></a>Restrictions</h4>

<ul><li>
<a id="pgfId-1008250"></a>Because most of the special characters are used as infix symbols in        SKILL++ and SKILL, they cannot be used as regular name constituents. However, many standard Scheme functions and syntax forms have been systematically renamed for ease of use under SKILL++&#39;s syntax, for example<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1008251">
<a id="pgfId-1008251"></a>pair?            ==&gt; pairp
list-&gt;vector     ==&gt; listToVector
make-vector      ==&gt; makeVector
set!             ==&gt; setq
let*             ==&gt; letseq (for &#8220;sequential let&#8221;)</pre></li><li>
<a id="pgfId-1008252"></a>Except for vector literals (such as <code>#(1 2 3)</code>), the <code>#&#8230;</code> syntax is not supported, so use <code>t</code> for <code>#t</code><a id="marker-1008253"></a>, <code>nil</code> for <code>#f</code>, and use single character symbols for character literals and so forth. </li></ul>



<h4>
<a id="pgfId-1008254"></a>Extensions</h4>

<ul><li>
<a id="pgfId-1008255"></a>Like SKILL, but unlike standard Scheme, SKILL++ symbols are case- sensitive.</li><li>
<a id="pgfId-1008256"></a>SKILL++ inherited all the SKILL syntactic features, such as infix notation, optional/keyword arguments with default values, and many powerful looping special forms (such as <code>for</code>, <code>foreach</code>, <code>setof</code>).</li><li>
<a id="pgfId-1008259"></a>SKILL++ code can define macros using the <code>mprocedure/defmacro</code><a id="marker-1008257"></a><a id="marker-1008258"></a> as well as use existing macros defined in SKILL.</li></ul>



<h3>
<a id="pgfId-1008260"></a>Semantic Differences</h3>

<p>
<a id="pgfId-1008262"></a><a id="marker-1008261"></a>SKILL++ adopts the standard Scheme semantics with the following restrictions and extensions.</p>

<h4>
<a id="pgfId-1008263"></a>Restrictions</h4>

<ul><li>
<a id="pgfId-1008264"></a>The atom <code>nil</code> is the same as the empty list &#39;(), as well as the <code>false</code> value. Standard Scheme uses <a id="marker-1008265"></a>#f for the only false value and treats the empty list as a true value. </li><li>
<a id="pgfId-1008267"></a>The <code>cons</code><a id="marker-1008266"></a> cells in SKILL++ are like SKILL&#39;s, that is, their <code>cdr</code> slot can only be either <code>nil</code> or another <code>cons</code> cell. In standard Scheme, the <code>cdr</code> slot of a cons cell can hold any value. </li><li>
<a id="pgfId-1008269"></a>The SKILL++ <code>map</code><a id="marker-1008268"></a> function and the SKILL <code>map</code> function share the same name and implementation, but behave differently from standard Scheme&#8217;s <code>map</code> function. To get the behavior of Scheme&#8217;s <code>map</code>, use <code>mapcar</code> in SKILL++.</li><li>
<a id="pgfId-1008270"></a>Strings in SKILL++ and SKILL are immutable, so there is no support for functions like Scheme&#39;s <code>string-set!</code>.</li><li>
<a id="pgfId-1008271"></a>The <code>character</code> type is not supported yet. As in SKILL, symbols of one character can be used as characters.</li><li>
<a id="pgfId-1008274"></a>No &#8220;<a id="marker-1008272"></a>eof&#8221; object. The <code>lineread</code><a id="marker-1008273"></a> function returns <code>nil</code> on end-of-file.</li></ul>






<h4>
<a id="pgfId-1008276"></a>Extensions</h4>

<ul><li>
<a id="pgfId-1008278"></a>Environments are treated as first class objects. The <code>theEnvironment</code><a id="marker-1008277"></a> form can be used to get the enclosing lexical environment, and bindings in an environment can be easily accessed. This provides a powerful encapsulation tool.</li><li>
<a id="pgfId-1008279"></a>SKILL++ inherits the SKILL set of powerful data structures, such as <code>defstruct</code> and association tables, as well as all the functions and many special forms of SKILL.</li><li>
<a id="pgfId-1008280"></a>Support for transparent cross-language (SKILL &lt;-&gt; SKILL++) mixed programming.</li></ul>



<h3>
<a id="pgfId-1008281"></a>Syntax Options</h3>

<p>
<a id="pgfId-1008283"></a>SKILL++ adopts the same SKILL syntax, which means <a id="marker-1008282"></a>SKILL++ programs can be written in the familiar infix syntax and the general Lisp syntax. </p>
<p>
<a id="pgfId-1008284"></a>If syntax is not an issue for you and you are comfortable with the infix notation, continue to use that.</p>
<p>
<a id="pgfId-1012565"></a>If you are concerned that the knowledge of SKILL++ you build by programming in the infix syntax will not be useful if you were to program in a Scheme environment (without SKILL), then use the Lisp syntax for programming in SKILL++. The syntactic differences between SKILL++ using Lisp syntax and standard Scheme are: </p>
<ul><li>
<a id="pgfId-1012567"></a>In SKILL++, you may not use any <a id="marker-1012566"></a>special characters (such as <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, <code>!</code>, <code>$</code>, <code>&amp;</code>, and so forth) in identifiers because most of these characters are used as infix operators. </li><li>
<a id="pgfId-1012946"></a>As a general convention, Scheme functions ending with an exclamation point (<code>!</code>) are provided either without the exclamation point or as the equivalent SKILL function. For example, Scheme <code>set!</code> is SKILL++ <code>setq</code>. Scheme functions using <code>-&gt;</code> are provided using <code>To</code> as part of the function name. For example, <code>list-&gt;vector</code> becomes <code>listToVector</code>. See &#8220;<a actuate="user" class="URL" href="../sklangref/appA.html#firstpage" show="replace" xml:link="simple">Scheme/SKILL++ Equivalents&#8221;</a> in the <em><a actuate="user" class="URL" href="../sklangref/sklangrefTOC.html#firstpage" show="replace" xml:link="simple">Cadence SKILL Language Reference</a></em> for a complete list of name mappings.</li><li>
<a id="pgfId-1008291"></a><a id="marker-1008290"></a>Scheme&#39;s dotted pairs are not available in SKILL++. Use simple lists instead.</li><li>
<a id="pgfId-1008292"></a>You can use <code>=&gt;</code> and <code>&#8230;</code> as identifiers.</li></ul>




<h3>
<a id="pgfId-1008293"></a>Compliance Disclaimer</h3>

<p>
<a id="pgfId-1008294"></a>Cadence-supplied Scheme is not fully IEEE compliant for the following reason:</p>
<ul><li>
<a id="pgfId-1008295"></a>Scheme was not originally designed as an extension language. Features in <a id="marker-1008296"></a>Scheme that cannot be used safely in conjunction with a system written in C/C++ are omitted, such as &#8220;<code>call</code>/<code>cc</code>&#8221; and non-null terminated strings. </li><li>
<a id="pgfId-1008298"></a>Cadence puts a high value on making the system fully <a id="marker-1008297"></a>backward compatible for SKILL programs and procedural interfaces. As a result, the empty list <code>nil</code> is a Boolean <code>true</code> in the Scheme standard while Cadence&#39;s SKILL and SKILL++ treat <code>nil</code> as a Boolean <code>false</code>. Without this treatment of <code>nil</code>, the migration of existing SKILL programs to Scheme would require many existing procedural interfaces written in SKILL to change.</li></ul>

<p>
<a id="pgfId-1008299"></a>In general, SKILL++ is implemented to support both the Lisp syntax and the more familiar SKILL infix syntax for writing Scheme programs, as well as to provide a smooth path for migrating SKILL code to Scheme. </p>

<h3>
<a id="pgfId-1008300"></a>References</h3>

<p>
<a id="pgfId-1008302"></a>You can read the following for more information about <a id="marker-1008301"></a>Scheme:</p>
<p>
<a id="pgfId-1008303"></a><em>Structure and Interpretation of Computer Programs</em>, Harold Abelson, Gerald Sussman, Julie Sussman, McGraw Hill, 1985.</p>
<p>
<a id="pgfId-1008304"></a><em>Scheme and the Art of Programming</em>, G. Springer &amp; D. Friedman, McGraw Hill, 1989.</p>
<p>
<a id="pgfId-1008305"></a><em>An Introduction to Scheme</em>, J. Smith, Prentice Hall, 1988.</p>
<p>
<a id="pgfId-1008306"></a>&#8220;Draft Standard for the Scheme Programming Language,&#8221; P1178/D5, October 1, 1990. IEEE working paper.</p>

<h2>
<a id="pgfId-1008308"></a><a id="34728"></a>Extension Language Environment</h2>

<p>
<a id="pgfId-1008312"></a>Cadence&#8217;s <a id="marker-1008309"></a>extension language <a id="marker-1008310"></a>environment supports two integrated extension languages, SKILL and SKILL++. Your application can consist of source code written in either language. Programs in either language can call each other&#8217;s functions and share data.</p>
<ul><li>
<a id="pgfId-1008317"></a>You can maintain existing SKILL applications with no change whatsoever. </li><li>
<a id="pgfId-1008320"></a>Using SKILL++, you can <a id="marker-1008319"></a>hide private functions and private data so that you can design and implement your application with reusable components.</li></ul>

<p>
<a id="pgfId-1012340"></a>You should consider developing new applications using the SKILL++ language, in conjunction with SKILL procedural interfaces as necessary.</p>
<p>
<a id="pgfId-1008360"></a>For source code files, the <a id="marker-1008323"></a>file extension indicates the language:<br /><code>.il</code> for SKILL, <code>.ils</code> for SKILL++.</p>

<p>
<a id="pgfId-1010031"></a></p>
<div class="webflare-div-image">
<img width="628" height="302" src="images/chap13-2.gif" /></div>

<p>
<a id="pgfId-1008363"></a>By default, the session accepts SKILL expressions. <a id="marker-1008362"></a>Interactively, you can invoke a <a id="marker-1008364"></a>top level <a id="marker-1008365"></a>for either SKILL or SKILL++ as follows:</p>

<p>
<a id="pgfId-1010195"></a> </p>
<table class="webflareTable" id="#id1008366">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008368">
<a id="pgfId-1008368"></a>Language</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008370">
<a id="pgfId-1008370"></a>Command</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008372"></a>SKILL</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008374"></a><code>toplevel &#39;il</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008376"></a>SKILL++</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008378"></a><code>toplevel &#39;ils</code></p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1008382"></a>Advanced programmers can use the <code>eval</code><a id="marker-1008380"></a> function to evaluate an expression using either SKILL semantics or SKILL++ semantics.<a id="marker-1008381"></a></p>

<h2>
<a id="pgfId-1008383"></a><a id="17549"></a>Contrast Variable Scoping</h2>

<p>
<a id="pgfId-1008384"></a>Variables associate an identifier with a memory location. A referencing environment is the collection of identifiers and their associated memory locations. The <a id="marker-1008385"></a>scope of a variable refers to the part of your program within which the variable refers to the same location. </p>
<p>
<a id="pgfId-1008386"></a>During your program&#8217;s execution, the referencing environment changes according to certain scoping rules. Even though the syntax of both languages is identical, SKILL and SKILL++ use different scoping rules and partition a program into pieces differently.</p>

<h3>
<a id="pgfId-1008390"></a><a id="93018"></a>SKILL++ Uses Lexical Scoping<a id="marker-1012665"></a></h3>

<p>
<a id="pgfId-1012676"></a>SKILL++ uses <a id="marker-1012675"></a>lexical scoping. Because lexical scoping relies solely on the static layout of the source code, the programmer can confidently determine how reusing a program affects the scope of variables. </p>
<p>
<a id="pgfId-1008392"></a>The lexical <a id="marker-1008391"></a>scoping rule is only concerned with the source code of your program. The phrase &#8216;a part of your program&#8217; means a block of text associated with a SKILL++ expression, such as <code>let</code>, <code>letrec</code>, <code>letseq</code>, and <code>lambda</code> expressions. You can nest blocks of text in the source code.</p>

<h3>
<a id="pgfId-1008394"></a><a id="84314"></a>SKILL Uses <a id="marker-1008393"></a>Dynamic Scoping </h3>

<p>
<a id="pgfId-1012686"></a>SKILL uses dynamic scoping. Modifying a SKILL program can sometimes unintentionally disrupt the scope of a variable. The probability of introducing subtle bugs is higher.</p>
<p>
<a id="pgfId-1008396"></a>The dynamic <a id="marker-1008395"></a>scoping rule is only concerned with the flow of control of your program. In SKILL, the phrase &#8216;a part of your program&#8217; means a period of time during execution of an expression. Usually, the dynamic scoping and lexical scoping rules agree. In these cases, identical expressions in both SKILL and SKILL++ return the same value. </p>

<h3>
<a id="pgfId-1012754"></a><a id="55425"></a>Lexical versus Dynamic Scoping</h3>

<p>
<a id="pgfId-1012761"></a>It is important that the <a id="marker-1012760"></a>scope of variables not be unintentionally disrupted when a programmer modifies or otherwise reuses a program. Subtle bugs can result when modification or reuse in another setting changes the scope of a variable.</p>
<p>
<a id="pgfId-1012762"></a>Lexical scoping makes it possible for you to inspect the source code to determine the effect on the scope of variables. Dynamic scoping&#8212;which relies on the execution history of your program&#8212;can make it difficult to write reusable, modular code by preventing confident reuse of existing code.</p>

<h3>
<a id="pgfId-1012756"></a><a id="84217"></a>Example 1: Sometimes the Scoping Rules Agree</h3>

<p>
<a id="pgfId-1008399"></a>The following example has <a id="marker-1008398"></a>line numbers added for reference only.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008400"></a>1:let((x)<br />2:     x = 3<br />3:     x<br />4:&#160;&#160; )</pre>

<p>
<a id="pgfId-1008401"></a>In both SKILL and SKILL++, the <code>let</code> expression establishes a scope for <code>x</code> and the expression returns 3.</p>
<ul><li>
<a id="pgfId-1008402"></a>In SKILL++, the scope of <code>x</code> is the block of text comprising line 2 and line 3. The <code>x</code> in line 2 and the x in line 3 refer to the same memory location. </li><li>
<a id="pgfId-1008403"></a>In SKILL, the scope of <code>x</code> begins when the flow of control enters the <code>let</code> expression and ends when the flow of control exits the <code>let</code> expression. </li></ul>


<h3>
<a id="pgfId-1008404"></a><a id="10777"></a>Example 2: When Dynamic and Lexical Scoping Disagree</h3>

<p>
<a id="pgfId-1008405"></a>In example 1, the two scoping rules agree and the <code>let</code> expression returns the same value in both SKILL and SKILL++. Example 2 illustrates a case in which dynamic and lexical scoping disagree. Notice that the following extends the first example by merely inserting a function call to the <code>A</code> function between two references to <code>x</code>. However, the <code>A</code> function assigns a value to <code>x</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008406"></a>1: procedure( A() x = 5 )<br />2: let( ( x )<br />3:      x = 3<br />4:      A()<br />5:      x<br />6:&#160;&#160;    )</pre>

<p>
<a id="pgfId-1008407"></a>Consider the <code>x</code> in line 1.</p>
<ul><li>
<a id="pgfId-1008408"></a>In SKILL++, the <code>x</code> in line 1 and the <code>x</code> in line 5 refer to different locations because the <code>x</code> in line 1 is outside the block of text determined by the <code>let</code> expression. The <code>let</code> expression returns 3.</li><li>
<a id="pgfId-1008409"></a>In SKILL, because line 1 executes during the execution of the <code>let</code> expression, the <code>x</code> in line 1 and the <code>x</code> in line 5 refer to the same location. The <code>let</code> expression returns 5.</li></ul>


<h3>
<a id="pgfId-1008410"></a><a id="79795"></a>Example 3: Calling Sequence Effects on Memory Location</h3>

<p>
<a id="pgfId-1008411"></a>In SKILL, dynamic scoping dictates that the memory location affected depends on the function calling sequence. In the code below, function <code>B</code> updates the global variable <code>x</code>. Yet, when called from the function A, function B <code>alters</code> function <code>A</code>&#8217;s local variable <code>x </code>instead. Function <code>B</code> updates the <code>x</code> that is local to the <code>let</code> expression in <code>A</code>. </p>
<ul><li>
<a id="pgfId-1008412"></a>In SKILL, function <code>A</code> returns 6. </li><li>
<a id="pgfId-1008413"></a>In SKILL++, function <code>A</code> returns 5.</li></ul>


<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008414"></a>procedure( A()<br />    let( ( x )<br />        x = 5        ;;; set the value of A&#8217;s local variable x<br />        B()<br />        x            ;;; return the value of A&#8217;s local variable x<br />        ) ;let<br />    ) ; procedure</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008415"></a>procedure( B()<br />    let( ( y z )<br />        x = 6<br />        z <br />        ) <br />    ) ; procedure</pre>

<p>
<a id="pgfId-1008419"></a>See <a href="chap9.html#29809">&#8220;Dynamic Scoping&#8221;</a> for guidelines concerning the use of dynamic scoping.</p>

<h2>
<a id="pgfId-1008428"></a><a id="36778"></a>Differencein Symbol Usage</h2>

<p>
<a id="pgfId-1008429"></a>SKILL and SKILL++ share the same symbol table. Each symbol in the symbol table is visible to both languages.</p>

<h3>
<a id="pgfId-1008430"></a>How SKILL Uses Symbols</h3>

<p>
<a id="pgfId-1008432"></a>SKILL has a data structure called a <a id="marker-1008431"></a>symbol. A symbol has a name which uniquely identifies it and three associated memory locations. For more information, see <a href="chap4.html#93665">&#8220;Symbols&#8221;</a>. </p>

<h4>
<a id="pgfId-1008436"></a>The Value Slot</h4>

<p>
<a id="pgfId-1008438"></a>SKILL uses symbols for <a id="marker-1008437"></a>variables. A variable is bound to the value slot of the symbol with the same name. For example, <code>x = 5</code> stores the value 5 in the value slot of the symbol x. The <code>symeval</code><a id="marker-1008439"></a> function returns the contents of the value slot. For example, <code>symeval( &#39;x )</code> returns the value 5.</p>

<h4>
<a id="pgfId-1008440"></a>The Function Slot</h4>

<p>
<a id="pgfId-1008442"></a>SKILL uses the <a id="marker-1008441"></a>function slot of a symbol to store function objects. SKILL evaluates a function call, such as </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008443"></a>fun( 1 2 3 ) </pre>

<p>
<a id="pgfId-1008444"></a>by fetching the function object stored in the function slot of the symbol <code>fun</code>. Dynamic scoping does not affect the function slot at all.</p>

<h4>
<a id="pgfId-1008445"></a>The Property List</h4>

<p>
<a id="pgfId-1008447"></a>Dynamic scoping does not affect the <a id="marker-1008446"></a>property list at all. See <a href="chap4.html#18488">&#8220;Important Symbol Property List Considerations&#8221;</a>.</p>

<h4>
<a id="pgfId-1008451"></a>Summary</h4>

<p>
<a id="pgfId-1008452"></a>You can call the <code>set</code>, <code>symeval</code>, <code>getd</code>, <code>putd</code>, <code>get</code>, and <code>putprop</code> SKILL functions to access the three slots of a symbol. The following table summarizes the SKILL operations that affect the three slots of a symbol.</p>

<p>
<a id="pgfId-1010198"></a></p>
<table class="webflareTable" id="#id1008453">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008455">
<a id="pgfId-1008455"></a>SKILL Construct</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008457">
<a id="pgfId-1008457"></a>Value Slot</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008459">
<a id="pgfId-1008459"></a>Function Slot</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008461">
<a id="pgfId-1008461"></a>Property List</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008465"></a><a id="marker-1008463"></a>assignment <a id="marker-1008464"></a>operator (<code>=</code>) </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008467"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008469"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008471"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008475"></a><code>set</code><a id="marker-1008473"></a>, <code>symeval</code><a id="marker-1008474"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008477"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008479"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008481"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008485"></a><code>let</code><a id="marker-1008483"></a> and <code>prog</code><a id="marker-1008484"></a> constructs</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008487"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008489"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008491"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008494"></a><a id="marker-1008493"></a>procedure declaration</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008496"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008498"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008500"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008504"></a><code>getd</code><a id="marker-1008502"></a>, <code>putd</code><a id="marker-1008503"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008506"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008508"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008510"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008512"></a>function call</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008514"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008516"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008518"></a></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008522"></a><code>get</code><a id="marker-1008520"></a>, <code>putprop</code><a id="marker-1008521"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008524"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008526"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008528"></a>x</p>
</td>
</tr>
</tbody></table>
<h3>
<a id="pgfId-1008529"></a>How SKILL++ Uses Symbols</h3>

<p>
<a id="pgfId-1008530"></a>Normally, each SKILL++ global variable is bound to the function slot of the <a id="marker-1008531"></a>symbol with the same name. In this way, SKILL and SKILL++ can share functions transparently.</p>
<p>
<a id="pgfId-1008532"></a>Sometimes your SKILL++ program needs to access a SKILL global variable. You can use the <code>importSkillVar</code> function to change the binding of the SKILL++ global from the function slot of a symbol to the value slot of the symbol.</p>

<h2>
<a id="pgfId-1008533"></a><a id="14282"></a>Difference in the Use of Functions as Data</h2>

<p>
<a id="pgfId-1008535"></a>In SKILL++ it is much easier to treat <a id="marker-1008534"></a>functions as data than it is in SKILL.</p>

<h3>
<a id="pgfId-1008536"></a>Assigning a Function Object to a Variable</h3>

<p>
<a id="pgfId-1008538"></a>In <a id="marker-1008537"></a>SKILL++, function objects are stored in variables just like other data values. You can use the familiar SKILL algebraic or conventional function call syntax to invoke a function object indirectly. For example, in SKILL++:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008539"></a>addFun = lambda( ( x y ) x+y ) =&gt; funobj:0x1e65c8<br />addFun( 5 6 ) =&gt; 11</pre>

<p>
<a id="pgfId-1008540"></a>In SKILL, the same example can be done two different ways, both of them less convenient.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008541"></a>addFun = lambda( ( x y ) x+y )<br />apply( addFun list( 5 6 )) =&gt; 11</pre>

<p>
<a id="pgfId-1008542"></a>or</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008543"></a>putd( &#39;addFun lambda( ( x y ) x+y ))<br />addFun( 5 6 ) =&gt; 11</pre>
<h3>
<a id="pgfId-1008544"></a>Passing a Function as an Argument</h3>

<p>
<a id="pgfId-1008546"></a>To pass a <a id="marker-1008545"></a>function as an argument in SKILL++ does not require special syntax. In SKILL the caller must quote the function name and the callee must use the <code>apply</code> function to invoke the passed function. </p>

<p>
<a id="pgfId-1010082"></a></p>
<div class="webflare-div-image">
<img width="495" height="274" src="images/chap13-3.gif" /></div>

<p>
<a id="pgfId-1008547"></a>The <code>areaApproximation</code> function in the following example computes an approximation to the area under the curve defined by the <code>fun</code> function over the interval ( 0 1 ). The approximation consists of adding the areas of three rectangles, each with a width of 0.5 and with heights of <code>fun(0.0)</code>, <code>fun(0.5)</code>, and <code>fun(1.0)</code>. </p>

<h4>
<a id="pgfId-1008562"></a>In SKILL++</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008563"></a>procedure( areaApproximation( fun )<br />    0.5*( fun( 0.0 ) + fun( 0.5 ) + fun( 1.0 ) )<br />    ) =&gt; areaApproximation</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008564"></a>areaApproximation( sin ) =&gt; 0.6604483<br />areaApproximation( cos ) =&gt; 1.208942</pre>
<h4>
<a id="pgfId-1008565"></a>In SKILL</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008566"></a>procedure( areaApproximation( fun )<br />    0.5*( <br />      apply( fun &#39;( 0.0 )) + <br />      apply( fun &#39;( 0.5 )) +<br />      apply( fun &#39;( 1.0 ))<br />      )<br />    ) =&gt; areaApproximation</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008567"></a>areaApproximation( &#39;sin ) =&gt; 0.6604483<br />areaApproximation( &#39;cos ) =&gt; 1.208942</pre>
<h2>
<a id="pgfId-1008568"></a><a id="18439"></a>SKILL++ Closures</h2>

<p>
<a id="pgfId-1008570"></a>A SKILL++ <a id="marker-1008569"></a>closure is a function object containing one or more <code>free</code> variables (defined below) bound to data. Lexical scoping makes closures possible. In SKILL, dynamic scoping prevents effective use of closures, but a SKILL++ application can use closures as software building blocks.</p>

<h3>
<a id="pgfId-1008571"></a>Relationship to Free Variables</h3>

<p>
<a id="pgfId-1008574"></a>Within a segment of source code, a <code>free</code><a id="marker-1008572"></a> variable is a variable whose binding you cannot determine by examining the source code. For example, consider the following source code fragment.<a id="marker-1008573"></a></p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008575"></a>procedure( Sample( x y )<br />    x+y+z <br />    ) </pre>

<p>
<a id="pgfId-1008576"></a>By examination, <code>x</code> and <code>y</code> are not free variables because they are arguments. <code>z</code> is a free variable. In SKILL++ lexical scoping implies that the bindings of all of a function&#8217;s free variables is determined at the time the function object (closure) is created. In SKILL, dynamic scoping implies that all references to free variables are determined at run time.</p>
<p>
<a id="pgfId-1008577"></a>For example, you can embed the above definition in a <code>let</code> expression that binds <code>z</code> to <code>1</code>. Only code in the same lexical scope of <code>z</code> can affect z&#8217;s value. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008578"></a>let( (( z 1 ))<br />    procedure( Sample( x y ) <br />        x+y+z <br />        ) <br />    ;;; code that invokes Sample goes here.<br />    ) </pre>
<h3>
<a id="pgfId-1008579"></a>How SKILL++ Closures Behave</h3>

<p>
<a id="pgfId-1008581"></a>A SKILL++ application can use <a id="marker-1008580"></a>closures as software building blocks. The following examples increase in complexity to illustrate how SKILL++ closures behave. </p>

<h4>
<a id="pgfId-1008582"></a>Example 1</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008583"></a>let( (( z 1 ))<br />    procedure( Sample( x y ) <br />        x+y+z <br />        ) <br />    ;;; code that invokes Sample goes here.<br />    Sample( 1 2 )<br />    ) <br />=&gt; 4</pre>
<h4>
<a id="pgfId-1008584"></a>Example 2</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008585"></a>let( (( z 1 ))<br />    procedure( Sample( x y ) <br />        x+y+z <br />        ) <br />    ;;; code that invokes Sample goes here.<br />    z = 100<br />    Sample( 1 2 )<br />    ) <br />=&gt; 103</pre>

<p>
<a id="pgfId-1008586"></a>This example assigns <code>100</code> to the binding of <code>z</code>. Consequently, the <code>Sample</code> function returns <code>103</code>. In this case, dynamic scoping and lexical scoping agree.</p>

<h4>
<a id="pgfId-1008587"></a>Example 3</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008588"></a>let( (( z 1 ))<br />    procedure( Sample( x y ) <br />        x+y+z <br />        ) ; procedure<br />    ;;; code that invokes Sample goes here.<br />    let( (( z 100 ))<br />        Sample( 1 2 )<br />        ) ; let<br />    ) ; let<br />=&gt; 4</pre>

<p>
<a id="pgfId-1008589"></a>This example invokes <code>Sample</code> from within a nested <code>let</code> expression. Although dynamic scoping would dictate that <code>z</code> be bound to <code>100</code>, lexically it is bound to <code>1</code>.</p>

<h4>
<a id="pgfId-1008590"></a>Example 4</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012880"></a>procedure( CallThisFunction( fun )<br />    let( (( z 100 ))<br />          fun( 1 2 )<br />        ) <br />    ) </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008592"></a>let( (( z 1 ))<br />    procedure( Sample( x y ) <br />        x+y+z <br />        ) ; procedure<br />    CallThisFunction( Sample )<br />    ) <br />=&gt; 4</pre>

<p>
<a id="pgfId-1008593"></a>In this SKILL++ example, the <code>let</code> expression binds <code>z</code> to <code>1</code>, creates the <code>Sample</code> function and then passes it to the <code>CallThisFunction</code> function. Whenever the <code>Sample</code> function runs, <code>z</code> is bound to <code>1</code>. In particular, when the <code>CallThisFunction</code> function invokes <code>Sample</code>, <code>z</code> is bound to <code>1</code> even though <code>CallThisFunction</code> binds <code>z</code> to a different value prior to calling <code>Sample</code>. </p>
<p>
<a id="pgfId-1008594"></a>Therefore, <code>Sample</code> has encapsulated a value for its free variable <code>z</code>. To do this in SKILL is impossible, because dynamic scoping dictates that <code>Sample</code> would see the binding of <code>z</code> to <code>100</code>.</p>
<p>
<a id="pgfId-1008595"></a>Therefore, SKILL++ allows you to build a function object that you can pass an argument, certain that its behavior will be independent of specifics of how it is ultimately called.</p>

<h4>
<a id="pgfId-1008596"></a>Example 5</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008597"></a>W = let( (( z 1 ))<br />    lambda( ( x y ) <br />        x+y+z <br />        ) <br />    ) <br />=&gt; funobj:0x1bc828<br />W( 1 2 ) =&gt; 4</pre>

<p>
<a id="pgfId-1008598"></a>In this example, the name <code>Sample</code> is insignificant because the <code>let</code> expression itself does not contain a call to <code>Sample</code>. Instead, the <code>let</code> expression returns the function object. This function object is a closure. The code returns a distinct closure each time the code is executed. In SKILL++, there is no way to affect the binding of <code>z</code>. The function object has effectively encapsulated the binding of <code>z</code>.</p>

<h4>
<a id="pgfId-1008599"></a>Example 6</h4>

<p>
<a id="pgfId-1008600"></a>The <code>makeAdder</code> function below creates a function object which adds its argument <code>x</code> to the variable <code>delta</code>. Each call to <code>makeAdder</code> returns a distinct closure.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008601"></a>procedure( makeAdder( delta )<br />    lambda( ( x ) x + delta )<br />    ) <br />=&gt; makeAdder</pre>

<p>
<a id="pgfId-1008602"></a>In SKILL++, you can pass 5 to <code>makeAdder</code> and assign the result to the variable <code>add5</code>. No matter how you invoke the <code>add5</code> function, its local variable <code>delta</code> is bound to 5.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008603"></a>add5 = makeAdder( 5 )=&gt; funobj:0x1e3628<br />add5( 3 ) =&gt; 8 </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008604"></a>let( ( ( delta 1 ) )<br />    add5( 3 ) <br />    ) =&gt; 8</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008605"></a>let( ( ( delta 6 ) )<br />    add5( 3 )<br />    ) =&gt; 8</pre>
<h2>
<a id="pgfId-1008606"></a><a id="27327"></a>SKILL++ Environments</h2>

<p>
<a id="pgfId-1008608"></a>This section introduces the run-time data structures called <code>environments</code><a id="marker-1008607"></a> that SKILL++ uses to support lexical scoping. This section covers how SKILL++ manages environments during run time. Understanding this material is important if your application use closures.<a id="marker-1008609"></a></p>
<p>
<a id="pgfId-1008610"></a>For more information, <a href="chap15.html#18182">Using SKILL and SKILL++ Together</a> covers how inspecting environments can help you debug SKILL++ programs.</p>

<h3>
<a id="pgfId-1008615"></a>The Active Environment </h3>

<p>
<a id="pgfId-1008616"></a>During the execution of your SKILL++ program, the set of all the variable bindings is called an <code>environment</code><a id="marker-1008617"></a>. To accommodate the sequence of nested lexical scopes which contain the current SKILL++ statement being executed, an environment is a list of environment frames such that </p>
<ul><li>
<a id="pgfId-1008618"></a>SKILL++ stores all the variables with the same lexical scope in a single environment frame </li><li>
<a id="pgfId-1008619"></a>The sequence of nested lexical scopes correspond to a list of environment frames </li></ul>

<p>
<a id="pgfId-1008620"></a>Consequently, each environment frame is equivalent to a two column table. The first column contains the variable names and the second column contains the current values.</p>

<h3>
<a id="pgfId-1008621"></a>The Top-Level Environment</h3>

<p>
<a id="pgfId-1008623"></a>When a SKILL++ session starts, the active <a id="marker-1008622"></a>environment contains only one environment frame. There are no other environment frames. All the built-in functions and global variables are in this environment. This environment is called the top-level environment. The <code>toplevel( &#39;ils )</code> function call uses the SKILL++ top-level environment by default. However, it is possible to call the <code>toplevel( &#39;ils )</code> function and pass a non-top-level environment. Consider an expression such as </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008624"></a>let( (( x 3 )) x )&#160;&#160;=&gt; 3</pre>

<p>
<a id="pgfId-1008625"></a>in which we insert a call to <code>toplevel( &#39;ils )</code>. During the interaction we attempt to retrieve the value of <code>x</code> and then set it. References to <code>x</code> affect the SKILL++ top-level.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008626"></a>ILS-&lt;2&gt; let( (( x 3 )) toplevel( &#39;ils ) x )<br />ILS-&lt;3&gt; x<br />*Error* eval: unbound variable - x<br />ILS-&lt;3&gt; x = 5<br />5<br />ILS-&lt;3&gt; resume()<br />3<br />ILS-&lt;2&gt;</pre>

<p>
<a id="pgfId-1008627"></a>Compare it with the following in which we call <code>toplevel</code> passing in the lexically enclosing (active) environment. Thus the <code>toplevel</code> function can be made to access a non-top-level environment!</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008628"></a>ILS-&lt;2&gt; let( (( x 3 )) toplevel( &#39;ils theEnvironment() ) x )<br />ILS-&lt;3&gt; theEnvironment()-&gt;??<br />(((x 3)))<br />ILS-&lt;3&gt; x<br />3<br />ILS-&lt;3&gt; x = 5<br />5<br />ILS-&lt;3&gt; resume()<br />5<br />ILS-&lt;2&gt; x<br />*Error* eval: unbound variable - x<br />ILS-&lt;2&gt;</pre>
<h3>
<a id="pgfId-1008629"></a>Creating Environments</h3>

<p>
<a id="pgfId-1008630"></a>During the execution of your program, when SKILL++ evaluates certain expressions that affect lexical scoping, <a id="marker-1008631"></a>SKILL++ allocates a new <a id="marker-1008632"></a>environment frame and adds it to the front of the active environment. When the construct exits, the environment frame is removed from the active environment.</p>

<h4>
<a id="pgfId-1008633"></a>Example 1</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008634"></a>let( (( x 2 ) ( y 3 )) <br />    x+y<br />    ) </pre>

<p>
<a id="pgfId-1008635"></a>When SKILL++ encounters a <code>let</code> expression, it allocates an environment frame and adds it to the front of the active environment.</p>

<p>
<a id="pgfId-1010202"></a> </p>
<table class="webflareTable" id="#id1008636">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1009105"></a>An Environment Frame </div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1009109">
<a id="pgfId-1009109"></a>Variable</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1009111">
<a id="pgfId-1009111"></a>Value</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009113"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009115"></a>2</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009117"></a>y</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009119"></a>3</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1008653"></a>To evaluate the expression <code>x+y</code>, SKILL++ looks up <code>x</code> and <code>y</code> in the list of environment frames, starting at the front of the list. When the expression terminates, SKILL++ removes it from the active environment. The environment frame remains in memory as long as there are references to the environment frame. </p>
<p>
<a id="pgfId-1008654"></a>In this simple case, there are none, so the frame is discarded, which means it&#8217;s garbage and therefore liable to be garbage collected.</p>

<h4>
<a id="pgfId-1008655"></a>Example 2</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008656"></a>let( (( x 2 ) ( y 3 ))<br />    let( (( u 4 ) ( v 5 )( x 6 ))<br />        u*v+x*y<br />        ) <br />    ) </pre>

<p>
<a id="pgfId-1008657"></a>At the time SKILL++ is ready to evaluate the expression <code>u*v+x*y</code>, there are two environment frames at the front of the active environment.</p>

<p>
<a id="pgfId-1010749"></a>  </p>
<table class="webflareTable" id="#id1008658">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1008660"></a>Environment Frame for the Outermost let</div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008664">
<a id="pgfId-1008664"></a>Variable</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008666">
<a id="pgfId-1008666"></a>Value</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008668"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008670"></a>2</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008672"></a>y</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008674"></a>3</p>
</td>
</tr>
</tbody></table>
<table class="webflareTable" id="#id1008675">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1008677"></a>Environment Frame for the Innermost let</div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008681">
<a id="pgfId-1008681"></a>Variable</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008683">
<a id="pgfId-1008683"></a>Value</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008685"></a>u</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008687"></a>4</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008689"></a>v</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008691"></a>5</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008693"></a>x</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008695"></a>6</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1008696"></a>To determine a variable&#8217;s location is a straight-forward look up through the list of environment frames. Notice that <code>x</code> occurs in both environment frames. The value 6 is the first found at the time the expression <code>u*v+x*y</code> is evaluated.</p>

<h3>
<a id="pgfId-1008697"></a>Functions and Environments</h3>

<p>
<a id="pgfId-1008698"></a>When you create a function, <a id="marker-1008699"></a>SKILL++ allocates a function object with a link to the environment that was active at the time the function object was created. </p>
<p>
<a id="pgfId-1008700"></a>When you call a function, <a id="marker-1008701"></a>SKILL++ makes the function object&#8217;s environment active (again) and allocates a new environment frame to hold the arguments. For example,</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008702"></a>procedure( example( u v )<br />    let( (( x 2 ) ( y 3 ))<br />        x*y + u*v<br />        ) <br />    ) <br />example( 4 5 )</pre>

<p>
<a id="pgfId-1008721"></a>allocates the following: </p>

<p>
<a id="pgfId-1010751"></a> </p>
<table class="webflareTable" id="#id1008704">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1008706"></a>An Environment Frame </div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008710">
<a id="pgfId-1008710"></a>Variable</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008712">
<a id="pgfId-1008712"></a>Value</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008714"></a>u</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008716"></a>4</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008718"></a>v</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008720"></a>5</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1008722"></a>and adds to the front of the active environment, which is the environment saved when the <code>example</code> function was first created. </p>
<p>
<a id="pgfId-1008723"></a>When the function returns, <a id="marker-1008724"></a>SKILL++ removes the environment frame holding the arguments from the active environment and, in this case, the environment frame becomes garbage. It then restores the environment that was active before the function call.</p>

<h3>
<a id="pgfId-1008725"></a>Persistent Environments</h3>

<p>
<a id="pgfId-1008726"></a>The <code>makeAdder</code> example below shows a function which allocates a function object and then returns it. The returned function object contains a reference to the environment that was active at the time the function object was created. This environment contains an environment frame that holds the argument to the original function call.<a id="marker-1008727"></a></p>
<p>
<a id="pgfId-1008728"></a>Therefore, whenever you subsequently call the returned function object, it can refer the local variables and arguments of the original function even though the original function has returned. </p>
<p>
<a id="pgfId-1008729"></a>This capability gives SKILL++ the power to build robust software components that can be reused. Full understanding of this capability is the basis for advanced SKILL++ programming. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008730"></a>procedure( makeAdder( delta)<br />    lambda( ( x ) x + delta )<br />    ) <br />=&gt; makeAdder</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008731"></a>add2 = makeAdder(2) =&gt; funobj:0x1e6628<br />add2( 1 ) =&gt; 3</pre>

<p>
<a id="pgfId-1008732"></a>The function object that <code>makeAdder</code> returns is within the lexical scope of the <code>delta</code> argument. </p>

<p>
<a id="pgfId-1010103"></a></p>
<div class="webflare-div-image">
<img width="658" height="285" src="images/chap13-4.gif" /></div>

<p>
<a id="pgfId-1008767"></a>Calling <code>makeAdder</code> again returns another function object.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008768"></a>add3 = makeAdder(3) =&gt; funobj:0x1e6638</pre>

<p>
<a id="pgfId-1008769"></a>The figure below shows several environments. The encircled environments belong to the <code>add2</code> and <code>add3</code> functions. The gray environment is the active environment at the time <code>add2(1)</code> at its entry point. The other environment belongs to the <code>add3</code> function, which becomes active only if <code>add3</code> is called. </p>

<p>
<a id="pgfId-1010149"></a></p>
<div class="webflare-div-image">
<img width="560" height="289" src="images/chap13-5.gif" /></div>

<p>
<a id="pgfId-1008201"></a></p>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap12.html" id="prev" title="SKILL Code Optimization">SKILL Code Optimization</a></em></b><b><em><a href="chap14.html" id="nex" title="Using SKILL++">Using SKILL++</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
 

 <div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160; </center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div> 

</body></html>