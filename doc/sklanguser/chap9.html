
<html><head><title>Advanced Topics</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="parula" />
<meta name="CreateDate" content="2023-08-23" />
<meta name="CreateTime" content="1692797225" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the SKILL language to new users and helps them understand advanced topics, encourages sound SKILL programming methods, and introduces the SKILL++ language" />
<meta name="DocTitle" content="Cadence SKILL Language User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="Advanced Topics" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-4.0.0" />
<meta name="Keyword" content="sklanguser" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-08-23" />
<meta name="ModifiedTime" content="1692797225" />
<meta name="NextFile" content="chap10.html" />
<meta name="Group" content="SKILL Language" />
<meta name="Platform" content="Cadence Shared Tools" />
<meta name="PrevFile" content="chap8.html" />
<meta name="c_product" content="Virtuoso Layout Suite,Virtuoso Schematic Editor,Virtuoso Analog Design Environment" />
<meta name="Product" content="SKILL" />
<meta name="ProductFamily" content="SKILL" />
<meta name="ProductVersion" content="IC23.1" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Cadence SKILL Language User Guide -- Advanced Topics" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="0" />
<meta name="Version" content="IC23.1" />
<meta name="SpaceKey" content="sklanguserIC231" />
<meta name="webflare-version" content="2.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" />


  <script>/*<![CDATA[*/
 document.addEventListener("DOMContentLoaded", function(event) {  document.querySelectorAll("img").forEach((img, index) => {
if (img.hasAttribute("usemap")){return;}else{img.classList.add("cursorclass");} img.addEventListener("click", (e) => {if(img.hasAttribute("usemap")){            img.setAttribute("style","cursor:none;");return;};document.querySelector("#cad_image_modal").classList.add("opac");document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0;margin: auto;max-height:95%;"  src="${e.target.src}">`;});});});
/*]]>*/</script> 




 <style>/*<![CDATA[*/
.cursorclass{cursor:pointer;}#cad_image_modal{position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;}#cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;}#cad_image_modal span{position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;}
/*]]>*/</style> 
</head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="sklanguserTOC.html">Contents</a></li><li><a class="prev" href="chap8.html" title="Advanced List Operations">Advanced List Operations</a></li><li style="float: right;"><a class="viewPrint" href="sklanguser.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap10.html" title="Delivering Products">Delivering Products</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Cadence SKILL Language User Guide<br />Product Version IC23.1, September 2023</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<h1>9
<a id="pgfId-1005655"></a></h1>
<h1>
<a id="pgfId-1008199"></a><hr />
<a id="30824"></a>Advanced Topics<hr />
</h1>

<p>
<a id="pgfId-1009144"></a>You can find information about advanced topics in the following sections:</p>
<ul><li>
<a id="pgfId-1009256"></a><a href="chap9.html#12208">Cadence SKILL Language Architecture and Implementation</a> </li><li>
<a id="pgfId-1014321"></a><a href="chap9.html#11728">SKILL Namespace</a></li><li>
<a id="pgfId-1009258"></a><a href="chap9.html#31969">Evaluation</a>  </li><li>
<a id="pgfId-1009266"></a><a href="chap9.html#13631">Function Objects</a>  </li><li>
<a id="pgfId-1009278"></a><a href="chap9.html#90007">Macros</a>  </li><li>
<a id="pgfId-1009296"></a><a href="chap9.html#42449">Variables</a>  </li><li>
<a id="pgfId-1009304"></a><a href="chap9.html#35042">Error Handling</a> </li><li>
<a id="pgfId-1009316"></a><a href="chap9.html#33792">Top Levels</a>  </li><li>
<a id="pgfId-1009318"></a><a href="chap9.html#68393">Memory Management (Garbage Collection)</a> </li><li>
<a id="pgfId-1009944"></a><a href="chap9.html#40164">Exiting SKILL</a>  </li></ul>









<h2>
<a id="pgfId-1009947"></a><a id="12208"></a>Cadence SKILL Language Architecture and Implementation</h2>
<p>
<a id="pgfId-1008208"></a>When you first encounter the Cadence&#174; SKILL language in an application and begin typing expressions to evaluate, you are encountering what is known as the <a id="marker-1008209"></a>read-eval-print loop.</p>
<p>
<a id="pgfId-1008210"></a>The expression you type in is first &#8220;read&#8221; and converted into a format that can be evaluated. The evaluator then does an &#8220;eval&#8221; on the output from the &#8220;read.&#8221; The result of the &#8220;eval&#8221; is a SKILL data value, which is then printed. The same sequence is repeated when other expressions are entered. </p>

<p>
<a id="pgfId-1009765"></a></p>
<div class="webflare-div-image">
<img width="500" height="329" src="images/chap9-2.gif" /></div>

<p>
<a id="pgfId-1008275"></a>The &#8220;read&#8221; in this case performs the following tasks. </p>
<ul><li>
<a id="pgfId-1008276"></a>The expression is parsed, resulting in the generation of a parse tree. </li><li>
<a id="pgfId-1008277"></a>The parse tree is then compiled into a body of code, known as a function object, made of a set of instructions that, when executed, results in the desired effect from the expression. </li></ul>

<p>
<a id="pgfId-1008278"></a>The instructions generated are not those of a particular machine architecture. They are the instructions of an abstract machine. Usually, this set of instructions might be referred to as <a id="marker-1008279"></a>byte-code or p-code. (p-code was the target instruction set of some of the early <a id="marker-1008280"></a>Pascal compilers and lent the name to this technique.)</p>
<p>
<a id="pgfId-1008283"></a>The <a id="marker-1008281"></a>evaluator executes the byte-code generated by the <a id="marker-1008282"></a>compiler. In a sense, the evaluator emulates in software the operations of a hardware CPU. This technique of using an abstract instruction set to be executed by an engine written in software has several advantages for the implementation of an extension language. </p>
<ul><li>
<a id="pgfId-1008284"></a>This technique lends itself well to an interpreter-based implementation. </li><li>
<a id="pgfId-1008285"></a>This technique offers faster performance than direct source interpretation.</li><li>
<a id="pgfId-1008288"></a>Once SKILL code is compiled into contexts (refer to <a href="chap10.html#26277">Delivering Products</a>) the context files are faster to load than original source code and are portable from one machine to another. </li></ul>


<p>
<a id="pgfId-1008290"></a>That is, if the context file is generated on a machine with architecture A from vendor X, it can be copied onto a machine with architecture B from vendor Y and SKILL will load the file without the need for recompilation or translation. </p>

<h2>
<a id="pgfId-1013590"></a><a id="11728"></a>SKILL Nam<a id="namespace"></a>espace</h2>
<h3>
<a id="pgfId-1013727"></a>Need for a SKILL Namespace</h3>

<p>
<a id="pgfId-1016007"></a>A SKILL programmer often uses the same name for different purposes when working on a large project with different programmers. Usually this problem is solved by using naming conventions or adding prefixes to function names, such as <code>leCreateRect</code>, <code>dbCreateRect</code>, <code>rodCreateRect</code>, and <code>geCreateRect</code>. SKILL provides a language mechanism called <em>namespace</em> to separate these symbols, so that a symbol with the same name can exist in several namespaces.</p>
<p>
<a id="pgfId-1018201"></a>SKILL provides several namespace functions that you can use. For example, you can use namespace functions to create a new namespace, associate symbols with the new or an existing namespace, add or remove symbols to and from a namespace, and also use shadow functions to resolve any name conflicts between symbols within a namespace. </p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1018202"></a>By default all warnings related to SKILL namespaces are suppressed.</div>

<h3>
<a id="pgfId-1018203"></a>Default Namespace</h3>

<p>
<a id="pgfId-1016241"></a>In SKILL, the default namespace is the namespace that is opened at the start of the SKILL interpreter. The symbols from the default namespace can be referenced with their full names, such as <code>IL:::&lt;symbol_name&gt; </code>or just by their names such as <code>&lt;symbol_name&gt; </code>since there is no way to change the current namespace.</p>

<h3>
<a id="pgfId-1014706"></a>Working with a Namespace</h3>
<h4>
<a id="pgfId-1014707"></a>Creating a Namespace</h4>

<p>
<a id="pgfId-1014712"></a>You start working with a namespace when you first create a new namespace using the <code>makeNamespace </code>function. For example, the following code helps you create an empty namespace, <code>myNS</code>:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016249"></a>makeNamespace(&quot;myNs&quot;)</pre>

<p>
<a id="pgfId-1016250"></a>You can use the <code>findNamespace</code> function to check if a given namespace already exists.</p>

<h4>
<a id="pgfId-1016251"></a>Associating Symbols to a Namespace</h4>

<p>
<a id="pgfId-1014564"></a>Next, you associate new symbols to the namespace (or an existing namespace) by using any of the following methods:</p>
<ul><li>
<a id="pgfId-1014332"></a>Use the access operator &quot;<code>:::</code>&quot; </li><li>
<a id="pgfId-1014353"></a>Use the <code>addToNamespace</code> function</li></ul>

<p>
<a id="pgfId-1014346"></a>Some examples are given below:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1014129"></a>myNs:::x = 0 </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015111"></a>;Creates a new symbol <code>x</code> in the namespace <code>myNs</code> and associates a numerical value 0 to it</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1014228"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1014271"></a>defun( myNs:::y (a) list(a a)) </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015125"></a>;Creates a new symbol y in the namespace myNs and associates a function value to it</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1014395"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1014385"></a>(addToNamespace &quot;A&quot; &#39;(&quot;a&quot; &quot;b&quot; &quot;c&quot;))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015146"></a>;Adds symbols a, b, and c to the namespace A</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015138"></a></pre>
<h4>
<a id="pgfId-1014466"></a>Using Export and Import Lists of a Namespace</h4>

<p>
<a id="pgfId-1016127"></a>Finally, to be able to use the symbols associated with your own or other namespaces, you must add them to an export list. An export list is a list of symbols to be imported into the default (&quot;<code>IL</code>&quot;) namespace when the <code>useNamespace()</code> function is called. When a new namespace is created, its export list is empty. You use the <code>addToExportList</code> and the <code>removeFromExportList</code> functions to add or remove symbols from the export list of a namespace. </p>
<p>
<a id="pgfId-1014941"></a>You can use the symbols that have been added to the export list by using the &quot;<code>::</code>&quot; and &quot;<code>:::</code>&quot; operators, such as <code>&lt;NAMESPACE&gt;::&lt;SYMBOL&gt;</code>. Consider the following example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016154"></a>makeNamespace(&quot;A&quot;)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016155"></a>addToExportList(&#39;(A:::abcd))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016156"></a>defun(A::abcd ()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016157"></a>;;defun a function &quot;abcd&quot; in the namespace:&quot;A&quot;</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016158"></a>. . .</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016190"></a>. . .</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016159"></a>printf(&quot;calling A::abcd\n&quot;)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016160"></a>)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016161"></a>useNamespace(&quot;A&quot;) ;; now symbol A::abcd is imported into the default namespace</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016162"></a>abcd()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016163"></a>=&gt; &quot;calling A::abcd\n&quot;</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016164"></a>getSymbolNamespace(&#39;abcd)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1016165"></a>=&gt; ns@A ;; this symbol belongs to the namespace:&quot;A&quot;</pre>

<p>
<a id="pgfId-1014862"></a>To use symbols that are not available in the export list, you can use only the &quot;<code>:::</code>&quot; operator.</p>
<p>
<a id="pgfId-1015380"></a>Consider the following examples.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1014515"></a>myNs:::y(myNs:::x)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015029"></a>;Uses a private function <code>y</code> from the namespace <code>myNs</code>, use the following code</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015085"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015157"></a>makeNamespace(&quot;A&quot;)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015158"></a>A::a1</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015159"></a>A:::a1</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015166"></a>;A::a1 returns an error because a1 is not in the export list of namespace A, whereas, A:::a1 enables you to access the symbol a1</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015160"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015192"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015071"></a>addToExportList(&#39;(A:::a1))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015072"></a>A::a1 </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015199"></a>;Allows you to access a1 from namespace A</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015036"></a></pre>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1014904"></a>The <code>addToNamespace</code> function can also be used to add symbols to the export list of a namespace. Therefore, this function is suitable for converting the existing code into one that adopts a namespace without the need to modify all the occurrences of that symbol in the code.</div>
<p>
<a id="pgfId-1015266"></a>Symbols from other namespaces can be imported to the default (or current) namespace by using any of the following methods: </p>
<ul><li>
<a id="pgfId-1015267"></a>Implicitly&#8211;from the export list by using the <code>useNamespace </code>function<br />
<a id="pgfId-1015401"></a>In the following example, function <code>y</code> can be accessed by its name after the <code>myNs</code> namespace is used.<pre class="webflare-pre-block webflare-courier-new" id="#id1015403">
<a id="pgfId-1015403"></a>useNamespace(&quot;myNs&quot; ) </pre><pre class="webflare-pre-block webflare-courier-new" id="#id1016081">
<a id="pgfId-1016081"></a>=&gt;t</pre><pre class="webflare-pre-block webflare-courier-new" id="#id1016336">
<a id="pgfId-1016336"></a>y(6)</pre><pre class="webflare-pre-block webflare-courier-new" id="#id1016323">
<a id="pgfId-1016323"></a>=&gt;(6 6)</pre></li><li>
<a id="pgfId-1016084"></a>Explicitly&#8211;by using the <code>importSymbol</code> or <code>shadowImport </code>functions <br />
<a id="pgfId-1015351"></a>In the following example, the explicit import feature is used to gain access to the symbol <code>x</code><pre class="webflare-pre-block webflare-courier-new" id="#id1015352">
<a id="pgfId-1015352"></a>importSymbol(&#39;(myNs:::x)) </pre><pre class="webflare-pre-block webflare-courier-new" id="#id1015353">
<a id="pgfId-1015353"></a>=&gt;t</pre><pre class="webflare-pre-block webflare-courier-new" id="#id1015354">
<a id="pgfId-1015354"></a>x = y(x)</pre><pre class="webflare-pre-block webflare-courier-new" id="#id1015355">
<a id="pgfId-1015355"></a>=&gt;(0 0)</pre><pre class="webflare-pre-block webflare-courier-new" id="#id1015356">
<a id="pgfId-1015356"></a>(eq &#39;x &#39;myNs:::x)</pre><pre class="webflare-pre-block webflare-courier-new" id="#id1015357">
<a id="pgfId-1015357"></a>=&gt;t</pre></li></ul>

















<p>
<a id="pgfId-1015630"></a>To be able to access the imported symbols, you can use the symbol name (without using the &quot;<code>::</code>&quot; or &quot;<code>:::</code>&quot; operator).</p>
<p>
<a id="pgfId-1015668"></a>The <code>unuseNamespace </code>function is used to remove imported symbols from a namespace. </p>

<h4>
<a id="pgfId-1015503"></a>Resolving Symbol Name Conflicts</h4>

<p>
<a id="pgfId-1015891"></a>Importing operations (that is, using the <code>importSymbol</code> or <code>useNamespace </code>functions) on a namespace can cause symbol name conflicts. For example, a name conflict can occur if a namespace contains a symbol with the same name as a symbol in the default namespace. Such conflicts can be resolved or avoided. Unhandled name conflicts cause an error and do not allow importing of any symbols. </p>
<p>
<a id="pgfId-1015815"></a>To resolve a name conflict, you can use the <code>shadow</code> or <code>shadowImport </code>functions. Using these functions you can determine the symbols that should be used in case of a name conflict.</p>
<p>
<a id="pgfId-1015989"></a>The <code>shadow</code> function is used to protect symbols in the given namespace. This means that the symbols that were <em>shadowed</em> cannot be overridden by the import operation. On the other hand, the <code>shadowImport </code>function shadows the symbol from the importing namespace and disregards any name conflict. This means that if a symbol of the same name is present then it is removed. See the following example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015505"></a>makeNamespace(&quot;ns1&quot;)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015506"></a>=&gt;t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015507"></a>ns1:::x = 9; the symbol x is assigned a value</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015508"></a>=&gt;9</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015509"></a>importSymbol(&#39;(ns1:::x))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015510"></a>*error* the symbol &#39;x&#39; is already exists</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015511"></a>shadowImport(&#39;(ns1:::x)) ;; it takes a list of symbols</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015512"></a>=&gt;t</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015513"></a>(eq &#39;ns1:::x &#39;x)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1015514"></a>=&gt;t</pre>
<h3>
<a id="pgfId-1013933"></a>Nesting Namespaces</h3>

<p>
<a id="pgfId-1013769"></a>Currently, nested namespaces are not permitted.</p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1013780"></a>Procedural interfaces need to be available to create a namespace from a given textual name.</div>
<p>
<a id="pgfId-1014671"></a>For more information about SKILL namespace functions, see Chapter 15, &#8220;<h-hot><a actuate="user" class="URL" href="../sklangref/nmspace.html#firstpage" show="replace" xml:link="simple">Namespace Functions</a></h-hot>&#8221; in the <em>SKILL Language Reference Guide</em>.</p>

<h2>
<a id="pgfId-1013741"></a><a id="31969"></a>Evaluation</h2>

<p>
<a id="pgfId-1013743"></a>SKILL provides <a id="marker-1013742"></a>functions that invoke the evaluator to execute a SKILL expression. You can therefore store programs as data to be subsequently executed. You can dynamically create, modify, or selectively evaluate function definitions and expressions. </p>

<h3>
<a id="pgfId-1008295"></a>Evaluating an Expression (<a id="marker-1008294"></a>eval)</h3>

<p>
<a id="pgfId-1008296"></a><code>eval</code> accepts any SKILL expression as an argument. <code>eval</code> evaluates an argument and returns its value. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008297"></a>eval( &#39;( plus 2 3 ) )=&gt; 5</pre>

<p>
<a id="pgfId-1008298"></a>Evaluates the expression <code>plus(2 3)</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009932"></a>x = 5<br />eval( &#39;x )=&gt; 5</pre>

<p>
<a id="pgfId-1010307"></a>Evaluates the symbol x and returns the value of symbol x.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1010308"></a>eval( list( &#39;max 2 1 ) ) =&gt; 2</pre>

<p>
<a id="pgfId-1010309"></a>Evaluates the expression <code>max(2 1)</code>.</p>

<h3>
<a id="pgfId-1008304"></a>Getting the Value of a Symbol (<a id="marker-1008303"></a>symeval)</h3>

<p>
<a id="pgfId-1008305"></a><code>symeval</code> returns the value of a symbol. <code>symeval</code> is slightly more efficient than <code>eval</code> and can be used in place of <code>eval</code> when you are sure that the argument being evaluated is indeed a symbol.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008306"></a>x = 5<br />symeval( &#39;x )=&gt; 5</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008307"></a>y = &#39;unbound<br />symeval( &#39;y )=&gt; unbound</pre>

<p>
<a id="pgfId-1008308"></a>Returns <code>unbound</code> if the symbol is <code>unbound</code>.</p>
<p>
<a id="pgfId-1008309"></a>Use the <code>symeval</code> function to evaluate symbols you encounter in lists. For example, the following <code>foreach</code> loop returns <code>aList</code> with the symbols replaced by their values.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008310"></a>a = 1<br />b = 2<br />aList = &#39;( a b 3 4 )<br />anotherList = foreach( mapcar element aList <br />      if( symbolp( element )<br />            then symeval( element )<br />            else element<br />            ) ; if<br />      ) <br />=&gt; ( 1 2 3 4 )</pre>
<h3>
<a id="pgfId-1008312"></a>Applying a Function to an Argument List (<a id="marker-1008311"></a>apply) </h3>

<p>
<a id="pgfId-1008313"></a><code>apply</code> is a function that takes two or more arguments. The first argument must be either a symbol signifying the name of a function or a function object. (Refer to <a href="chap9.html#27967">&#8220;Declaring a Function Object (lambda)&#8221;</a>.) The rest of the arguments to apply are passed as arguments to the function. </p>
<p>
<a id="pgfId-1008317"></a><code>apply</code> calls the function given as the first argument, passing it the rest of the arguments. <code>apply</code> is flexible as to how it takes the arguments to pass to the function. For example, all the calls below have the same effect, that of applying <code>plus</code> to the numbers 1, 2, 3, 4, and 5:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1010332"></a>apply(&#39;plus &#39;(1 2 3 4 5) )<br />=&gt; 15</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1010333"></a>apply(&#39;plus 1 2 3 &#39;(4 5) )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1010334"></a>apply(&#39;plus 1 2 3 4 5 nil)<br />=&gt; 15</pre>

<p>
<a id="pgfId-1008321"></a>The last argument to <code>apply</code> must always be a list.</p>
<p>
<a id="pgfId-1008322"></a>If the function is a macro, <code>apply</code> evaluates it only once, that is, <code>apply</code> expands the macro and returns the expanded form, but does not evaluate the expanded form again (as <code>eval</code> does).</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008323"></a>apply(&#39;plus (list 1 2) )         ; Apply plus to its arguments.<br />=&gt; 3</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008324"></a>defmacro( sum (@rest nums) `(plus ,@nums)) ; Define a macro.<br />=&gt; sum</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008325"></a>apply(&#39;sum &#39;(sum 1 2))<br />=&gt; (1 + 2)&#160;&#160;                     ; Returns expanded macro.</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008326"></a>eval(&#39;(sum 1 2))<br />=&gt; 3</pre>
<h2>
<a id="pgfId-1008328"></a>Read-time Evaluation</h2>

<p>
<a id="pgfId-1018007"></a>SKILL provides the <code>read-time</code> <code>eval</code> operator <code>#.</code> for evaluating expressions at read-time. When this operator is encountered, the expression following the dot is evaluated and the result of this evaluation replaces the #. For example, in the code below <code>get_filename(piport)</code> is evaluated at read-time and the results are inserted when the entire expression is compiled:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018008"></a>procedure(printFileThisWasFrom() </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017941"></a>  printf( &quot;The file is:%s\n&quot; #.get_filename(piport) ) </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018156"></a>) </pre>

<p>
<a id="pgfId-1018157"></a>If this function was defined within a file &quot;<code>code.il</code>&quot; then after the read-time evaluation, the expression would expand to the following, before being passed to the SKILL evaluator:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018106"></a>procedure(printFileThisWasFrom()</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018043"></a>  printf( &quot;The file is:%s\n&quot; &quot;code.il&quot; )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018044"></a>)</pre>
<h2>
<a id="pgfId-1017857"></a><a id="marker-1008327"></a><a id="13631"></a>Function Objects</h2>

<p>
<a id="pgfId-1008329"></a>When you use the procedure function to define a function in SKILL, the byte-code compiler generates a block of code known as a function object and places that object on the function property of a symbol. </p>
<p>
<a id="pgfId-1008330"></a>Subsequently, when SKILL encounters the symbol in a function call, the function object is retrieved and the evaluator executes the instructions. </p>
<p>
<a id="pgfId-1008331"></a>Function objects can be used in assignment statements and passed as arguments to functions such as <code>sort</code> and <code>mapcar</code>. </p>
<p>
<a id="pgfId-1008332"></a>SKILL provides several functions for manipulating function objects.</p>

<h3>
<a id="pgfId-1008334"></a>Retrieving the Function Object for a Symbol (<a id="marker-1008333"></a>getd)</h3>

<p>
<a id="pgfId-1008335"></a>You can use the <code>getd</code> function to retrieve the function object that the procedure function associates with a symbol. </p>
<p>
<a id="pgfId-1008336"></a>For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008337"></a>procedure( trAdd( x y ) <br />      printf( &quot;Adding %d and %d &#8230; %d \n&quot; x y x+y ) <br />      x+y <br />      ) <br />=&gt; trAdd</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008338"></a>getd( &#39;trAdd ) =&gt; funobj:0x1814bc0</pre>

<p>
<a id="pgfId-1008339"></a>If there is no associated function object, <code>getd</code> returns nil. The following table shows several other possible return values. </p>

<p>
<a id="pgfId-1009841"></a></p>
<table class="webflareTable" id="#id1009846">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1009848"></a>The getd Function</div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1009854">
<a id="pgfId-1009854"></a>Function</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1009856">
<a id="pgfId-1009856"></a>Return Value</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1009858">
<a id="pgfId-1009858"></a>Explanation </span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009860"></a><code>trAdd </code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009862"></a><code>funobj:0x1814bc0</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009864"></a>Application SKILL function. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009866"></a><code>edit </code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009868"></a><code>t </code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009870"></a>Read-protected SKILL function. <br />A function is read protected when it is loaded from a context or from an encrypted file.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009872"></a><code>max</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009874"></a><code>lambda:0xf6f25c</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009876"></a>Built-in lambda function.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009878"></a><code>breakpt</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009880"></a><code>nlambda:0xf7a784</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009882"></a>Built-in nlambda function.</p>
</td>
</tr>
</tbody></table>
<h3>
<a id="pgfId-1008379"></a>Assigning a New Function Binding (<a id="marker-1008378"></a>putd) </h3>

<p>
<a id="pgfId-1008380"></a>The <code>putd</code> function binds a function object to a symbol. You can undefine a function by setting its function binding to <code>nil</code>. You cannot change the function binding of a write-protected function using <code>putd</code>.</p>
<p>
<a id="pgfId-1008381"></a>For example, you can copy a function definition into another symbol as follows:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008382"></a>putd( &#39;mySqrt getd( &#39;sqrt ))=&gt; lambda:0x108b8</pre>
<p class="webflare-indent2">
<a id="pgfId-1008383"></a>Assigns the function <code>mySqrt</code> the same definition as <code>sqrt</code>.</p>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008384"></a>putd( &#39;newFun <br />      lambda( ( x y ) x + y )<br />      )<br />=&gt; funobj:0x17e0b3c<br />
newFun( 5 6 ) 
=&gt; 11</pre>

<p>
<a id="pgfId-1008385"></a>Assigns the symbol <code>newFun</code> a function definition that adds its two arguments.</p>

<h3>
<a id="pgfId-1008388"></a><a id="27967"></a>Declaring a Function Object (<a id="marker-1008387"></a>lambda)</h3>

<p>
<a id="pgfId-1008390"></a>The word <code>lambda</code> in SKILL is inherited from Lisp, which in turn inherits it from <code>lambda calculus</code><a id="marker-1008389"></a>, a mathematical compute engine on which Lisp is based.</p>
<p>
<a id="pgfId-1008391"></a>The <code>lambda</code> function builds a function object. The arguments to the <code>lambda</code> function are </p>
<ul><li>
<a id="pgfId-1008392"></a>The formal arguments </li><li>
<a id="pgfId-1008393"></a>The SKILL expressions that make up the function body (these expressions are evaluated when the function object is passed to the <code>apply</code> function or the <code>funcall</code> function) </li></ul>

<p>
<a id="pgfId-1008394"></a>Unlike the procedure function, the <code>lambda</code> function does not associate the function object with any particular symbol. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008395"></a>(lambda (x y) (sqrt (x*x + y*y))) </pre>

<p>
<a id="pgfId-1008396"></a>defines an unnamed function capable of computing the length of the diagonal side of a right-angled triangle. </p>

<h3>
<a id="pgfId-1008397"></a>Evaluating a Function Object</h3>

<p>
<a id="pgfId-1008398"></a>Unnamed or anonymous functions are useful in various situations. For example, mapping functions such as <code>mapcar</code> require a function as the first argument. You can pass either a symbol or the function object itself.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008399"></a>mapcar( &#39;get_pname &#39;( sin cos tan ))<br />=&gt; (&quot;sin&quot; &quot;cos&quot; &quot;tan&quot;)<br />mapcar( lambda(( x ) strlen( get_pname(x)) ) <br />      &#39;( sin cos tan )) <br />=&gt; ( 3 3 3 )</pre>

<p>
<a id="pgfId-1008400"></a>A <code>quote</code> before a <code>lambda</code> construct is not needed. In fact, a <code>quote</code> before a <code>lambda</code> construct used as a function is slower than one without a <code>quote</code> because the construct is compiled every time before it is called. That is, the <code>quote</code> prevents the <code>lambda</code> construct from being compiled into a function object when the code is loaded. You can save function objects in data structures. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008401"></a>var = (lambda (x y) x + y)<br />=&gt; funobj:0x1eb038</pre>

<p>
<a id="pgfId-1008402"></a>The result is a function object stored in the variable <code>var</code>. Function objects are first class objects. That is, you can use function objects just like an instance of any other type to pass as an argument to other functions or to assign as a value to variables. You can also use function objects with <code>apply</code> or <code>funcall</code>. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008403"></a>apply(var &#39;(2 8)) <br />=&gt; 10<br />funcall(var 2 8)<br />=&gt; 10</pre>
<h3>
<a id="pgfId-1008405"></a>Efficiently <a id="marker-1008404"></a>Storing Programs as Data</h3>

<p>
<a id="pgfId-1008406"></a>Whenever possible, store SKILL programs as function objects instead of text strings. Function objects are more efficient because calls to <code>eval, errset, evalstring, </code>or<code> errsetstring</code> require the compiler and generate garbage parsing the text strings. On the other hand, unquoted <code>lambda</code> expressions are compiled once. Use <code>apply</code> or <code>funcall</code> to do the evaluation.</p>

<h4>
<a id="pgfId-1008408"></a>Converting Strings to Function Objects (<a id="marker-1008407"></a>stringToFunction)</h4>

<p>
<a id="pgfId-1008409"></a>To convert an expression represented as a string into a function object with zero arguments, use <code>stringToFunction. </code>For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008410"></a>f = stringToFunction(&quot;1+2&quot;)&#160;&#160;=&gt; funobj:0x220038</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008411"></a>apply(f nil) =&gt; 3</pre>

<p>
<a id="pgfId-1008412"></a>To convert an expression represented as a list, you can construct a list with <code>lambda</code> and <code>eval</code> it. Make sure you account for any parameters:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008413"></a>expr = &#39;(x + y)<br />f = eval( &#8216;( lambda ( x y ) ,expr )) =&gt; funobj:0x33ab00<br />apply( f &#39;( 5 6 ) ) =&gt; 11</pre>

<p>
<a id="pgfId-1008414"></a>You can always construct the expression as a <code>lambda</code> construct at the outset to avoid an unnecessary call to <code>eval</code>.</p>

<h2>
<a id="pgfId-1008416"></a><a id="90007"></a>Ma<a id="Macros"></a>cros </h2>

<p>
<a id="pgfId-1008418"></a>Macros in SKILL are <a id="marker-1008417"></a>different from macros in C. </p>
<ul><li>
<a id="pgfId-1008419"></a>In C, macros are essentially syntactic substitutions of the body of the macro for the call to the macro. </li><li>
<a id="pgfId-1008421"></a>A <a id="marker-1008420"></a>macro function allows you to adapt the normal SKILL function call syntax to the needs of your application.</li></ul>


<h3>
<a id="pgfId-1008422"></a>Benefits of Macros</h3>

<p>
<a id="pgfId-1008423"></a>SKILL macros can be used in various situations: </p>
<ul><li>
<a id="pgfId-1008424"></a>To gain speed by replacing function calls with in-line code </li><li>
<a id="pgfId-1008425"></a>To expand constant expressions for readability </li><li>
<a id="pgfId-1008426"></a>As convenience wrappers on top of existing functions <br /><div class="webflare-information-macro webflare-macro-warning">
<a id="pgfId-1008427"></a>
In-line expansion increases the size of the code using macros. So, use macros sparingly and only in those situations where they clearly add value to the code. </div></li></ul>




<h3>
<a id="pgfId-1008429"></a>Macro <a id="marker-1008428"></a>Expansion</h3>

<p>
<a id="pgfId-1008430"></a>When SKILL encounters a macro function call, it evaluates the function call immediately and the last expression computed is compiled in the current function object. This process is called macro expansion. Macro expansion is inherently recursive: the body of a macro function can refer to other macros including itself.</p>
<p>
<a id="pgfId-1008431"></a>Macros should be defined before they are referenced. This is the most efficient way to process macros. If a macro is referenced before it is defined, the call is compiled as &#8220;unknown&#8221; and the evaluator expands it at run-time, incurring a serious penalty in performance for macros.</p>

<h3>
<a id="pgfId-1008432"></a>Redefining Macros</h3>

<p>
<a id="pgfId-1008434"></a>If you are in development mode and you redefine a <a id="marker-1008433"></a>macro, make sure all code that uses that macro is reloaded or redefined. Otherwise, wherever the macro was expanded, the previous definition continues to be used.</p>

<h3>
<a id="pgfId-1008436"></a><a id="marker-1008435"></a>defmacro </h3>

<p>
<a id="pgfId-1008438"></a>To define a <a id="marker-1008437"></a>macro in SKILL, use <code>defmacro</code>.</p>
<p>
<a id="pgfId-1008439"></a>For example, if you want to check the value of a variable to be a string before calling <code>printf</code> and you don&#8217;t want to write the code to perform the check at every place where <code>printf</code> is called, you might consider writing a macro:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008440"></a>(defmacro myPrintf (arg) `when((stringp ,arg) <br /> printf( &quot;%s&quot; ,arg)))</pre>

<p>
<a id="pgfId-1008441"></a>As you can see, the macro <code>myPrintf</code> returns an expression constructed using backquote, which is substituted for the call to <code>myPrintf</code> at the time a function calling <code>myPrintf</code> is defined. </p>

<h3>
<a id="pgfId-1008442"></a>mprocedure</h3>

<p>
<a id="pgfId-1008444"></a>The <a id="marker-1008443"></a><code>mprocedure</code> function is a more primitive facility on which <code>defmacro</code> is based. Avoid using <code>mprocedure</code> in new code that you are developing. Use <code>defmacro</code> instead. While compiling source code, when SKILL encounters an <code>mprocedure</code> call, the entire list representing the function call is passed to the <code>mprocedure</code> immediately, bound to the single formal argument. The result of the last expression computed within the <code>mprocedure</code> is compiled.</p>

<h3>
<a id="pgfId-1008446"></a>Using the Backquote (<code>`</code>) Operator with defmacro<a id="marker-1008445"></a></h3>

<p>
<a id="pgfId-1008447"></a>Here is a sample macro that highlights the effect of compile time macro expansion in SKILL. It assumes <code>isMorning</code> and <code>isEvening</code> are defined.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008448"></a>(defmacro myGreeting (_arg)<br />      let((_res)<br />            cond( (isMorning() <br />                              _res= sprintf(nil &quot;Good morning %s&quot; _arg))<br />                         (isEvening()<br />                              _res= sprintf(nil &quot;Good evening %s&quot; _arg)))<br />            `println(,_res))<br />)</pre>

<p>
<a id="pgfId-1008449"></a>Use the utility function <code>expandMacro</code> to test the expansion, for example,</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008450"></a>expandMacro(&#39;myGreeting(&quot;Sue&quot;)) ; using the above definition<br />=&gt; println(&quot;Good morning Sue&quot;)&#160;&#160;; if isMorning returns t</pre>

<p>
<a id="pgfId-1008451"></a>When called, <code>myGreeting</code> returns a <code>println</code> statement with the desired greeting to be in-line substituted for the call to <code>myGreeting</code>. Because the call to <code>sprintf</code> inside <code>myGreeting</code> is performed outside of the expression returned, the greeting message reflects the time when the code was compiled, and not when it was run. </p>
<p>
<a id="pgfId-1008452"></a>This is how <code>myGreeting</code> should be rewritten to have the greeting message reflect the time the code was run:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008453"></a>(defmacro myGreeting (_arg)<br />     `let((_res)<br />        cond( (isMorning() <br />                     _res= sprintf(nil &quot;Good morning %s&quot; ,_arg))<br />                  (isEvening()<br />                     _res= sprintf(nil &quot;Good evening %s&quot; ,_arg)))<br />        println(_res))<br />)</pre>

<p>
<a id="pgfId-1008454"></a>The above, when compiled, substitutes the entire <code>let</code> expression in-line for the macro call. </p>

<h3>
<a id="pgfId-1008456"></a>Using an @rest Argument with <a id="marker-1008455"></a>defmacro </h3>

<p>
<a id="pgfId-1008457"></a>The next macro example shows how a functionality can be implemented efficiently by exploiting in-line expansion. The macro implements <code>letOrdered</code>. It differs from regular <code>let</code> in that it performs the bindings for the declared local variables in sequence, so an earlier declared variable can be used in expressions evaluated to bind subsequent variable declarations, which is not safe to do in a <code>let</code>. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008458"></a>(letOrdered ((x 1) (y x+1) &#8230;)</pre>

<p>
<a id="pgfId-1008459"></a>guarantees that <code>x</code> is first bound to 1 when the binding for <code>y</code> is done. </p>
<p>
<a id="pgfId-1008460"></a>The <code>letOrdered</code> macro</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008461"></a>defmacro(letOrdered (decl @rest body)<br />                  cond(( zerop(length(decl))<br />                                     cons(&#8216;progn body))<br />                         ( t &#8216;let((,car(decl)) <br />                                          letOrdered(,cdr(decl),@body)))<br />                  )<br />)</pre>

<p>
<a id="pgfId-1008462"></a>is defined recursively. For each variable declaration, it nests <code>let</code> statements, thereby guaranteeing that all bindings are performed sequentially. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008463"></a>procedure( foo() <br />      letOrdered(((x 1) (y x+1)) <br />                        y+x))</pre>

<p>
<a id="pgfId-1008464"></a>expands to</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008465"></a>procedure(foo() <br />      let(((x 1)) <br />            let(((y x+1)) <br />                        progn( y+x ))))</pre>
<h3>
<a id="pgfId-1008467"></a>Using @key Arguments with <a id="marker-1008466"></a>defmacro</h3>

<p>
<a id="pgfId-1008468"></a>The following example illustrates a custom syntax for a special way to build a list from an original list by applying a filter and a transformation. To build a list of the squares of the odd integers in the list </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008469"></a>      ( 0 1 2 3 4 5 6 7 8 9 )</pre>

<p>
<a id="pgfId-1008470"></a>you write </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008471"></a>trForeach( <br />      ?element         x <br />      ?list            &#39;( 0 1 2 3 4 5 6 7 8 9 ) <br />      ?suchThat        oddp(x) <br />      ?collect         x*x <br />      ) =&gt; ( 1 9 25 49 81 )</pre>

<p>
<a id="pgfId-1008472"></a>instead of the more complicated</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008473"></a>foreach( mapcar x <br />      setof(x &#39;(0 1 2 3 4 5 6 7 8 9) oddp(x)) <br />      x * x<br />      ) =&gt; ( 1 9 25 49 81 ) </pre>

<p>
<a id="pgfId-1008474"></a>Implementing an easy-to-maintain macro requires knowledge of how to build SKILL expressions dynamically using the backquote (&#8216;), <br />comma (,), and comma-at (,@) operators.</p>
<p>
<a id="pgfId-1008475"></a>The definition for <code>trForeach</code> follows.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008476"></a>defmacro( trForeach ( @key element list suchThat collect )<br />      `foreach( mapcar ,element<br />            setof( ,element ,list ,suchThat )<br />                  ,collect<br />            ) ; foreach<br />) ; defmacro</pre>
<h2>
<a id="pgfId-1008477"></a><a id="42449"></a>Variables</h2>

<p>
<a id="pgfId-1008479"></a>SKILL uses symbols for both global and local <a id="marker-1008478"></a>variables. In SKILL, global and local variables are handled differently from <a id="marker-1008480"></a>C and <a id="marker-1008481"></a>Pascal. </p>

<h3>
<a id="pgfId-1008482"></a>Lexical Scoping</h3>

<p>
<a id="pgfId-1008483"></a>In C and Pascal, a program can refer to a local variable only within certain textually defined regions of the program. This region is called the <code>lexical scope</code><a id="marker-1008484"></a> of the variable. For example, the lexical scope of a local variable is the body of the function. In particular</p>
<ul><li>
<a id="pgfId-1008485"></a>Outside of a function, local variables are inaccessible </li><li>
<a id="pgfId-1008486"></a>If a function refers to non-local variables, they must be global variables </li></ul>


<h3>
<a id="pgfId-1008489"></a><a id="29809"></a>Dynamic Scoping<a id="marker-1011798"></a></h3>

<p>
<a id="pgfId-1008491"></a>SKILL <a id="Dynamic Scoping"></a>does not rely on lexical scoping rules at all. Instead:</p>
<ul><li>
<a id="pgfId-1008492"></a>A symbol&#8217;s current value is accessible at any time from anywhere within your application </li><li>
<a id="pgfId-1008493"></a>SKILL transparently manages a symbol&#8217;s value slot as if it were a stack </li><li>
<a id="pgfId-1008494"></a>The current value of a symbol is the top of the stack </li><li>
<a id="pgfId-1008495"></a>Assigning a value to a symbol changes only the top of the stack </li><li>
<a id="pgfId-1008496"></a>Whenever the flow of control enters a <code>let</code> or <code>prog</code> expression, the system pushes a temporary value onto the value stack of each symbol in the local variable list (he local variables are normally initialized to <code>nil</code>) </li><li>
<a id="pgfId-1008497"></a>Whenever the flow exits the <code>let</code> or <code>prog</code> expression, the prior values of the local variables are restored </li></ul>






<h3>
<a id="pgfId-1008499"></a><a id="marker-1008498"></a>Dynamic Globals</h3>

<p>
<a id="pgfId-1008500"></a>During the execution of your program, the SKILL programming language does not distinguish between global and local variables.</p>
<p>
<a id="pgfId-1008501"></a>The term <code>dynamically scoped variable</code> refers to a variable used as a local variable in one procedure and as a global in another procedure. Such variables are of concern because any function called from within a <code>let</code> or <code>prog</code> expression can alter the value of the local variables of that <code>let</code> or <code>prog</code> expression. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008502"></a>procedure( trOne()<br />      let( ( aGlobal )<br />            aGlobal = 5 ;;; set the value of trOne&#8217;s local variable<br />            trTwo()<br />            aGlobal     ;;; return the value of trOne&#8217;s local variable<br />            ) ;let<br />      ) ; procedure<br />
procedure( trTwo()
&#160;&#160;    printf(&quot;\naGlobal: %L&quot; aGlobal ) <br />      aGlobal = 6<br />      printf(&quot;\naGlobal: %L\n&quot; aGlobal ) <br />      aGlobal<br />      ) ; procedure</pre>

<p>
<a id="pgfId-1008503"></a>The <code>trOne</code> function uses the <code>let</code> function to define <code>aGlobal</code> to be a local variable. However, <code>aGlobal</code>&#8217;s temporary value is accessible to any function <code>trOne</code> calls. In particular, the <code>trTwo</code> function changes <code>aGlobal</code>. </p>
<p>
<a id="pgfId-1008504"></a>This change is not intuitively expected and can lead to problems that are difficult to isolate. SKILL Lint reports this type of variable as an &#8220;Error Global.&#8221; It is usually recommended that users should not rely on the dynamic behavior of variable bindings.</p>

<h2>
<a id="pgfId-1008505"></a><a id="35042"></a>Error Handling</h2>

<p>
<a id="pgfId-1012528"></a>SKILL has a robust <a id="marker-1012527"></a>error handling environment that allows functions to abort their execution and recover from user errors safely. When an error is discovered, you can send an error signal up the calling hierarchy. The error is then caught by the first error catcher that is active. The default error catcher is the SKILL top level, which catches all errors that were not caught by your own error catchers. In addition, starting from the IC6.1.6 release, SKILL can handle unusual situations or exceptions, which may occur during the execution of your programs by using the <code>throw </code>and <code>catch </code>functions. </p>

<h3>
<a id="pgfId-1012530"></a>The err<a id="errset"></a>set Function</h3>

<p>
<a id="pgfId-1008510"></a>The <a id="marker-1008509"></a><code>errset</code> function catches any errors signalled during the execution of its body. The <code>errset</code> function returns a value based on how the error was signalled. If no error is signalled, the value of the last expression computed in the <code>errset</code> body is returned in a list. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008511"></a>errset( 1+2 )(3)</pre>

<p>
<a id="pgfId-1008512"></a>In the following example, without the <code>errset</code> wrapper, the expression </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008513"></a>1+&quot;text&quot; </pre>

<p>
<a id="pgfId-1008514"></a>signals an error and display the messages</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008515"></a>*Error* plus: can&#8217;t handle (1 + &quot;text&quot;)</pre>

<p>
<a id="pgfId-1009936"></a>To trap the error, wrap the expression in an <code>errset</code>. Trapping the error causes the <code>errset</code> to return <code>nil</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009937"></a>errset( 1+&quot;text&quot; ) =&gt; nil</pre>

<p>
<a id="pgfId-1009938"></a>If you pass <code>t</code> as the second argument, any error message is displayed. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008519"></a>errset( 1+&quot;text&quot; t ) =&gt; nil<br />*Error* plus: can&#8217;t handle (1 + &quot;text&quot;)</pre>

<p>
<a id="pgfId-1008520"></a>Information about the error is placed in the <code>errset</code> property of the <code>errset</code> symbol. Programs can therefore access this information with the <code>errset.errset</code> construct after determining that <code>errset </code>returned <code>nil.</code></p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008521"></a>errset( 1+&quot;text&quot; ) =&gt; nil<br />errset.errset =&gt; <br />(&quot;plus&quot; 0 t nil <br />      (&quot;*Error* plus: can&#8217;t handle (1 + \&quot;text\&quot;)&quot;))</pre>

<p>
<a id="pgfId-1018513"></a>When working in the CIW, to ensure that the <code>errset.errset</code> variable is not modified internally in the Virtuoso Studio design environment, do not separate <code>errset</code> and <code>errset.errset</code>. For example, use this construct:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1018509"></a>errset(sqrt(&#39;x)), errset.errset <br />=&gt; (&quot;sqrt&quot; 0 t nil&#160;&#160;  (&quot;*Error* sqrt: cannot handle sqrt(x)&quot;))</pre>
<h3>
<a id="pgfId-1008522"></a>Using err and errset Together</h3>

<p>
<a id="pgfId-1008524"></a>Use the err<a id="marker-1008523"></a> function to pass control from the point at which an error is detected to the closest errset on the stack. You can control the return value of the errset by your argument to the err function.</p>
<p>
<a id="pgfId-1008525"></a>If this error is caught by an <code>errset</code>, <code>nil</code> is returned by that <code>errset</code>. However, if an optional argument is given, that value is returned from the <code>errset</code> in a list and can be used to identify which <code>err</code> signaled the error. The <code>err</code> function never returns.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008526"></a>procedure( trDivide( x )<br />      cond(<br />            ( !numberp( x ) err() )<br />            ( zerop( x ) err( &#39;trDivideByZero ) )<br />            ( t 1.0/x )<br />            )<br />      ) ; procedure </pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008527"></a>errset( trDivide( 5 ) )      =&gt; ( 0.2 )<br />errset( trDivide( 0 ) )      =&gt; (trDivideByZero)<br />errset( trDivide( &quot;text&quot; ) ) =&gt; nil</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008528"></a>errset( err( &#39;ErrorType) )   =&gt; (ErrorType)<br />errset.errset&#160;&#160;                                        =&gt; nil</pre>
<h3>
<a id="pgfId-1008529"></a>The error Function</h3>

<p>
<a id="pgfId-1008531"></a><code>error</code><a id="marker-1008530"></a> prints any error messages and then calls <code>err</code> flagging the error. The first argument can be a format string that causes the rest of the arguments to print using that format. Here are some examples:</p>

<p>
<a id="pgfId-1011693"></a></p>
<table class="webflareTable" id="#id1011697">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011699">
<a id="pgfId-1011699"></a>This function:</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1011701">
<a id="pgfId-1011701"></a>Prints the following:</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011719"></a>error( &quot;myFunc&quot; &quot;Bad List&quot; )</pre>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011751"></a>*Error* myFunc: Bad List</pre>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011775"></a>error( &quot;bad args - %s %d %L&quot; &quot;name&quot; 100 &#39;(1 2 3) )</pre>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011731"></a></pre>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011759"></a>*Error* bad args - name 100 (1 2 3)</pre>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011743"></a>errset( error( &quot;test&quot; ) t)=&gt; nil</pre>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011767"></a>*Error* test</pre>
</td>
</tr>
</tbody></table>
<h3>
<a id="pgfId-1008538"></a>The warn Function</h3>

<p>
<a id="pgfId-1008540"></a><code>warn</code><a id="marker-1008539"></a> queues a warning message string. After a function returns to the top level, all queued warning messages are printed in the Command Interpreter Window and the system flushes the warning queue. Arguments to <code>warn</code> use the same format specification as <code>sprintf</code>, <code>printf</code>, and <code>fprintf</code>.</p>
<p>
<a id="pgfId-1008541"></a>This function is useful for printing SKILL warning messages in a consistent format. You can also suppress a message with a subsequent call to<code> getWarn</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008542"></a>arg1 = &#39;fail<br />warn( &quot;setSkillPath: first argument must be a string or list of strings - %s\n&quot; arg1)<br />=&gt; nil<br />
*WARNING* setSkillPath: first argument must be a string or list of strings - fail</pre>
<h3>
<a id="pgfId-1008543"></a>The getWarn Function</h3>

<p>
<a id="pgfId-1008545"></a><code>getWarn</code><a id="marker-1008544"></a> dequeues the most recently queued warning from a previous <code>warn</code> function call and returns that warning as its return result. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008546"></a>procedure( testWarn( @key ( dequeueWarn nil ) )<br />      warn(&quot;This is warning %d\n&quot; 1 ) ;;; queue a warning<br />      warn(&quot;This is warning %d\n&quot; 2 ) ;;; queue a warning<br />      warn(&quot;This is warning %d\n&quot; 3 ) ;;; queue a warning<br />      when( dequeueWarn <br />            getWarn() ;;; return the most recently queued warning<br />            )<br />      ) ; procedure</pre>

<p>
<a id="pgfId-1008547"></a>The <code>testWarn</code> function prints the warning if <code>t</code> is passed in and gets the warning if <code>nil</code> is given as an argument.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008548"></a>testWarn( ?dequeueWarn nil)<br />=&gt; nil<br />*WARNING* This is warning 1<br />*WARNING* This is warning 2<br />*WARNING* This is warning 3</pre>

<p>
<a id="pgfId-1008549"></a>Returns <code>nil</code> and the system prints all the queued warnings.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008550"></a>testWarn( ?dequeueWarn t)<br />=&gt; &quot;This is warning 3\n&quot;<br />*WARNING* This is warning 1<br />*WARNING* This is warning 2</pre>

<p>
<a id="pgfId-1008551"></a>Returns the dequeued (most recent) warning and the system prints the remaining queued warnings.</p>
<p>
<a id="pgfId-1020018"></a></p>
<p>
<a id="pgfId-1020020"></a></p>
<p>
<a id="pgfId-1020016"></a></p>

<h3>
<a id="pgfId-1018792"></a>The muffleWarnings and getMuffleWarnings Functions</h3>

<p>
<a id="pgfId-1018793"></a>The <code>muffleWarnings</code> function can be used when it is not desirable to show warning messages from functions included in a piece of code. In such cases, where the number of messages is dynamic, the <code>getWarn</code> function is not feasible.</p>
<p>
<a id="pgfId-1018794"></a>Wrapping code in <code>muffleWarnings</code> dequeues all SKILL warning messages within the enclosed code. You can include the <code>getMuffleWarnings</code> function within it to retrieve the muffled warnings, which can then be used to build a new message, if required.</p>
<p>
<a id="pgfId-1019917"></a>The following example illustrates the use of <code>muffleWarnings</code> with function calls that will result in a dynamic number of warning messages.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019632"></a>procedure( myTask( task @optional object )
&#160;&#160;&#160;&#160;let((code)<br />        if( typep( task ) == &#39;string then<br />            code = case( task<br />                (&quot;Open&quot; <br />                    unless( object <br />                        warn( &quot;Object not defined\n&quot; ) <br />                    )<br />                    1<br />                )<br />                (&quot;Close&quot; <br />                    2<br />                )<br />                (t <br />                    warn( &quot;Unknown task specified\n&quot; )<br />                    0<br />                )<br />            )<br />        else<br />            warn( &quot;Task is expected to a string\n&quot; )<br />        )<br />        unless( code <br />            warn( &quot;Unexpected task result\n&quot; )<br />        )<br />        code<br />    )<br />)<br /></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019778"></a>myTask( &quot;Open&quot; &quot;Door&quot; )<br />=&gt; 1</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019887"></a>myTask( &quot;Open&quot; )<br />*WARNING* Object not defined<br />=&gt; 1</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019914"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019912"></a>myTask( &quot;Look&quot; )<br />*WARNING* Unknown task specified<br />*WARNING* Unexpected task result<br />=&gt; nil</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019906"></a>muffleWarnings(<br />    myTask( &quot;Open&quot; &quot;Door&quot; )<br />)<br />=&gt; 1<br />getMuffleWarnings() =&gt; nil</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019908"></a>muffleWarnings(</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019678"></a>    myTask( &quot;Open&quot; )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019679"></a>)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019680"></a>=&gt; 1<br />getMuffleWarnings() =&gt; (&quot;Object not defined\n&quot;)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019910"></a>muffleWarnings(</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019683"></a>    myTask( &quot;Look&quot; )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019684"></a>)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1019685"></a>=&gt; nil<br />getMuffleWarnings() =&gt; (&quot;Unknown task specified\n&quot; &quot;Unexpected task result\n&quot;)</pre>

<p>
<a id="pgfId-1019304"></a>The results for <code>getMuffleWarnings</code> pertain to the preceding <code>muffleWarnings</code> command. </p>

<h3>
<a id="pgfId-1012613"></a>The throw and catch Functions</h3>

<p>
<a id="pgfId-1013416"></a>The <code>throw</code> and <code>catch</code> functions implement the exception mechanism in SKILL. These functions can be used to throw exceptions of various types with the help of <code>tags</code> and provide handlers for each <code>tag</code>. When a <code>throw</code> occurs and a particular <code>tag </code>or exception is caught, the SKILL stack is unwound to the initial point of block execution and <code>catch</code> block returns the value produced by evaluating <code>throw</code> form(s).</p>
<p>
<a id="pgfId-1012885"></a>The <code>throw</code> function should always be defined inside a&#160;&#160;block. There can also be nested&#160;&#160;blocks. </p>
<p>
<a id="pgfId-1012869"></a>The syntax for using the <code>catch</code> and <code>throw</code> functions is as follows:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012849"></a>(s_tag g_form) =&gt; g_result</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012965"></a>throw(s_tag g_value) </pre>

<p>
<a id="pgfId-1012966"></a>You can specify an <code>s_tag</code> to be <code>t</code>, in which case the function will&#160;&#160;any condition thrown by the corresponding throw.</p>
<p>
<a id="pgfId-1013023"></a>The steps of execution of the <code>catch</code> and <code>throw</code> functions is as follows:</p>
<ol><li>
<a id="pgfId-1013032"></a>Evaluate <code>s_tag</code> and establish it as a return point.</li><li>
<a id="pgfId-1013163"></a>Evaluate the forms and return the results of the last form unless a <code>throw</code> occurs. </li><li>
<a id="pgfId-1013244"></a>If a <code>throw</code> occurs, transfer the control to the block for which s_tag corresponds with the s_tag argument of the <code>throw </code>function. No more forms are evaluated any further. </li></ol>



<h2>
<a id="pgfId-1008553"></a><a id="33792"></a>Top Levels</h2>

<p>
<a id="pgfId-1008554"></a>When you run SKILL or non-graphical applications built on top of SKILL, you are talking to the SKILL <a id="marker-1008555"></a>top level, which reads your input from the terminal, evaluates the expressions, and prints the results. If an error is encountered during the evaluation of expressions, control is usually passed back to the top level. </p>
<p>
<a id="pgfId-1008556"></a>When you are talking to the top level, any complete expression that you type (followed by typing the Return key to signal the end of your input) is evaluated immediately. Following the evaluation, the value of the expression is pretty printed.</p>
<p>
<a id="pgfId-1008557"></a>If only the name of a symbol is typed at the top level, SKILL checks if the variable is <code>bound</code>. If so, the value of the variable is printed. Otherwise, the symbol is taken to be the name of a function to call (with no arguments). The following examples show how the outer pair of parentheses can be omitted at the top-level.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008558"></a>if (ga &gt; 1) 0 1<br />if( (a &gt; 1) 0 1 )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008559"></a>loadi &quot;file.ext&quot;<br />loadi(&quot;file.ext&quot;)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008560"></a>exit                 ; Assuming exit has no variable binding<br />exit() </pre>

<p>
<a id="pgfId-1008561"></a>The default top level uses <code>lineread</code>, so it quietly waits for you to complete an expression if there are any open parentheses or any binary <code>infix</code> operators that have not yet been assigned a right operand. If SKILL seems to do nothing after you press Return, chances are you have mistyped something and SKILL is waiting for you to complete your expression. </p>
<p>
<a id="pgfId-1008563"></a>Sometimes typing a <a id="marker-1008562"></a>super right bracket (]) is all you need to properly terminate your input expression. If you mistype something when entering a form that spans multiple lines, you can cancel your input by pressing <em>Control-c</em>. You can also press <em>Control-c</em> to interrupt function execution.</p>

<h2>
<a id="pgfId-1008565"></a><a id="68393"></a>Memory Management (Garbage Collection)</h2>

<p>
<a id="pgfId-1008567"></a>In SKILL all <a id="marker-1008566"></a>memory allocation and deallocation is managed automatically. That is, the developer using SKILL does not have to remember to deallocate unused structures. For example, when you create an array or an instance of a <code>defstruct</code> and assign it as a value to a variable declared locally to a procedure, if the structure is no longer in use after the procedure exits, the memory manager reclaims that structure automatically. In fact, reclaimed structures are subsequently recycled. For users programming in SKILL, garbage collection simplifies bookkeeping to the point that most users do not have to worry about storage management at all.<a id="marker-1008568"></a></p>
<p>
<a id="pgfId-1008569"></a>The allocator keeps a pool of memory for each data type and, on demand, it allocates from the various pools and reclaimed structures are returned to the pool. The process of reclaiming unused memory - garbage collection (GC) - is triggered when a memory pool is exhausted. </p>
<p>
<a id="pgfId-1008570"></a>Garbage collection replenishes the pool by tracking all unused or unreferenced memory and making that memory available for allocation. If garbage collection cannot reclaim sufficient memory, the allocator applies heuristics to expand the memory pools by a factor determined at run time.</p>
<p>
<a id="pgfId-1008571"></a>Garbage collection is transparent to SKILL users and to users of applications built on top of SKILL. The system might slow down for a brief moment when garbage collection is triggered, but in most cases it should not be noticeable. However, unrestrained use of memory in SKILL applications can result in more time spent in garbage collection than intended.</p>

<h3>
<a id="pgfId-1008572"></a>How to Work with Garbage Collection</h3>

<p>
<a id="pgfId-1008574"></a>The <a id="marker-1008573"></a>garbage collector uses a heuristic procedure that dynamically determines when and if additional working memory should be allocated from the operating system. The procedure works well in most cases, but because optimal time/space trade-offs can vary from application to application, you might sometimes want to override the default system parameters. </p>
<p>
<a id="pgfId-1008575"></a>When an application is known to use certain SKILL data types more than others, you can measure the amount of memory pools needed for the session and preallocate that pool. This allocation helps reduce the number of garbage collection cycles triggered in a session. However, because the overhead caused by garbage collection is typically only several percent of total run time, such fine-tuning might not be worthwhile for many applications. </p>
<p>
<a id="pgfId-1008576"></a>First you need to analyze your memory usage by using <code>gcsummary</code>. This function prints a breakdown of memory allocation in a session. See the next section for a sample output. Once you have determined how many instances of a data type you need for the session, you can preallocate memory for that data type by using <code>needNCells</code> (described at the end of this section).</p>
<p>
<a id="pgfId-1009952"></a>For the most part, you do not need to fine tune memory usage. You should first use memory profiling (refer to the chapter about SKILL Profiler in <em>Cadence SKILL IDE User Guide</em>) to see if you can track down where the memory is generated and deal with that first. Use the memory tuning technique described in this section as a last resort. Remember, because all memory tuning is global, you can&#8217;t just tune the memory for your application. All other applications running in the same currently running binary are affected by your tuning.</p>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1017660"></a>To troubleshoot performance and memory management issues in your SKILL code, contact Cadence Customer Support.</div>

<h3>
<a id="pgfId-1017628"></a><a id="62651"></a>Printing Summary Statistics</h3>

<p>
<a id="pgfId-1017631"></a>The <a id="marker-1017629"></a><code>gcsummary</code> function prints a summary of memory allocation and garbage collection statistics in the current SKILL run.<a id="marker-1017630"></a></p>

<p>
<a id="pgfId-1009888"></a></p>
<table class="webflareTable" id="#id1009892">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1009894"></a>How to Interpret the Summary Report</div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1009898">
<a id="pgfId-1009898"></a>Column </span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1009900">
<a id="pgfId-1009900"></a>Contains</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009902"></a>Type</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009904"></a>Data type names.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009906"></a>Size</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009908"></a>Size of each atom representing the data type in bytes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009910"></a>Allocated</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009912"></a>Total number of bytes allocated in the pool for the data type.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009914"></a>Free</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009916"></a>Number of bytes that are free and available for allocation.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009918"></a>Static</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009920"></a>Memory allocated in static pools that are not subject to GC. This memory is usually generated when contexts are built. When variables are write protected, their contents are shifted to static pools.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009922"></a>GC Count</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1009924"></a>Number of GC cycles triggered because the pool for this data type was exhausted.</p>
</td>
</tr>
</tbody></table>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008617"></a>************* SUMMARY OF MEMORY ALLOCATION *************<br />Maximum Process Size (i.e., voMemoryUsed) = 3589448<br />Total Number of Bytes Allocated by IL = 2366720<br />Total Number of Static Bytes          = 1605632<br />-----------------------------------------------------------<br />Type       Size   Allocated     Free      Static   GC count<br />-----------------------------------------------------------<br />list         12      339968    42744     1191936          9<br />fixnum        8       36864    36104       12288          0<br />flonum       16        4096     2800       20480          0<br />string        8       90112    75008       32768          0<br />symbol       28           0        0      303104          0<br />binary       16           0        0        8192          0<br />port         60        8192     7680           0          0<br />array        16       20480     8288        8192          0<br />TOTALS       --      516096   188848     1576960          9<br />-----------------------------------------------------------<br />User Type (ID)             Allocated     Free    GC count<br />-----------------------------------------------------------<br />hiField              (20)       8192     7504           0<br />hiToggleItem         (21)       8192     7900           0<br />hiMenu               (22)       8192     7524           0<br />hiMenuItem           (23)       8192     5600           0<br />TOTALS                --       32768    28528           0<br />-----------------------------------------------------------<br />Bytes allocated for : <br />      arrays       = 38176<br />      strings      = 43912<br />      strings(perm)= 68708<br />      IL stack     = 49140<br />      (Internal)   = 12288<br />TOTAL GC COUNT 9 <br />----- Summary of Symbol Table Statistics -----<br />Total Number of Symbols = 11201<br />Hash Buckets Occupied = 4116 out of 4499<br />Average chain length = 2.721331</pre>
<h3>
<a id="pgfId-1008654"></a><a id="marker-1008653"></a>Allocating Space Manually</h3>

<p>
<a id="pgfId-1008656"></a>The <a id="marker-1008655"></a><code>needNCells</code> function takes a cell count and allocates the appropriate number of pages to accommodate the cell count. The name of the user type can be passed in as a string or a symbol. However, internal types, like list or fixnum, must be passed in as symbols. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008657"></a>needNCells( &#39;list 1000 )</pre>

<p>
<a id="pgfId-1008658"></a>guarantees there will always be 1000 list cells available in the system.</p>

<h2>
<a id="pgfId-1008660"></a><a id="marker-1008659"></a><a id="40164"></a>Exiting SKILL</h2>

<p>
<a id="pgfId-1008661"></a>Normally you exit SKILL indirectly by selecting the <code>Quit</code> menu command from the CIW while running the Cadence software in graphic mode, or by typing <em>Control-d</em> at the prompt while running in non-graphic mode. However, you can also call the <code>exit</code> function to exit a running SKILL application with or without an explicit status code. Both the <code>Quit</code> menu command in the CIW and <em>Control-d</em> in standalone SKILL trigger a call to <code>exit</code>.</p>
<p>
<a id="pgfId-1008662"></a>Sometimes you might like to do certain cleanup actions before exiting SKILL. You can do this by registering exit-before and/or exit-after functions, using the <a id="marker-1008663"></a><code>regExitBefore</code> and <code>regExitAfter</code><a id="marker-1008664"></a> functions. An exit-before function is called before <code>exit</code> does anything, and an exit-after function is called after <code>exit</code> has performed its bookkeeping tasks and just before it returns control to the operating system. The user-defined exit functions do not take any arguments.</p>
<p>
<a id="pgfId-1008665"></a>To give you even more control, an exit-before function can return the atom <code>ignoreExit</code> to abort the exit call totally. When <code>exit</code> is called, first all the registered exit-before functions are called in the reverse order of registration. If any of them returns the special atom <code>ignoreExit</code>, the exit request is aborted and it returns <code>nil</code> to the caller. After calling the exit-before functions, it does some bookkeeping tasks, calls all the registered exit-after functions in the reverse order of their registration, and finally exits to the operating system.</p>
<p>
<a id="pgfId-1008666"></a>For compatibility with earlier versions of SKILL, you can still define the functions named<code> exitbefore</code> and <code>exitafter</code> as one of the exit functions. They are treated as the first registered exit functions (the last being called). To avoid confusing the system setup, do not use these names for other purposes.</p>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap8.html" id="prev" title="Advanced List Operations">Advanced List Operations</a></em></b><b><em><a href="chap10.html" id="nex" title="Delivering Products">Delivering Products</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
 

 <div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160; </center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div> 

</body></html>