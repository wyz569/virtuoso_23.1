
<html><head><title>Using SKILL and SKILL++ Together</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="parula" />
<meta name="CreateDate" content="2023-08-23" />
<meta name="CreateTime" content="1692797217" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the SKILL language to new users and helps them understand advanced topics, encourages sound SKILL programming methods, and introduces the SKILL++ language" />
<meta name="DocTitle" content="Cadence SKILL Language User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="Using SKILL and SKILL++ Together" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-4.0.0" />
<meta name="Keyword" content="sklanguser" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-08-23" />
<meta name="ModifiedTime" content="1692797217" />
<meta name="NextFile" content="chap16.html" />
<meta name="Group" content="SKILL Language" />
<meta name="Platform" content="Cadence Shared Tools" />
<meta name="PrevFile" content="chap14.html" />
<meta name="c_product" content="Virtuoso Layout Suite,Virtuoso Schematic Editor,Virtuoso Analog Design Environment" />
<meta name="Product" content="SKILL" />
<meta name="ProductFamily" content="SKILL" />
<meta name="ProductVersion" content="IC23.1" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Cadence SKILL Language User Guide -- Using SKILL and SKILL++ Together" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="0" />
<meta name="Version" content="IC23.1" />
<meta name="SpaceKey" content="sklanguserIC231" />
<meta name="webflare-version" content="2.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" />


  <script>/*<![CDATA[*/
 document.addEventListener("DOMContentLoaded", function(event) {  document.querySelectorAll("img").forEach((img, index) => {
if (img.hasAttribute("usemap")){return;}else{img.classList.add("cursorclass");} img.addEventListener("click", (e) => {if(img.hasAttribute("usemap")){            img.setAttribute("style","cursor:none;");return;};document.querySelector("#cad_image_modal").classList.add("opac");document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0;margin: auto;max-height:95%;"  src="${e.target.src}">`;});});});
/*]]>*/</script> 




 <style>/*<![CDATA[*/
.cursorclass{cursor:pointer;}#cad_image_modal{position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;}#cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;}#cad_image_modal span{position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;}
/*]]>*/</style> 
</head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="sklanguserTOC.html">Contents</a></li><li><a class="prev" href="chap14.html" title="Using SKILL++">Using SKILL++</a></li><li style="float: right;"><a class="viewPrint" href="sklanguser.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap16.html" title="SKILL++ Object System">SKILL++ Object System</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Cadence SKILL Language User Guide<br />Product Version IC23.1, September 2023</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<h1>15
<a id="pgfId-1005655"></a></h1>
<h1>
<a id="pgfId-1008199"></a><hr />
<a id="18182"></a>Using SKILL and SKILL++ Together<hr />
</h1>

<p>
<a id="pgfId-1010363"></a>This chapter discusses the pragmatics of developing programs in the Cadence&#174; SKILL++ language. You should be familiar with both SKILL and SKILL++, specifically the material in <a href="chap13.html#35957">&#8220;About SKILL++ and SKILL&#8221;</a> and <a href="chap14.html#14849">&#8220;Using SKILL++&#8221;</a>.</p>
<p>
<a id="pgfId-1010370"></a>Developing a SKILL++ application involves the same basic tasks as for developing SKILL applications. Because most viable applications will involve tightly integrated SKILL and SKILL++ components, there are several more factors to consider:</p>
<ul><li>
<a id="pgfId-1010371"></a>Selecting an interactive language <br />
<a id="pgfId-1010372"></a>When entering a language expression into the command interpreter, you need to choose the appropriate language mode.</li><li>
<a id="pgfId-1010373"></a>Partitioning an application into a SKILL portion and a SKILL++ portion <br />
<a id="pgfId-1010377"></a>You are <a id="marker-1010374"></a>free to implement your a<a id="marker-1010375"></a>pplication as a heterogenous collection of <a id="marker-1010376"></a>source code files. You need to choose a file extension accordingly.</li><li>
<a id="pgfId-1010378"></a>Cross-calling between SKILL and SKILL++ <br />
<a id="pgfId-1010379"></a>In general, SKILL++ functions and SKILL functions can transparently call one another. However, a few families of SKILL functions can operate differently when called from SKILL than when called from SKILL++. You need to be able to identify such SKILL functions, adjust your expectations, and exercise caution, when calling them from SKILL++.</li><li>
<a id="pgfId-1010380"></a>Debugging a SKILL++ program <br />
<a id="pgfId-1010381"></a>In a hybrid application, errors can occur in either SKILL functions or SKILL++ functions. Displaying the SKILL stack will reveal SKILL++ environments and SKILL++ function objects which you will want to examine.</li><li>
<a id="pgfId-1010484"></a>Communicating between SKILL and SKILL++<br />
<a id="pgfId-1010486"></a>Data allocated with one <a id="marker-1010485"></a>language is accessible from the other language. For example, you can allocate a list in a SKILL++ function and retrieve data from it in a SKILL function. Both languages use the same print representations for data. </li></ul>









<p>
<a id="pgfId-1010383"></a>The phrase &#8216;from within a SKILL program&#8217; means</p>
<ul><li>
<a id="pgfId-1010386"></a>from a SKILL interactive loop </li><li>
<a id="pgfId-1010387"></a>from within SKILL source code, outside of a function definition </li><li>
<a id="pgfId-1010388"></a>from within a SKILL function </li></ul>


<p>
<a id="pgfId-1010389"></a>Similar definitions apply &#8216;from within a SKILL++ program&#8217;.</p>
<p>
<a id="pgfId-1008587"></a>For more information, see the following sections:</p>
<ul><li>
<a id="pgfId-1008654"></a><a href="chap15.html#14004">Selecting an Interactive Language</a>  </li><li>
<a id="pgfId-1008660"></a><a href="chap15.html#32221">Partitioning Your Source Code</a>  </li><li>
<a id="pgfId-1008662"></a><a href="chap15.html#38250">Cross-Calling Guidelines</a>  </li><li>
<a id="pgfId-1008670"></a><a href="chap15.html#27870">Redefining Functions</a> </li><li>
<a id="pgfId-1008672"></a><a href="chap15.html#19731">Sharing Global Variables</a>  </li><li>
<a id="pgfId-1008680"></a><a href="chap15.html#31154">Debugging SKILL++ Applications</a>  </li></ul>






<h2>
<a id="pgfId-1008234"></a><a id="14004"></a>Selecting an Interactive Language </h2>

<p>
<a id="pgfId-1008237"></a>You can use <a id="marker-1008235"></a>SKILL or SKILL++ <a id="marker-1008236"></a>for interactive work. Both languages support a read-eval-print loop in which you repeat the following steps:</p>
<ol><li>
<a id="pgfId-1008238"></a>You type a language expression.</li><li>
<a id="pgfId-1008239"></a>The system parses, compiles, and evaluates the expression in accordance with either SKILL or SKILL++ languages syntax and semantics.</li><li>
<a id="pgfId-1008240"></a>The system displays the result using the print representation appropriate to the result&#8217;s data type.</li></ol>



<h3>
<a id="pgfId-1008241"></a>Starting an Interactive Loop (toplevel)</h3>

<p>
<a id="pgfId-1008245"></a>You can call the <code>toplevel</code><a id="marker-1008242"></a> function to start an interactive loop with either SKILL or SKILL++. SKILL is the default.<a id="marker-1008243"></a><a id="marker-1008244"></a></p>

<ul><li>
<a id="pgfId-1008246"></a>To select the SKILL language, type<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1008247">
<a id="pgfId-1008247"></a>toplevel( &#39;il )</pre></li><li>
<a id="pgfId-1008248"></a>To select the SKILL++ language and the SKILL++ top-level environment, type<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1008249">
<a id="pgfId-1008249"></a>toplevel( &#39;ils )</pre></li><li>
<a id="pgfId-1008250"></a>To select the SKILL++ language and the environment to be made active during the interactive loop, pass the environment object as the second argument: <br /><pre class="webflare-pre-block webflare-courier-new" id="#id1008251">
<a id="pgfId-1008251"></a>toplevel( &#39;ils envobj( 0x1e00b4 ))</pre></li></ul>






<p>
<a id="pgfId-1008252"></a>In this example, the environment object is retrieved from the print representation.</p>

<h3>
<a id="pgfId-1008253"></a>Exiting the Interactive Loop (resume)</h3>

<p>
<a id="pgfId-1008257"></a>Use the <code>resume</code><a id="marker-1008254"></a> function to exit the interactive loop, returning a specific value. This value is the return value of the <code>toplevel</code><a id="marker-1008256"></a> function. The following example is a transcript of a brief session, including prompts.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008258"></a>&gt; R = toplevel( &#39;ils )<br />ILS-&lt;2&gt; resume( 1 )<br />1<br />&gt; R<br />1&#160;&#160;              ;;;return value of the toplevel function.</pre>
<h2>
<a id="pgfId-1008259"></a><a id="32221"></a>Partitioning Your Source Code</h2>

<p>
<a id="pgfId-1011210"></a>You are free to implement your <a id="marker-1011208"></a>application as a heterogenous collection of <a id="marker-1011209"></a>source code files. The <code>load</code> and <code>loadi</code> functions select the language to apply to the source code based on the file extension.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008264"></a>FileA.il<br />FileB.il<br />FileC.ils<br />FileD.ils<br />FileE.ils</pre>

<p>
<a id="pgfId-1008265"></a>Functions defined in each file can call functions defined in the other files without regard to the language in which the functions are written. The syntax for function calls is the same regardless of whether the function called is a SKILL function or a SKILL++ function. Specifically,</p>
<ul><li>
<a id="pgfId-1008266"></a>SKILL++ functions are visible to the SKILL portions of your application </li><li>
<a id="pgfId-1008267"></a>SKILL functions are automatically visible to the SKILL++ portions of your application </li></ul>

<p>
<a id="pgfId-1008268"></a>You may call SKILL application procedural interface functions from a SKILL++ program. Most applications continue to rely heavily on SKILL functions.</p>

<h2>
<a id="pgfId-1008269"></a><a id="38250"></a>Cross-Calling Guidelines</h2>

<p>
<a id="pgfId-1008270"></a>Several key semantic differences between SKILL and SKILL++ dictate certain <a id="marker-1008271"></a>guidelines you should follow when calling SKILL functions from SKILL++, including the following:</p>
<ul><li>
<a id="pgfId-1008272"></a>All SKILL++ environments, other than the top-level environment, are invisible to SKILL </li><li>
<a id="pgfId-1008273"></a>All SKILL++ local variables are invisible to SKILL </li></ul>

<p>
<a id="pgfId-1008274"></a>You should avoid calling SKILL functions that call </p>
<ul><li>
<a id="pgfId-1008275"></a>The <code>eval</code>, <code>symeval</code>, or <code>evalstring</code> functions </li><li>
<a id="pgfId-1008276"></a>The <code>set</code> function </li></ul>

<p>
<a id="pgfId-1008277"></a>You should avoid calling <code>nlambda</code> SKILL functions.</p>

<h3>
<a id="pgfId-1008278"></a>Avoid Calling SKILL Functions That Call eval, symeval, or evalstring</h3>

<p>
<a id="pgfId-1008279"></a>When you call the one-argument version of <code>eval</code>, <code>symeval</code>, or <code>evalstring</code> functions from a SKILL function, you are using dynamic scoping. Any symbol or expression which you pass to a SKILL function will probably evaluate to a different result than it would have in the SKILL++ caller.</p>
<p>
<a id="pgfId-1008280"></a>In general, to determine whether a SKILL function calls any of these functions, you should consult the reference documentation.</p>

<h3>
<a id="pgfId-1008281"></a>Avoid Calling nlambda Functions</h3>

<p>
<a id="pgfId-1008282"></a>The nlambda category of SKILL functions are highly likely to call the <code>eval</code> or <code>symeval </code>functions.</p>
<p>
<a id="pgfId-1008283"></a>A SKILL <code>nlambda</code> function receives all of its argument expressions unevaluated in a list. Such a function usually evaluates one or more of the arguments. The <code>addVars</code> SKILL function adds the values of its arguments.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008284"></a>nprocedure( addVars( args )<br />    let( (( sum 0 ))<br />        foreach( arg args<br />            sum = sum+eval(arg)<br />            ) ; foreach<br />        sum<br />        ) <br />    ) <br />
&#160;&#160;  let( ((x 1) (y 2) (z 3 ))<br />        addVars( x y z )<br />        )<br />=&gt; 6</pre>

<p>
<a id="pgfId-1008285"></a>When called from SKILL++, the <code>eval</code> function uses dynamic scoping to resolve the variable references. In this case, the variable <code>x</code> was unbound.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008286"></a>ILS-&lt;2&gt; let( ((x 1) (y 2) (z 3 ))<br />    addVars( x y z )<br />    )<br />*WARNING* (addVars): calling NLambda from Scheme code - <br />    addVars(x y z)<br />*Error* eval: unbound variable - x<br />ILS-&lt;2&gt;</pre>

<p>
<a id="pgfId-1008287"></a>If necessary, reimplement the SKILL <code>nlambda</code> function as a SKILL or SKILL++ macro, using <code>defmacro</code>. For example,</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008288"></a>defmacro( addVars ( @rest args )<br />    `let( (( sum 0 ))<br />        foreach( arg list( ,@args )<br />            sum = sum + arg<br />            ) ; foreach<br />        sum<br />        ) <br />    ) </pre>
<h3>
<a id="pgfId-1008289"></a>Use the set Function with Care</h3>

<p>
<a id="pgfId-1008291"></a>Avoid calling SKILL functions that in turn call the <code>set</code><a id="marker-1008290"></a> function. Usually such SKILL functions store values in other SKILL variables. If you call such a function from SKILL++ and pass a quoted local variable, the SKILL function will not store the value in the SKILL++ local variable. Instead, the value goes into the SKILL variable of the same name. </p>
<p>
<a id="pgfId-1008292"></a>The following <code>SetMyArg</code> SKILL function behaves differently when called from SKILL++ than when called from SKILL.</p>

<h4>
<a id="pgfId-1008293"></a>SetMyArg Called from SKILL </h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008294"></a>&gt; procedure( SetMyArg( aSymbol aValue )<br />    set( aSymbol aValue )<br />    ) ; procedure<br />SetMyArg<br />&gt; let( ( ( x 3 ))<br />    SetMyArg( &#39;x 5 )<br />    x<br />    ) ; let<br />5</pre>
<h4>
<a id="pgfId-1008295"></a>SetMyArg Called from SKILL++ </h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008296"></a>&gt; toplevel &#39;ils <br />ILS-&lt;2&gt; let( (( x 3 ))<br />  SetMyArg( &#39;x 5 )<br />  x<br />  ) ; let<br />3</pre>
<h2>
<a id="pgfId-1008297"></a><a id="27870"></a>Redefining Functions</h2>

<p>
<a id="pgfId-1008298"></a>During a single session, you are warned when you redefine a SKILL function to be a SKILL++ <a id="marker-1008299"></a>function, or visa versa. </p>
<p>
<a id="pgfId-1008300"></a>You are only likely to encounter this when doing interactive work and are confused about which language &#8220;owns&#8221; the interaction.</p>

<h2>
<a id="pgfId-1008301"></a><a id="19731"></a>Sharing Global Variables</h2>

<p>
<a id="pgfId-1008303"></a>It is usually desirable to avoid relying on <a id="marker-1008302"></a>global variables. However, it is sometimes necessary or expedient for the SKILL++ and SKILL portions of your application to communicate through global variables.</p>

<h3>
<a id="pgfId-1008304"></a>Using importSkillVar</h3>

<p>
<a id="pgfId-1008305"></a>Before the SKILL and SKILL++ portions of your application can share a global variable, you must first call the <code>importSkillVar</code><a id="marker-1008307"></a> function. The SKILL++ global variable and the SKILL global variable will then be bound to the same location.</p>
<p>
<a id="pgfId-1008308"></a>For example, consider the following interaction with a SKILL top level.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008309"></a>&gt; delta = 2<br />2<br />&gt; procedure( adder( y )<br />    delta+y<br />    ) ;<br />adder<br />&gt; </pre>

<p>
<a id="pgfId-1008310"></a>To set the value of the <code>delta</code> variable from within a SKILL++ program, you should first</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008311"></a>importSkillVar( delta )</pre>

<p>
<a id="pgfId-1008312"></a>as the following sample interaction with a SKILL++ top level shows.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009472"></a>&gt; toplevel &#39;ils<br />ILS-&lt;2&gt;delta<br />*Error* eval: unbound variable - delta<br />ILS-&lt;2&gt; importSkillVar( delta )<br />ILS-&lt;2&gt; delta<br />2<br />ILS-&lt;2&gt; adder( 4 )<br />6</pre>
<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1008314"></a>You do not need to import <code>delta</code> just to call <code>adder</code> from within SKILL++ code.</div>
<h3>
<a id="pgfId-1008315"></a>How importSkillVar Works</h3>

<p>
<a id="pgfId-1008316"></a>Although understanding this level of detail is not necessary to effectively use <code>importSkillVar</code>, this section is provided for expert users.</p>
<p>
<a id="pgfId-1008318"></a>In SKILL++, a variable is bound to a memory location called the variable&#39;s binding. The familiar operation of &#8220;storing a value in a variable&#8221; stores the value in the variable&#39;s binding. SKILL++ variable bindings are organized into environment frames. The SKILL++ top-level environment contains all the variable bindings initially available at system start up. </p>
<p>
<a id="pgfId-1008319"></a>Normally, all global (top-level) SKILL++ variables are bound to the function slot of the SKILL symbol with the same name as the variable. For example, the variable <code>foo</code> is bound to the function slot of the symbol <code>foo</code>. Consequently, in SKILL++, when you retrieve the value of a SKILL variable, you are getting the contents of the symbol&#8217;s function slot.</p>
<p>
<a id="pgfId-1008321"></a>The <code>importSkillVar</code><a id="marker-1008320"></a> function directs the compiler to instead bind a SKILL++ global variable in the top-level environment to the value slot of the symbol with the same name. Informally, you can use <code>importSkillVar</code> to enable access to a SKILL symbol&#39;s current value binding from within SKILL++.</p>

<h3>
<a id="pgfId-1008322"></a>Evaluating an Expression with SKILL Semantics</h3>

<p>
<a id="pgfId-1008323"></a>As an advanced programmer, you might find that separating closely related SKILL code and SKILL++ code into different files is distracting or otherwise not convenient. For example, suppose that in the middle of a SKILL++ source code file you want to declare a SKILL function that refers to a SKILL variable. </p>
<p>
<a id="pgfId-1008324"></a>Using the previous example</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1010547"></a>delta = 5<br />procedure( adder( y )<br />    delta+y ) <br /></pre>

<p>
<a id="pgfId-1010549"></a>The <code>inSkill</code><a id="marker-1010548"></a> macro below allows you to splice SKILL language source code into a SKILL++ source code file. You can use the <code>inSkill</code> macro as shown.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008328"></a>inSkill(<br />    delta = 5<br />    procedure( adder( y )<br />        delta+y ) ; procedure<br />    ) </pre>
<h2>
<a id="pgfId-1008329"></a><a id="31154"></a>Debugging SKILL++ Applications</h2>

<p>
<a id="pgfId-1008330"></a>This section addresses common tasks that arise when debugging hybrid SKILL and <a id="marker-1008331"></a>SKILL++ applications.</p>

<h3>
<a id="pgfId-1008336"></a>Examining the Source Code for a Function Object</h3>

<p>
<a id="pgfId-1008337"></a>Use the <code>pp</code> SKILL function to display the source code for a global function. The <code>pp</code><a id="marker-1008338"></a> function expects that its argument is a symbol. It retrieves the function object stored in the function slot of the symbol you pass. To use <code>pp</code> to display the source code for a function object, store the function object in an unused global. </p>
<p>
<a id="pgfId-1008339"></a>In SKILL++</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008340"></a>G4 = funobj( 0x1e3628 )<br />pp( G4 )</pre>

<p>
<a id="pgfId-1008341"></a>In SKILL</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008342"></a>putd( &#39;G4 ) = funobj( 0x1e3628 )<br />pp( G4 )</pre>

<p>
<a id="pgfId-1008343"></a>The <code>pp</code> function pretty-prints the function object stored in the function slot of the symbol. The <code>pp</code> function uses the global symbol to name the function object. This is only seriously misleading if the function object is recursive.</p>

<h3>
<a id="pgfId-1008344"></a>Pretty-Printing Package Functions</h3>

<p>
<a id="pgfId-1008345"></a>Use the <code>pp</code> function as explained above to pretty-print package functions. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008346"></a>MathPackage = let( ()<br />    procedure( add( x y ) x+y )<br />    procedure( mult( x y ) x*y )<br />    list( nil &#39;add add &#39;mult mult )<br />    )<br />    =&gt; (nil add funobj:0x1c9c48 nult funobj:0x1c9c58)<br />
ILS-1&gt; Q = MathPackage-&gt;add
funobj:0x1c9c48
ILS-1&gt; pp( Q )
procedure( Q(x y)
&#160;&#160;  (x + y)<br />    )</pre>
<h3>
<a id="pgfId-1008347"></a>Inspecting Environments</h3>

<p>
<a id="pgfId-1008349"></a>A significant <a id="marker-1008348"></a>SKILL++ application is likely to include many function objects, each with its own separate environment. While debugging, you may need to interactively examine or set a local variable in an environment other than the active <a id="marker-1008350"></a>environment.</p>
<p>
<a id="pgfId-1008351"></a>You can</p>
<ul><li>
<a id="pgfId-1010313"></a>Retrieve the active environment </li><li>
<a id="pgfId-1010314"></a>Inspect an environment with the <code>-&gt;</code> operator </li><li>
<a id="pgfId-1010315"></a>Retrieve the environment of a function object </li></ul>



<h3>
<a id="pgfId-1008355"></a>Retrieving the Active Environment</h3>

<p>
<a id="pgfId-1008358"></a>The <code>theEnvironment</code><a id="marker-1008356"></a> function returns the enclosing lexical environment when you call it from within SKILL++ code. <a id="marker-1008357"></a></p>

<h4>
<a id="pgfId-1008359"></a>Example 1</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008360"></a>Z = let( (( x 3 )) <br />    theEnvironment() <br />    ) ; let<br />    =&gt; envobj:0x1e0060</pre>

<p>
<a id="pgfId-1008361"></a>This example returns the environment that the <code>let</code> expression establishes. The value of <code>Z</code> is an environment in which <code>x</code> is bound to <code>3</code>. Each time you execute the above expression, it returns a different environment object.</p>

<h4>
<a id="pgfId-1008362"></a>Example 2</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008363"></a>W = let( (( r 3 ) ( y 4 ))<br />    let( (( z 5 ) ( v 6 ))<br />        theEnvironment()<br />        ) <br />    ) </pre>

<p>
<a id="pgfId-1008364"></a>This example returns the environment that the nested <code>let</code> expressions establish. </p>

<h3>
<a id="pgfId-1008365"></a>Testing Variables in an Environment (boundp)</h3>

<p>
<a id="pgfId-1008367"></a>Use the <code>boundp</code><a id="marker-1008366"></a> function to determine whether a variable is bound in an environment. The optional second argument should be a SKILL++ environment.<a id="marker-1008368"></a></p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008369"></a>boundp( &#39;b W ) =&gt; nil<br />boundp( &#39;r W ) =&gt; t</pre>
<h3>
<a id="pgfId-1008371"></a>Using the <a id="marker-1008370"></a>-&gt; Operator with Environments</h3>

<p>
<a id="pgfId-1008373"></a>You can use the <code>-&gt;</code> operator against an environment to read and write variables bound in the environment.<a id="marker-1008372"></a></p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008374"></a>W-&gt;z =&gt; 5<br />W-&gt;v = 100</pre>

<p>
<a id="pgfId-1008375"></a>Alternatively, you can use the <code>symeval</code> function to retrieve the value of a variable relative to an environment.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008376"></a>symeval( &#39;r W ) =&gt; 3</pre>

<p>
<a id="pgfId-1008377"></a>Alternatively, you can use the <code>set</code> function to set the value of a variable in an environment.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008378"></a>set( &#39;r 200 W ) =&gt; 200</pre>
<h3>
<a id="pgfId-1008379"></a>Using the -&gt;?? Operator with Environments</h3>

<p>
<a id="pgfId-1008382"></a>Use the <a id="marker-1008380"></a><code>-&gt;??</code> operator to dump out the environment as a list of association lists with one association list for each environment frame. <a id="marker-1008381"></a></p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008383"></a>W-&gt;?? =&gt; ( ((z 5) (v 6)) ((r 3) (y 4)) )</pre>
<h3>
<a id="pgfId-1008384"></a>Evaluating an Expression in an Environment (eval)</h3>

<p>
<a id="pgfId-1008386"></a>Use the <code>eval</code><a id="marker-1008385"></a> function to evaluate an expression in a given lexical environment.<a id="marker-1008387"></a></p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008388"></a>eval( &#39;( z+v ) W ) =&gt; 11<br />eval( &#39;( z = 100 ) W ) =&gt; 100<br />eval( &#39;( z+v ) W ) =&gt; 106</pre>
<h3>
<a id="pgfId-1008394"></a>Examining Closures</h3>

<p>
<a id="pgfId-1008395"></a>As function objects, closures have both source code and data. For example, consider the following <a id="marker-1008396"></a>closure generated when the <code>makeAdder</code> function is called.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008397"></a>procedure( makeAdder( delta )<br />    lambda( ( x ) x + delta )<br />    ) <br />=&gt; makeAdder<br />add5 = makeAdder( 5 )<br />=&gt; funobj:0x1fe668</pre>
<h4>
<a id="pgfId-1008398"></a>Examining the Source Code</h4>

<p>
<a id="pgfId-1008400"></a>Use the <code>pp</code><a id="marker-1008399"></a> function as explained above to examine the source code for the closure. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008401"></a>ILS-1&gt; pp( add5 )<br />procedure( add5(x)<br />    (x + delta)<br />)<br />nil</pre>
<h4>
<a id="pgfId-1008402"></a>Examining the Environment</h4>

<p>
<a id="pgfId-1008406"></a>Install the SKILL Debugger and use the <code>theEnvironment</code> function to retrieve the environment for the function object. Use the <code>-&gt;??</code> operator to examine the environment.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008407"></a>theEnvironment( funobj( 0x1fe668 ) )-&gt;??<br />=&gt; (((delta 5)))</pre>

<p>
<a id="pgfId-1008408"></a>See the <code>makeStack</code> example in <a href="chap14.html#20169">&#8220;Implementing the makeStack Function&#8221;</a></p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008409"></a>S = makeStack( &#39;( 1 2 3 )) =&gt; funobj:0x1e3758<br />E = theEnvironment( S ) =&gt; envobj:0x1e00b4<br />E-&gt;push =&gt; funobj:0x1e3738<br />E-&gt;initialContents =&gt; (1 2 3)</pre>
<h3>
<a id="pgfId-1008410"></a>General SKILL Debugger Commands</h3>
<h4>
<a id="pgfId-1008411"></a>Tracing (tracef)</h4>

<p>
<a id="pgfId-1008413"></a>You can only use the <code>tracef</code><a id="marker-1008412"></a> function to trace SKILL functions or SKILL++ functions defined in the top-level SKILL++ environment.<a id="marker-1008414"></a></p>

<h4>
<a id="pgfId-1008415"></a>Setting Breakpoints</h4>

<p>
<a id="pgfId-1008416"></a>You can only set breakpoints at SKILL functions or SKILL++ functions defined in the top-level SKILL++ environment. </p>

<h4>
<a id="pgfId-1008417"></a>Calling the break Function</h4>

<p>
<a id="pgfId-1008419"></a>You can insert a call to the <code>break</code><a id="marker-1008418"></a> function but that requires redefining the function that calls the <code>break</code> functions. If called from SKILL++, the enclosing lexical environment is the active environment during the debugger session.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008420"></a>ILS-&lt;2&gt; MathPackage = let( ()<br />    procedure( add( x y ) break() x+y )<br />    procedure( mult( x y ) x*y )<br />    list( nil &#39;add add &#39;mult mult )<br />    )<br />(nil add funobj:0x1c9ca8 mult funobj:0x1c9cb8)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008421"></a>ILS-&lt;2&gt; MathPackage-&gt;add( 3 4 )<br />&lt;&lt;&lt; Break &gt;&gt;&gt; on explicit &#39;break&#39; request<br />SKILL Debugger: type &#39;help debug&#39; for a list of commands or debugQuit to leave.<br />ILS-&lt;3&gt; theEnvironment()-&gt;??<br />(((x 3) <br />        (y 4)<br />    ) <br />    ((add funobj:0x1c9ca8) <br />        (mult funobj:0x1c9cb8)<br />    )<br />)<br />ILS-&lt;3&gt;</pre>
<h4>
<a id="pgfId-1008422"></a>Examining the Stack (stacktrace)</h4>

<p>
<a id="pgfId-1008423"></a>During the execution of both SKILL and SKILL++ function calls, use the <code>stacktrace</code><a id="marker-1008424"></a> function to examine the SKILL stack. The stack will probably contain several function object and environment object references. You can use the techniques discussed above to display source code for a function object and to examine an environment. </p>
<p>
<a id="pgfId-1008425"></a>For example, at the break point in the previous example, the <code>break</code> function passes the active environment to the break handler.</p>
<p>
<a id="pgfId-1008201"></a></p>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap14.html" id="prev" title="Using SKILL++">Using SKILL++</a></em></b><b><em><a href="chap16.html" id="nex" title="SKILL++ Object System">SKILL++ Object System</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
 

 <div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160;⠀ </center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div> 

</body></html>