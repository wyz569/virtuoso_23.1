
<html><head><title>Using SKILL++</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="parula" />
<meta name="CreateDate" content="2023-08-23" />
<meta name="CreateTime" content="1692797217" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the SKILL language to new users and helps them understand advanced topics, encourages sound SKILL programming methods, and introduces the SKILL++ language" />
<meta name="DocTitle" content="Cadence SKILL Language User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="Using SKILL++" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-4.0.0" />
<meta name="Keyword" content="sklanguser" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-08-23" />
<meta name="ModifiedTime" content="1692797217" />
<meta name="NextFile" content="chap15.html" />
<meta name="Group" content="SKILL Language" />
<meta name="Platform" content="Cadence Shared Tools" />
<meta name="PrevFile" content="chap13.html" />
<meta name="c_product" content="Virtuoso Layout Suite,Virtuoso Schematic Editor,Virtuoso Analog Design Environment" />
<meta name="Product" content="SKILL" />
<meta name="ProductFamily" content="SKILL" />
<meta name="ProductVersion" content="IC23.1" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Cadence SKILL Language User Guide -- Using SKILL++" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="0" />
<meta name="Version" content="IC23.1" />
<meta name="SpaceKey" content="sklanguserIC231" />
<meta name="webflare-version" content="2.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" />


  <script>/*<![CDATA[*/
 document.addEventListener("DOMContentLoaded", function(event) {  document.querySelectorAll("img").forEach((img, index) => {
if (img.hasAttribute("usemap")){return;}else{img.classList.add("cursorclass");} img.addEventListener("click", (e) => {if(img.hasAttribute("usemap")){            img.setAttribute("style","cursor:none;");return;};document.querySelector("#cad_image_modal").classList.add("opac");document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0;margin: auto;max-height:95%;"  src="${e.target.src}">`;});});});
/*]]>*/</script> 




 <style>/*<![CDATA[*/
.cursorclass{cursor:pointer;}#cad_image_modal{position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;}#cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;}#cad_image_modal span{position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;}
/*]]>*/</style> 
</head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="sklanguserTOC.html">Contents</a></li><li><a class="prev" href="chap13.html" title="About SKILL++ and SKILL">About SKILL++ and SKILL</a></li><li style="float: right;"><a class="viewPrint" href="sklanguser.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap15.html" title="Using SKILL and SKILL++ Together">Using SKILL and SKILL++ Togeth ...</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Cadence SKILL Language User Guide<br />Product Version IC23.1, September 2023</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<h1>14
<a id="pgfId-1005655"></a></h1>
<h1>
<a id="pgfId-1008199"></a><hr />
<a id="14849"></a>Using SKILL++<hr />
</h1>

<p>
<a id="pgfId-1011505"></a>This chapter deals with the pragmatics of writing programs in the Cadence&#174; SKILL++ language.</p>
<p>
<a id="pgfId-1011509"></a><a href="chap13.html#35957">About SKILL++ and SKILL</a> provides an overview of the differences between the Cadence SKILL language and SKILL++.</p>
<p>
<a id="pgfId-1011513"></a><a href="chap15.html#18182">Using SKILL and SKILL++ Together</a> focuses on the key areas in which SKILL++ semantics differ from SKILL semantics.</p>
<p>
<a id="pgfId-1011517"></a><a href="chap16.html#18332">SKILL++ Object System</a> describes a system that allows for object-oriented interfaces based on classes and generic functions composed of methods specialized on those classes.</p>

<h4><em>
<a id="pgfId-1008791"></a>Related Topics</em></h4>

<p>
<a id="pgfId-1008846"></a><a href="chap14.html#29805">Declaring Local Variables in SKILL++</a>  </p>
<p>
<a id="pgfId-1008856"></a><a href="chap14.html#26339">Sequencing and Iteration</a>  </p>
<p>
<a id="pgfId-1008864"></a><a href="chap14.html#42461">Software Engineering with SKILL++</a>  </p>
<p>
<a id="pgfId-1008866"></a><a href="chap14.html#15893">SKILL++ Packages</a>  </p>

<h2>
<a id="pgfId-1008217"></a><a id="29805"></a>Declaring Local Variables in SKILL++</h2>

<p>
<a id="pgfId-1008219"></a>SKILL++ provides three binding constructs to <a id="marker-1008218"></a>declare local variables together with initialization expressions. The syntax for <code>let, letseq</code> and <code>letrec </code>is identical but they differ in the order of evaluation of the initialization expressions and in the scope of the local variables.</p>

<h4>
<a id="pgfId-1008220"></a>Syntax Template for let, letseq and letrec</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008221"></a>let( <br />    ( ( s_var1 g_initExp1 ) ( s_var2 g_initExp2 )&#8230; )<br />    g_bodyExp1 <br />    g_bodyExp2 <br />    &#8230;<br />    )</pre>
<h3>
<a id="pgfId-1008222"></a>Using let</h3>

<p>
<a id="pgfId-1008225"></a>Each local variable <a id="marker-1008223"></a>has the body of the <code>let</code> expression as its lexical scope. The order of evaluation of the initialization expressions and the binding sequence is unspecified. You should avoid cross-references between variables in a <code>let</code> expression.</p>

<div class="webflare-information-macro webflare-macro-warning">
<a id="pgfId-1008226"></a>
The initialization expression bound to one local variable should not refer to any of the other local variables. </div>
<h4>
<a id="pgfId-1008227"></a>Example 1</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008228"></a>let( ( ( x 2 ) ( y 3 ) )<br />    x*y <br />    ) =&gt; 6</pre>
<h4>
<a id="pgfId-1008229"></a>Example 2</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008230"></a>let( ( ( x 2 ) ( y 3 ) )<br />    let( (( z 4 ))<br />        x + y + z <br />        ) ; let<br />    ) ; let<br />=&gt; 9</pre>
<h4>
<a id="pgfId-1008234"></a><a id="68232"></a>Example 3</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008235"></a>let( ( ( x 2 ) ( y 3 ) )<br />    let( (( x 7 ) ( z x+y ) )<br />        z*x<br />        )<br />    ) =&gt; 35</pre>

<p>
<a id="pgfId-1008236"></a>Because the initialization expressions are outside of the scope of the <code>let</code>, <code>z</code> is bound to <code>2+3</code>, instead of <code>7+3</code>.</p>

<h4>
<a id="pgfId-1008239"></a><a id="Example 4 Using let"></a><a id="52213"></a>Example 4</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008240"></a>let( ( ( x 2 ) ( y 3 ) )<br />    let( (( x 7 ) ( foo lambda( ( z ) x + y + z ) ) )<br />        foo( 5 )<br />        ) <br />    ) <br />=&gt; 10</pre>

<p>
<a id="pgfId-1008241"></a>This example shows that the initialization expressions are also outside the scope of the <code>let</code>. Specifically, the occurrence of <code>x</code> in the body of <code>foo</code> is in the scope of the outer <code>let</code>.</p>

<h3>
<a id="pgfId-1008242"></a>Using letseq</h3>

<p>
<a id="pgfId-1008244"></a>Use <code>letseq</code><a id="marker-1008243"></a> to control the order of evaluation of the initialization expressions and the binding sequence of the local variables. Evaluation proceeds from left to right. The scope of each variable includes the remaining initialization expressions and the body of <code>letseq</code>. It is equivalent to a corresponding sequence of nested <code>let</code> expressions.</p>

<h4>
<a id="pgfId-1008246"></a>Example 1</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008247"></a>letseq( ( ( x 1 ) ( y x+1 ) ) <br />    y <br />    ) <br />=&gt; 2 </pre>

<p>
<a id="pgfId-1008248"></a>The code above is a more convenient equivalent to the code below in <br />which you control the sequence explicitly by the nesting.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008249"></a>let( ( ( x 1 ) )<br />    let( ( ( y x+1 ) )<br />        y<br />        )<br />    )</pre>
<h4>
<a id="pgfId-1008251"></a><a id="18517"></a>Example 2 </h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011533"></a>let( ( ( x 2 ) ( y 3 ) )<br />    letseq( (( x 7 ) ( z x+y ) )<br />        z*x<br />        )<br />    ) =&gt; 70</pre>

<p>
<a id="pgfId-1011537"></a>This example is identical to <a href="chap14.html#68232">&#8220;Example 3&#8221;</a> except that the inner <code>let</code> is replaced with <code>letseq</code>. </p>

<h4>
<a id="pgfId-1008257"></a>Example 3 </h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008258"></a>let( ( ( x 2 ) ( y 3 ) )<br />    letseq( (( x 7 ) ( foo lambda( ( z ) x + y + z ) ) )<br />        foo( 5 )<br />        ) <br />    ) <br />=&gt; 15</pre>

<p>
<a id="pgfId-1008261"></a>This example is identical to <a href="chap14.html#52213">&#8220;Example 4&#8221;</a> except that the inner <code>let</code> is replaced with <code>letseq</code>. </p>

<h3>
<a id="pgfId-1008263"></a>Using letrec</h3>

<p>
<a id="pgfId-1008266"></a>Unlike <code>let</code> and <code>letseq</code>, each variable&#8217;s scope is the<a id="marker-1008264"></a> entire <code>letrec</code> expression. In particular, each variable&#8217;s scope includes all of the initialization expressions. Each initialization expression can refer to the other local variables with the following restriction: each initialization expression must be executable without accessing the other variables. This restriction is met when each initialization expression is a <code>lambda</code> expression. Therefore, use <code>letrec</code> to declare mutually recursive local functions.</p>

<h4>
<a id="pgfId-1008267"></a>Example 1</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008268"></a>letrec( <br />    ( ;;; variable list<br />        ( f <br />            lambda( ( n ) <br />                if( n &gt; 0 then n*f(n-1) else 1<br />                      ) ; if<br />                ) ; lambda<br />            ) ; f<br />        ) ; variable list<br />    f( 5 )<br />    ) ; letrec <br />=&gt; 120</pre>

<p>
<a id="pgfId-1008269"></a>This example declares a single recursive local function. The <code>f</code> function computes the factorial of its argument. The <code>letrec</code> expression returns the factorial of 5.</p>

<h4>
<a id="pgfId-1008271"></a><a id="13498"></a>Example 2</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008272"></a>procedure( trParity( x )<br />    letrec(<br />      ( <br />          ( isEven <br />              lambda( (x) <br />                  x == 0 || isOdd( x-1 )<br />                  ) ; lambda<br />              ) ; isEven <br />          ( isOdd <br />              lambda( (x) <br />                  x &gt; 0 &amp;&amp; isEven(x-1)) ; lambda <br />              ) ; isOdd <br />          ) ; <br />      if( isEven( x ) then &#39;even else &#39;odd )<br />      ) ; letrec<br />    ) ; procedure</pre>

<p>
<a id="pgfId-1008273"></a>The <code>trParity</code> function returns the symbol <code>even,</code> if its argument is <code>even</code>, and returns the symbol <code>odd</code> otherwise. <code>trParity</code> relies on two mutually recursive local functions <code>isEven</code> and <code>isOdd</code>.</p>

<h3>
<a id="pgfId-1008274"></a>Using procedure to Declare Local Functions</h3>

<p>
<a id="pgfId-1008276"></a>As an alternative t<a id="marker-1008275"></a>o using <code>letrec</code> to define local functions, you can use the <code>procedure</code> syntax.</p>

<h4>
<a id="pgfId-1008277"></a>Example 1</h4>

<p>
<a id="pgfId-1008278"></a>This example uses the <code>procedure</code> construct to declare a local function instead of using <code>letrec</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008279"></a>procedure( trParity( x )<br />    procedure( isEven(x) <br />        x == 0 || isOdd( x-1 )<br />        ) <br />    procedure( isOdd(x) <br />        x &gt; 0 &amp;&amp; isEven(x-1) <br />        ) <br />    if( isEven( x ) then &#39;even else &#39;odd )<br />    ) ; procedure</pre>
<h4>
<a id="pgfId-1008281"></a><a id="74701"></a>Example 2</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008282"></a>procedure( makeGauge( tolerance )<br />    let( ( ( iteration 0 ) ( previous 0.0 ) test )<br />        procedure( performTest( value )<br />            ++iteration<br />            test = ( abs( value - previous ) &lt;= tolerance )<br />            previous = value<br />            when( test list( iteration value ))<br />            ) ; procedure<br />        performTest<br />        ) ; let<br />    ) ; procedure<br />
G = makeGauge( .1 )
=&gt; funobj:0x322b28
G(2) =&gt; nil&#160;&#160;                ;; first iteration<br />G(3)=&gt; nil                   ;; second<br />G(3.01) = &gt;                  ;; third iteration<br />      ( 3 3.01 )</pre>

<p>
<a id="pgfId-1008284"></a>The <code>makeGauge</code><a id="Example 2 Using procedure"></a> function declares the local <code>performTest</code> function and returns it. This function object is the gauge. Passing a value to the gauge compares it to the previous value passed then updates the previous value. The gauge returns a list of the iteration count and the value, or <code>nil</code>. The function object has access to the local variables <code>iteration</code>, <code>previous</code>, and <code>test,</code> as well as access to the argument <code>tolerance</code>. Notice that using a gauge object can simplify your code by isolating variables used only for the tracking of successive values.</p>
<p>
<a id="pgfId-1008287"></a>For another <code>makeGauge</code> example, see <a href="chap14.html#59369">&#8220;Example 4: Using a Gauge When Computing the Area Under a Curve&#8221;</a>. </p>

<h4>
<a id="pgfId-1008290"></a><a id="69291"></a>Example 3</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008291"></a>procedure( trPartition( nList )<br />    procedure( loop( numbers nonneg neg )<br />        cond(<br />            ( !numbers list( nonneg neg ))<br />            ( car( numbers ) &gt; 0 <br />                loop( <br />                    cdr( numbers ) <br />                    cons( car( numbers ) nonneg ) ; ppush on nonneg<br />                    neg<br />                    ) ; loop<br />                )<br />            ( car( numbers ) &lt; 0<br />                loop( <br />                    cdr( numbers ) <br />                    nonneg<br />                    cons( car( numbers ) neg ) ; ppush on neg<br />                    ) ; loop <br />                )<br />            ) ; cond<br />        ) ; procedure<br />    loop( nList nil nil )<br />    ) ; procedure<br />
trPartition( &#39;( 3 -2 1 6 5 )) =&gt; ((5 6 1 3) (-2))</pre>

<p>
<a id="pgfId-1008293"></a>In this <a id="Example 3 Using procedure"></a>example, the <code>trPartition</code> function separates a list of integers into a list of non-negative elements and negative elements. The local <code>loop</code> function is recursive.</p>

<h2>
<a id="pgfId-1008294"></a><a id="26339"></a>Sequencing and Iteration</h2>

<p>
<a id="pgfId-1008296"></a>The following sequencing and <a id="marker-1008295"></a>iteration functions are provided in <a id="marker-1008297"></a>SKILL++:</p>
<ul><li>
<a id="pgfId-1008298"></a>Use <code>begin</code> to construct a single expression from one or more expressions.</li><li>
<a id="pgfId-1008299"></a>Use <code>do</code> to iteratively execute one or more expressions. </li><li>
<a id="pgfId-1008300"></a>Use a <code>named let</code> construct to extend the <code>let</code> construct with a recursive iteration capability.</li></ul>



<h3>
<a id="pgfId-1008301"></a>Using begin</h3>

<p>
<a id="pgfId-1008304"></a>Use <code>begin</code><a id="marker-1008302"></a> to construct a single expression from one or more expressions. The expressions are evaluated from left to right. The return value of the <code>begin</code> expression is the return value of the last expression in the sequence.</p>
<p>
<a id="pgfId-1008305"></a>The <code>begin</code> function is equivalent to the <code>progn</code> function. The <code>progn</code> function is used to implement the { } syntax. Use the <code>begin</code> function to write SKILL++-compliant code. </p>

<h4>
<a id="pgfId-1008306"></a>Example 1</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008307"></a>ILS-1&gt; begin(<br />    x = 0<br />    printf( &quot;Value of x: %d\n&quot; ++x ) <br />    printf( &quot;Value of x: %d\n&quot; ++x )<br />    x<br />    ) ; begin<br />Value of x: 1<br />Value of x: 2<br />2</pre>

<p>
<a id="pgfId-1008308"></a>This example shows a transcript using the <code>begin</code> function.</p>

<h4>
<a id="pgfId-1008309"></a>Example 2</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008310"></a>ILS-1&gt; { x = 0<br />    printf( &quot;Value of x: %d\n&quot; ++x ) <br />    printf( &quot;Value of x: %d\n&quot; ++x )<br />    x }<br />Value of x: 1<br />Value of x: 2<br />2</pre>

<p>
<a id="pgfId-1008311"></a>This example uses the { } braces to group the same expressions.</p>

<h3>
<a id="pgfId-1008312"></a>Using do</h3>

<p>
<a id="pgfId-1008315"></a>Use <code>do</code><a id="marker-1008313"></a> to iteratively execute one or more expressions. The <code>do</code> expression allows multiple loop variables with arbitrary variable initializations and step expressions. You can specify</p>
<ul><li>
<a id="pgfId-1008316"></a>One or more loop variables, including an initialization expression and a step expression for each variable. </li><li>
<a id="pgfId-1008317"></a>A termination condition that is evaluated before the body expressions are executed.</li><li>
<a id="pgfId-1008318"></a>One or more termination expressions that are evaluated upon termination to determine a return value.</li></ul>



<h4>
<a id="pgfId-1008319"></a>Syntax Template for do Expressions</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008320"></a>do( ( <br />( s_var1 g_initExp1 [g_stepExp1] )<br />( s_var2 g_initExp2 [g_stepExp2] )&#8230;)<br />    ( g_terminationExp g_terminationExp1 &#8230;)<br />    g_loopExp1 g_loopExp2 &#8230;)<br />=&gt; g_value</pre>

<p>
<a id="pgfId-1008321"></a>A <code>do</code> expression evaluates in two phases: the initialization phase and the iteration phase.</p>
<p>
<a id="pgfId-1010583"></a>The initialization expressions <code>g_initExp1</code>, <code>g_initExp2</code>, &#8230; are evaluated in an unspecified order and the results bound to the local variables <code>var1</code>, <code>var2</code>, &#8230; </p>
<p>
<a id="pgfId-1010586"></a>The iteration phase is a sequence of steps going around the loop zero or more times with the exit determined by the termination condition.</p>
<ol><li>
<a id="pgfId-1008325"></a>Each iteration begins by evaluating the termination condition. </li><li>
<a id="pgfId-1008326"></a>If the termination condition evaluates to a non-nil value, the <code>do</code> expression exits with a return value computed as follows:</li><li>
<a id="pgfId-1008327"></a>The termination expressions <code>terminationExp1</code>, <code>terminationEx</code>p2, &#8230; are evaluated in order. The value of the last termination condition is returned as the value of the <code>do</code> expression. </li><li>
<a id="pgfId-1008328"></a>Otherwise, the <code>do</code> expression continues with the next iteration as follows.</li><li>
<a id="pgfId-1008329"></a>The loop body expressions <code>g_loopExp1, g_loopExp2, &#8230; </code>are evaluated in order.</li><li>
<a id="pgfId-1008330"></a>The step expressions <code>g_stepExp1, g_stepExp2, &#8230;</code>, if given, are evaluated in an unspecified order.</li><li>
<a id="pgfId-1008331"></a>The local variables <code>var1, var2, &#8230;</code> are bound to the above results. Reiterate from step one.</li></ol>







<h4>
<a id="pgfId-1008332"></a>Example 1</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008333"></a>procedure( sumList( L )<br />    do(<br />        (<br />            ( tail L cdr( tail ))<br />            ( sum 0 sum + car( tail ))<br />        )<br />        ( !tail sum )<br />        )<br />    ) ; procedure<br />
sumList( nil ) =&gt; 0
sumList( &#39;( 1 2 3 4 5 6 7 )) =&gt; 28</pre>
<h4>
<a id="pgfId-1008334"></a>Example 2</h4>

<p>
<a id="pgfId-1008335"></a>By definition, the sum of the integers 1, &#8230;, N is the Nth triangular number. The following example finds the first triangular number greater than a given limit.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008336"></a>procedure( trTriangularNumber( limit )<br />    do(<br />        (                     ;;; start loop variables<br />            ( i 0 i+1 )<br />            ( sum 0 )        ;;; no update expression<br />                             ;;; same as ( sum 0 sum )<br />        )                    ;;; end loop variables<br />        ( sum &gt; limit        ;;; test<br />            sum              ;;; return result<br />            ) <br />        sum = sum+i ;;; body<br />        ) ; do<br />    ) ; procedure<br />
trTriangularNumber( 4 ) =&gt; 6
trTriangularNumber( 5 ) =&gt; 6
trTriangularNumber( 6 ) =&gt; 10</pre>
<h4>
<a id="pgfId-1008337"></a>Example 3</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008338"></a>procedure( approximateArea( dx fun lower upper )      <br />    do( <br />      ( ; loop variables<br />          ( sum <br />              0.0       ;;; initial value<br />              sum+fun(x)   ;; update<br />              )       <br />          ( x <br />              lower  ;;; initial value<br />              x+dx ;;; update expression<br />              )<br />          ) ; end loop vars<br />      ( x &gt;= upper ;;; exit test<br />          dx*sum ;;; return value<br />          )<br />      ;;; no loop expressions<br />      ;;; all work is in the update expression for sum<br />      ) ; do<br />    ) ; procedure<br />
approximateArea( .001 lambda( ( x ) 1 ) 0.0 1.0 ) =&gt; 1 
approximateArea( .001 lambda( ( x ) x ) 0.0 1.0 ) =&gt; .4995</pre>

<p>
<a id="pgfId-1008339"></a>The function <code>approximateArea</code> computes an approximation to the area under the graph of the <code>fun</code> function over the interval from <code>lower</code> to <code>upper</code>. It sums the values <code>fun(x), fun(x+dx), fun(x+dx+dx) &#8230;</code></p>

<h4>
<a id="pgfId-1008342"></a><a id="59369"></a>Example 4: Using a <a id="Example 4 Using do"></a>Gauge When Computing the Area Under a Curve</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008343"></a>procedure( makeGauge( tolerance )<br />    let( ( ( iteration 0 ) ( previous 0.0 ) test )<br />        lambda( ( value )<br />            ++iteration<br />            test = ( abs( value - previous ) &lt;= tolerance )<br />            previous = value<br />            when( test list( iteration value ))<br />            ) ; lambda<br />        ) ; let<br />    ) ; procedure<br />
procedure( computeArea( fun lower upper tolerance )
&#160;&#160;  let( ((gauge makeGauge( tolerance )) result ) <br />        do(<br />            ( ; loop variables <br />                (<br />                    dx <br />                    1.0*(upper-lower)/2 ;;; initial value<br />                    dx/2               ;;; update expression<br />                    ) <br />                ) ; end loop variables      <br />            ( result = <br />                gauge( approximateArea( dx fun lower upper ))<br />                result<br />                )<br />            nil ;;; empty body<br />            ) ; do<br />        ) ; let<br />    ) ; procedure<br />
computeArea( lambda( ( x ) 1 ) 0 1 .00001 ) =&gt; ( 2 1.0 )
computeArea( lambda( ( x ) x ) 0 1 .00001 ) =&gt; ( 16 0.4999924)
pi = 3.1415
computeArea( sin 0 pi/2 .00001 ) =&gt;(18 0.9999507)</pre>

<p>
<a id="pgfId-1008344"></a>The <code>computeArea</code> function invokes <code>approximateArea</code> iteratively until two successive results fall within the given tolerance. The <code>dx</code> loop variable is initialized to <code>1.0*(upper-lower)/2</code> and updated to <code>dx/2</code>. This example uses a gauge to hide the details of comparing successive results. The source for the <code>makeGauge</code> function is replicated for your convenience. See <a href="chap14.html#74701">Example 2</a> in the &quot;Using procedure to Declare Local Functions&quot; section for a discussion of <code>makeGauge</code> and gauges in general.</p>

<h3>
<a id="pgfId-1008348"></a>Using a Named let</h3>

<p>
<a id="pgfId-1008350"></a>The <code>named</code><a id="marker-1008349"></a> <code>let</code> construct extends the <code>let</code> construct with a recursive iteration capability. Besides the name you provide in front of the list of the local variables, the <code>named let</code> has the same syntax and semantics as the ordinary <code>let</code> except you can recursively invoke the named <code>let</code> expression from within its own body, passing new values for the local variables.</p>

<h4>
<a id="pgfId-1008351"></a>Syntax Template for Named let</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008352"></a>let( <br />    s_name <br />    ( ( s_var1 g_initExp1 ) ( s_var2 g_initExp2 )&#8230; )<br />    g_bodyExp1 <br />    g_bodyExp2 <br />    &#8230;<br />    )</pre>
<h4>
<a id="pgfId-1008353"></a>Example 1</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008354"></a>let( <br />    factorial <br />    (( n 5 ))<br />    if( n &gt; 1 <br />        then <br />            factorial( n-1)*n <br />        else <br />            1 <br />        )<br />    ) ; let =&gt; 120</pre>

<p>
<a id="pgfId-1008355"></a>This example computes the factorial of 5 with a named <code>let</code> expression. Compare the example above with the following</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008356"></a>let( (( n 5 ))<br />    procedure( factorial( n )<br />        if( n&gt; 1 <br />            then <br />                n*factorial( n-1)<br />            else <br />                1 <br />            ) ; if<br />        ) ; procedure<br />    factorial( n )<br />    ) ; let =&gt; 120 </pre>

<p>
<a id="pgfId-1008357"></a>and with the following</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008358"></a>letrec( <br />    ( ;;; variable list<br />        ( n 5 )<br />        ( factorial<br />            lambda( ( n ) <br />                if( n &gt; 0 then n*factorial(n-1) else 1 ) ; if<br />                ) ; lambda<br />            ) ; f<br />        ) ; variable list<br />    factorial( n )<br />    ) ; letrec =&gt; 120</pre>
<h4>
<a id="pgfId-1008359"></a>Example 2</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008360"></a>let( loop         ;;; name for the let<br />    (             ;;; start let variables<br />        ( numbers &#39;( 3 -2 1 6 -5 ))<br />        ( nonneg nil )<br />        ( neg nil )<br />        )       ;;; end of let variables<br />    cond(<br />        ( !numbers ;;; loop termination test and return result<br />              list( nonneg neg )<br />              )<br />        ( car( numbers ) &gt; 0 ;;; found a non-negative number <br />            loop( ;; recurse<br />                cdr( numbers )<br />                cons( car( numbers ) nonneg )<br />                neg<br />                ) ; loop <br />            )<br />        ( car( numbers ) &lt; 0 ;;; found a negative number<br />            loop( ;; recurse<br />                cdr( numbers )<br />                nonneg<br />                cons( car( numbers ) neg )<br />                ) ; loop <br />            )<br />        ) ; cond<br />    ) ;;; loop let<br />=&gt; ((613) (-5 -2))</pre>

<p>
<a id="pgfId-1008361"></a>This example separates an initial list of integers into a list of the negative integers and a list of the non-negative integers. Compare this example with the <code>trPartition</code> function in <a href="chap14.html#69291">&#8220;Example 3&#8221;</a> which explicitly relies on a local recursive function.</p>

<h2>
<a id="pgfId-1008365"></a><a id="42461"></a>Software Engineering with SKILL++</h2>

<p>
<a id="pgfId-1008366"></a>SKILL++ supports several modern software engineering methodologies, such as </p>
<ul><li>
<a id="pgfId-1008367"></a>Procedural packages</li><li>
<a id="pgfId-1009315"></a>Modules</li><li>
<a id="pgfId-1009318"></a>Object-oriented programming with classes (see <a href="chap16.html#18332">SKILL++ Object System</a>)</li></ul>


<p>
<a id="pgfId-1009322"></a>SKILL++ also facilitates information hiding. <code>Information hiding</code><a id="marker-1009320"></a> refers to using private functions and private data which are not accessible to other parts of your application. Information hiding promotes reusability and robustness because your implementation is easier to change with no adverse effect on the clients of the module. <a id="marker-1009321"></a><a id="marker-1009323"></a></p>

<h2>
<a id="pgfId-1008377"></a><a id="15893"></a>SKILL++ Packages</h2>

<p>
<a id="pgfId-1008379"></a>A <code>package</code><a id="marker-1008378"></a> is a collection of functions and data. Functions within a package can share private data and private functions that are not accessible outside the package. Packages are a hallmark of modern software engineering. </p>
<p>
<a id="pgfId-1008381"></a><a id="marker-1008380"></a>SKILL++ facilitates two approaches to packages.</p>
<ul><li>
<a id="pgfId-1008382"></a>You can explicitly represent the package as an collection of function objects and data. Clients of the package use the arrow (<code>-&gt;</code>) operator to retrieve the package functions. Different packages can have functions with the same name.</li><li>
<a id="pgfId-1008383"></a>You might want to reimplement a collection of SKILL functions as a SKILL++ package. Informal SKILL packages have no opportunity to hide private functions or data. Reimplementing a SKILL package in SKILL++ provides the opportunity. Usually, you want to do this in a way that clients do not need to change their calling syntax. In this case, you do not need to represent the collection as a data structure. Instead, the package exports some of its function objects and hides the remainder.</li></ul>


<h3>
<a id="pgfId-1008384"></a>The Stack Package</h3>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008385"></a>Stack = let( ()<br />    procedure( getContents( aStack )<br />        aStack-&gt;contents<br />        ) ; procedure<br />    procedure( setContents( aStack aList )<br />        aStack-&gt;contents = aList<br />        ) ; procedure<br />    procedure( ppush( aStack aValue )<br />        setContents( <br />            aStack <br />            cons(<br />                aValue<br />                getContents( aStack )<br />                ) ; cons<br />            )<br />        ) ; procedure<br />    procedure( ppop( aStack )<br />        letseq( (<br />              ( contents getContents( aStack ))<br />              ( v car( contents ))<br />              )<br />            setContents( aStack cdr( contents ))<br />            v<br />            ) ; letseq<br />        ) ; procedure<br />    procedure( new( initialContents )<br />        list( nil &#39;contents initialContents )<br />        ) ; procedure<br />    list( nil &#39;ppop ppop &#39;ppush ppush &#39;new new )<br />    ) ; let<br />
=&gt; ( nil 
&#160;&#160;      ppop funobj:0x1c9b38 <br />        ppush funobj:0x1c9b28<br />        new funobj:0x1c9b48 )</pre>
<h4>
<a id="pgfId-1008386"></a>Using the Stack Package</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008387"></a>S = Stack-&gt;new( &#39;( 1 2 3 4 )) =&gt; (nil contents ( 1 2 3 4 ))<br />Stack-&gt;ppop( S ) =&gt; 1<br />Stack-&gt;ppush( S 1 ) =&gt; (1 2 3 4)</pre>
<h4>
<a id="pgfId-1008388"></a>Comments</h4>

<p>
<a id="pgfId-1008389"></a>The Stack package is represented by a disembodied property list. Alternate representations such as a defstruct are possible. The only requirement is that the package data structure obey the <code>-&gt;</code> protocol.</p>
<p>
<a id="pgfId-1008390"></a>Only the <code>ppush</code>, <code>ppop</code>, and <code>new</code> function are visible to the clients of the package.</p>
<p>
<a id="pgfId-1008391"></a>The <code>ppush</code> and <code>ppop</code> functions use the <code>getContents</code> and <code>setContents</code> functions. If you choose a different representation for a stack, you only need to change the <code>new</code>, <code>getContents</code>, and <code>setContents</code> functions. The <code>getContents</code> and <code>setContents</code> functions are hidden to protect the abstract behavior of a stack. </p>

<h3>
<a id="pgfId-1008392"></a>Retrofitting a SKILL API as a SKILL++ Package</h3>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008393"></a>define( stackPush nil )<br />define( stackPop nil )<br />define( stackNew nil )<br />let( ()<br />    procedure( getContents( aStack )<br />        aStack-&gt;contents<br />        ) ; procedure<br />    procedure( setContents( aStack aList )<br />        aStack-&gt;contents = aList<br />        ) ; procedure<br />    procedure( ppush( aStack aValue )<br />        setContents( <br />          aStack <br />          cons(<br />            aValue<br />            getContents( aStack )<br />            ) ; cons<br />          )<br />        ) ; procedure<br />    procedure( ppop( aStack )<br />        letseq( (<br />            ( contents getContents( aStack ))<br />            ( v car( contents ))<br />            )<br />          setContents( aStack cdr( contents ))<br />          v<br />          ) ; letseq<br />        ) ; procedure<br />    procedure( new( initialContents )<br />        list( nil &#39;contents initialContents )<br />        ) ; procedure<br />    stackPush = ppush<br />    stackPop = ppop<br />    stackNew = new<br />nil<br />) ; let</pre>
<h4>
<a id="pgfId-1008394"></a>Using the stackNew, stackPop, and stackPush Functions</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008395"></a>S = stackNew( &#39;( 1 2 3 4 )) =&gt; (nil contents (1 2 3 4)) <br />stackPop( S ) =&gt; 1<br />stackPush( S 5 ) =&gt; (5 2 3 4)</pre>
<h4>
<a id="pgfId-1008396"></a>Comments</h4>

<p>
<a id="pgfId-1008397"></a>This example assumes <code>stackNew</code>, <code>stackPop</code>, and <code>stackPush</code> are the names of the functions to be exported from the stack package. As is customary, the package prefix <code>stack</code> informally indicates the functions that compose a package.</p>
<ul><li>
<a id="pgfId-1008398"></a>The <code>getContents</code> and <code>setContents</code> functions are local functions invisible to clients. </li><li>
<a id="pgfId-1008399"></a>Using the <code>define</code> forms for <code>stackNew</code>, <code>stackPop</code>, and <code>stackPush</code> is not strictly necessary. Using the <code>define</code> form alerts the reader to those functions which the ensuing <code>let</code> expression assigns a value to an exported API.</li></ul>


<h3>
<a id="pgfId-1008400"></a>SKILL++ Modules </h3>

<p>
<a id="pgfId-1008402"></a>You can structure a <a id="marker-1008401"></a>SKILL++ module around a creation function, which the client invokes to allocate one or more instances of the module. The client passes an instance to a procedural interface. </p>
<p>
<a id="pgfId-1008403"></a>The <code>makeStack</code> and <code>makeContainer</code> functions in the following examples are creation functions in the following sense: when you call <code>makeStack</code> it &#8220;creates&#8221; a stack instance. The stack instance is a function object whose internals can only be manipulated (outside of the debugger) by the <code>ppushStack</code> and <code>popStack</code> functions.</p>
<p>
<a id="pgfId-1008404"></a>The creation function has </p>
<ul><li>
<a id="pgfId-1008405"></a>Arguments </li><li>
<a id="pgfId-1008406"></a>Local variables </li><li>
<a id="pgfId-1008407"></a>Several local functions that can access the arguments to the creation function and can communicate between themselves through the local variables </li></ul>


<p>
<a id="pgfId-1008408"></a>The creation function returns one of the following, depending on the implementation:</p>
<ul><li>
<a id="pgfId-1008409"></a>A single local function object </li><li>
<a id="pgfId-1008410"></a>A data structure containing several of the local function objects </li><li>
<a id="pgfId-1008411"></a>A single function object which dispatches control to the appropriate local functions </li></ul>



<h3>
<a id="pgfId-1008412"></a>Stack Module Example</h3>

<p>
<a id="pgfId-1008414"></a>A <code>stack</code><a id="marker-1008413"></a> is a well-known data structure that allows the client to push a data value onto it and to pop a data value from it.</p>

<h4>
<a id="pgfId-1008415"></a>The Procedural Interface</h4>

<p>
<a id="pgfId-1008416"></a>The following table summarizes the procedural interface functions to the sample stack module.</p>

<p>
<a id="pgfId-1009306"></a></p>
<table class="webflareTable" id="#id1008417">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008419">
<a id="pgfId-1008419"></a>Action</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008421">
<a id="pgfId-1008421"></a>Function Call</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008423">
<a id="pgfId-1008423"></a>Return Value</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008425"></a>Allocate a stack.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008427"></a>makeStack( aList )</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008429"></a>Function object</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008431"></a>Push a value onto the stack.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008433"></a>pushStack( <br />aStack aValue )</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008435"></a>A list of the stack contents</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008437"></a>Pop a value from the stack.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008439"></a>popStack( aStack )</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008441"></a>A popped value</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1008443"></a>The variable <code>aStack</code> is assumed to contain a stack object allocated by calling the <code>makeStack</code><a id="marker-1008442"></a> function. </p>

<h4>
<a id="pgfId-1008444"></a>Allocating a Stack </h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008445"></a>S = makeStack( &#39;( 1 2 3 4 )) =&gt; funobj:0x1e36d8</pre>
<h4>
<a id="pgfId-1008446"></a>Popping a Value</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008447"></a>popStack( S ) =&gt; 1<br />popStack( S ) =&gt; 2</pre>
<h4>
<a id="pgfId-1008448"></a>Pushing a Value on the Stack</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008449"></a>pushStack( S 5 ) =&gt; (5 3 4) </pre>

<p>
<a id="pgfId-1008450"></a>Returns a list of stack contents at this point.</p>

<h4>
<a id="pgfId-1008451"></a><a id="20169"></a>Implementing the makeStack Function</h4>

<p>
<a id="pgfId-1008452"></a>The <code>makeStack</code> function returns a function object. This function object is an instance of the stack module. In turn, this function object returns one of several functions local to the <code>makeStack</code> function.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008453"></a>procedure( makeStack( initialContents )<br />    let( (( theStack initialContents ))<br />            <br />        procedure( ppush( value )<br />            theStack = cons( value theStack )<br />            ) <br />      <br />        procedure( ppop( )<br />            let( (( v car( theStack ) ))<br />                theStack = cdr( theStack )<br />                v<br />                ) <br />            ) <br />
&#160;&#160;      lambda( ( msg)           ;;;; return a function object<br />            case( msg <br />                ( ( ppush ) ppush )<br />                ( ( ppop ) ppop )<br />                ( t nil )<br />                ) <br />            ) <br />        ) ; let<br />    ) ; procedure</pre>
<h4>
<a id="pgfId-1008454"></a>Implementing the pushStack and popStack Functions</h4>

<p>
<a id="pgfId-1008455"></a>The variable <code>aStack</code> contains a function object.</p>
<ul><li>
<a id="pgfId-1008456"></a>When <code>aStack</code> is called, it returns the appropriate local function <code>ppush</code> and <code>ppop</code>. </li><li>
<a id="pgfId-1008457"></a>The <code>ppush</code> and <code>ppop</code> functions are within the lexical scope of the local variable <code>theStack</code>.</li></ul>

<p>
<a id="pgfId-1008458"></a>Notice the syntactic convenience of calling the stack object indirectly through the <code>fun</code> variable.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008459"></a>procedure( pushStack( aStack aValue )<br />    let( ( ( fun aStack( &#39;ppush ) ) ) <br />                             ;;; retrieve local ppush function<br />        fun( aValue )        ;;; call it<br />        ) <br />    ) <br />
procedure( popStack( aStack )
&#160;&#160;  let( ( ( fun aStack( &#39;ppop ) ) )<br />                             ;;; retrieve local ppop function<br />        fun()                ;;; call it<br />        ) <br />    ) </pre>
<h3>
<a id="pgfId-1008460"></a>The Container Module </h3>

<p>
<a id="pgfId-1008462"></a><code>Containers</code><a id="marker-1008461"></a> are like variables with an important difference. You can reset a container to the original value that you provided when you created the container.</p>

<h4>
<a id="pgfId-1008463"></a>The Procedural Interface</h4>

<p>
<a id="pgfId-1008464"></a>The following table summarizes the procedural interface to the sample container module. This interface relies on the availability of several function objects in the container instance&#8217;s data structure. The <a id="marker-1008465"></a>arrow (<code>-&gt;</code>) operator is used to retrieve the interface functions.</p>

<p>
<a id="pgfId-1009310"></a></p>
<table class="webflareTable" id="#id1008466">
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008468">
<a id="pgfId-1008468"></a>Action</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008470">
<a id="pgfId-1008470"></a>Function Call</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1008472">
<a id="pgfId-1008472"></a>Return Value</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008474"></a>Allocate a container with an initial value.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008476"></a><code>aContainer = <br />makeContainer(aValue)</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008478"></a>A disembodied property list representing the container instance.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008480"></a>Return the container&#8217;s current value.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008482"></a><code>aContainer-&gt;get()</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008484"></a>Current value in <br />aContainer</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008486"></a>Store a new value in the container.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008488"></a><code>aContainer-&gt;set( bValue)</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008490"></a>The container&#8217;s new value.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008492"></a>Reset the container to the initial value</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008494"></a><code>aContainer-&gt;reset()</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1008496"></a>The container&#8217;s original value.</p>
</td>
</tr>
</tbody></table>
<h4>
<a id="pgfId-1008497"></a>Implementing the makeContainer Function</h4>

<ul><li>
<a id="pgfId-1008498"></a>The <code>makeContainer</code> function returns a disembodied property list containing the local functions as property values. </li><li>
<a id="pgfId-1008499"></a>The three functions <code>resetValue</code>, <code>setValue</code>, and <code>getValue</code> are local but are accessible through <code>makeContainer&#8217;</code>s return value. </li><li>
<a id="pgfId-1008500"></a>Unlike the stack module example, there are no global functions in the procedural interface. <br /><pre class="webflare-pre-block webflare-courier-new" id="#id1011593">
<a id="pgfId-1011593"></a>procedure( makeContainer( initialValue )
    let( ( (value initialValue))        ;;; initialize the container
        procedure( resetValue()         ;;; reset value
              value = initialValue 
              )
        procedure( setValue( newValue ) ;;; store new value
              value = newValue 
              )
        procedure( getValue( )          ;;; return current value 
              value 
              )

        resetValue()                        
        list( nil                       ;;; the return value
              &#39;set setValue 
              &#39;get getValue 
              &#39;reset resetValue 
              )
        ) ; let
  ) ; procedure</pre></li></ul>




<h4>
<a id="pgfId-1008502"></a>Allocating Container Instances</h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008503"></a>x = makeContainer( 0 ) <br />    =&gt; (nil <br />          set funobj:0x1e38f8 <br />          get funobj:0x1e3908 <br />          reset funobj:0x1e38e8 )</pre>

<p>
<a id="pgfId-1008504"></a>This example allocates a container instance with initial value 0.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008505"></a>y = makeContainer( 2 )<br />    =&gt; (nil <br />          set funobj:0x1e3928 <br />          get funobj:0x1e3938<br />          reset funobj:0x1e3918 )</pre>

<p>
<a id="pgfId-1008506"></a>This example allocates a container instance with an initial value of 2. Notice that the returned value contains different function objects.</p>

<h4>
<a id="pgfId-1008507"></a>Retrieving Container Values </h4>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1008508"></a>x-&gt;get() + y-&gt;get() =&gt; 2</pre>

<p>
<a id="pgfId-1008509"></a>This example retrieves the values of the two containers and adds them. Notice the conventional function call syntax accepts an arrow (<code>-&gt;</code>) operator expression in place of a function name to access member functions.</p>
<p>
<a id="pgfId-1008201"></a></p>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap13.html" id="prev" title="About SKILL++ and SKILL">About SKILL++ and SKILL</a></em></b><b><em><a href="chap15.html" id="nex" title="Using SKILL and SKILL++ Together">Using SKILL and SKILL++ Togeth ...</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
 

 <div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160;â € </center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div> 

</body></html>