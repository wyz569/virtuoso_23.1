
<html><head><title>Creating Functions in SKILL</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="parula" />
<meta name="CreateDate" content="2023-08-23" />
<meta name="CreateTime" content="1692797221" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the SKILL language to new users and helps them understand advanced topics, encourages sound SKILL programming methods, and introduces the SKILL++ language" />
<meta name="DocTitle" content="Cadence SKILL Language User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="Creating Functions in SKILL" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-4.0.0" />
<meta name="Keyword" content="sklanguser" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-08-23" />
<meta name="ModifiedTime" content="1692797221" />
<meta name="NextFile" content="chap4.html" />
<meta name="Group" content="SKILL Language" />
<meta name="Platform" content="Cadence Shared Tools" />
<meta name="PrevFile" content="chap2.html" />
<meta name="c_product" content="Virtuoso Layout Suite,Virtuoso Schematic Editor,Virtuoso Analog Design Environment" />
<meta name="Product" content="SKILL" />
<meta name="ProductFamily" content="SKILL" />
<meta name="ProductVersion" content="IC23.1" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Cadence SKILL Language User Guide -- Creating Functions in SKILL" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="0" />
<meta name="Version" content="IC23.1" />
<meta name="SpaceKey" content="sklanguserIC231" />
<meta name="webflare-version" content="2.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" />


  <script>/*<![CDATA[*/
 document.addEventListener("DOMContentLoaded", function(event) {  document.querySelectorAll("img").forEach((img, index) => {
if (img.hasAttribute("usemap")){return;}else{img.classList.add("cursorclass");} img.addEventListener("click", (e) => {if(img.hasAttribute("usemap")){            img.setAttribute("style","cursor:none;");return;};document.querySelector("#cad_image_modal").classList.add("opac");document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0;margin: auto;max-height:95%;"  src="${e.target.src}">`;});});});
/*]]>*/</script> 




 <style>/*<![CDATA[*/
.cursorclass{cursor:pointer;}#cad_image_modal{position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;}#cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;}#cad_image_modal span{position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;}
/*]]>*/</style> 
</head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="sklanguserTOC.html">Contents</a></li><li><a class="prev" href="chap2.html" title="Language Characteristics">Language Characteristics</a></li><li style="float: right;"><a class="viewPrint" href="sklanguser.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap4.html" title="Data Structures">Data Structures</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Cadence SKILL Language User Guide<br />Product Version IC23.1, September 2023</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<h1>3
<a id="pgfId-1005655"></a></h1>
<h1>
<a id="pgfId-1008199"></a><hr />
<a id="22383"></a>Creating Functions in SKILL<hr />
</h1>

<p>
<a id="pgfId-1011915"></a><a href="chap1.html#18267">&#8220;Cadence SKILL Language&#8221;</a> introduces you to developing a Cadence&#174; SKILL language function. This chapter introduces you to constructs for defining a function and defining local and global variables.</p>
<p>
<a id="pgfId-1010243"></a>This chapter covers the following topics:</p>
<ul><li>
<a id="pgfId-1010248"></a><a href="chap3.html#61650">Terms and Definitions</a></li><li>
<a id="pgfId-1011906"></a><a href="chap3.html#96951">Kinds of Functions</a></li><li>
<a id="pgfId-1010252"></a><a href="chap3.html#92010">Syntax Functions for Defining Functions</a>  </li><li>
<a id="pgfId-1009792"></a><a href="chap3.html#17761">Defining Parameters</a>  </li><li>
<a id="pgfId-1009802"></a><a href="chap3.html#25755">Type Checking</a>  </li><li>
<a id="pgfId-1009806"></a><a href="chap3.html#21206">Local Variables</a>  </li><li>
<a id="pgfId-1009814"></a><a href="chap3.html#36873">Global Variables</a>  </li><li>
<a id="pgfId-1009824"></a><a href="chap3.html#38184">Redefining Existing Functions</a>  </li><li>
<a id="pgfId-1009826"></a><a href="chap3.html#26282">Physical Limits for Functions</a>  </li></ul>








<p>
<a id="pgfId-1011947"></a>See also <a href="chap9.html#30824">&#8220;Advanced Topics&#8221;</a> for more information.</p>

<h2>
<a id="pgfId-1009052"></a><a id="61650"></a>Term<a id="marker-1009051"></a>s and Definitions</h2>
<p>
<a id="pgfId-1015145"></a></p>
<table class="webflareTable" id="#id1015151">
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015153"></a><a id="marker-1015184"></a>function, <a id="marker-1015185"></a>procedure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015155"></a>In SKILL, the terms procedure and function are used interchangeably to refer to a parameterized body of code that can be executed with parameters bound to the formal parameters. SKILL can represent a function as both a hierarchical list and as a function object.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015157"></a><a id="marker-1015252"></a>argument, <a id="marker-1015253"></a>parameter</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015159"></a>The terms argument and parameter are used interchangeably. The arguments in a function call correspond to the formal arguments in the declaration of the function.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015161"></a><a id="marker-1015352"></a>byte-code</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015163"></a>A generic term for the machine code for a &#8220;virtual&#8221; machine.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015165"></a><a id="marker-1015375"></a>virtual machine</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015167"></a>A machine that is not physically built, but is emulated in software instead.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015437"></a><a id="marker-1015465"></a>function object</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015439"></a>The set of byte-code instructions that implement a function&#8217;s algorithm. SKILL programs can treat function objects on a basic level like other data types: compare for equality, assigning to a variable, and pass to a function.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015441"></a><a id="marker-1015510"></a>function body</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015443"></a>The collection of SKILL expressions that define the function&#8217;s algorithm.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015445"></a><a id="marker-1015555"></a>compilation</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015447"></a>The generation of byte-code that implements the function&#8217;s algorithm.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015449"></a><a id="marker-1015622"></a><a id="marker-1015623"></a>compile time</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015451"></a>SKILL compiles function definitions when you load source code. Top-level expressions are compiled and then executed.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015453"></a><a id="marker-1015670"></a>run time</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1015455"></a>The time during which SKILL evaluates a function object.</p>
</td>
</tr>
</tbody></table>
<h2>
<a id="pgfId-1009074"></a><a id="96951"></a>Kinds of Functions</h2>

<p>
<a id="pgfId-1009075"></a>SKILL has several different kinds of functions, classified by the internal names of <a id="marker-1009076"></a><code>lambda</code>,<code> nlambda</code>, and <a id="marker-1009077"></a><code>macro</code>. SKILL follows different steps when evaluating these functions. </p>
<ul><li>
<a id="pgfId-1009079"></a>Most of the functions you will define are <code>lambda</code> functions. SKILL executes a <code>lambda</code><a id="marker-1009078"></a> function after evaluating the parameters and binding the results to the formal parameters. </li><li>
<a id="pgfId-1009080"></a>You will probably not need to define an <code>nlambda</code> function. However, several built-in SKILL functions are <code>nlambda</code> functions.<br />
<a id="pgfId-1011052"></a>An <a id="marker-1009081"></a><code>nlambda</code> function should be declared to have a single formal argument. When evaluating an <code>nlambda</code> function, SKILL collects all the argument expressions unevaluated into a list and binds that list to the single formal argument. The body of the nlambda can selectively evaluate the elements of the argument list.</li><li>
<a id="pgfId-1009082"></a>It is not likely that you will write many macros. A <code>macro</code> function allows you to adapt the normal SKILL function call syntax to the needs of your application. Unlike <code>lambda</code> and <code>nlambda</code> functions, SKILL evaluates a macro at compile-time. When compiling source code, if SKILL encounters a <code>macro</code> function call, it evaluates the function call immediately and the last expression computed is compiled in the current function object. </li></ul>




<h2>
<a id="pgfId-1009085"></a><a id="marker-1009083"></a><a id="92010"></a>Syntax Functions for Defining Functions </h2>

<p>
<a id="pgfId-1009087"></a>SKILL supports the following <a id="marker-1009086"></a>syntax functions for defining functions. You should use the <code>procedure</code> function or the <code>defun</code> function in most cases. </p>

<h3>
<a id="pgfId-1009088"></a><a id="10047"></a>procedure</h3>

<p>
<a id="pgfId-1009089"></a>The <code>procedure</code> function is the most general and is easiest to use and understand. Anything that can be done with the other function definition functions can be done with a <code>procedure</code> and possibly a <code>quote</code> in the call.</p>
<p>
<a id="pgfId-1009091"></a>The <a id="marker-1009090"></a><code>procedure</code> function provides the standard method of defining functions. Its return value is the symbol with the name of the function. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009092"></a>procedure( trAdd( x y ) <br />      printf( &quot;Adding %d and %d &#8230; %d \n&quot; x y x+y ) <br />      x+y <br />      ) =&gt; trAdd<br />trAdd( 6 7 ) =&gt; 13</pre>
<h3>
<a id="pgfId-1009093"></a>lambda</h3>

<p>
<a id="pgfId-1009095"></a>The <a id="marker-1009094"></a><code>lambda</code> function defines a function without a name. Its return value is a function object that can be stored in a variable. For example: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1011006"></a>trAddWithMessageFun = lambda( ( x y )<br />      printf( &quot;Adding %d and %d &#8230; %d \n&quot; x y x+y ) <br />      x+y <br />      ) =&gt; funobj:0x1814b90</pre>

<p>
<a id="pgfId-1009097"></a>You can subsequently pass a function object to the apply function<br />together with an argument list. For example: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009098"></a>apply( trAddWithMessageFun &#39;( 4 5 ) ) =&gt; 9 </pre>

<p>
<a id="pgfId-1009099"></a>The use of <code>lambda</code> can render code difficult to understand. Often the function being defined is required at some other point in the program and so a procedural definition is better. However, the <code>lambda</code> structure can be useful when defining special purpose functions and for passing very small functions to functions such as <code>sort</code>. For example, to sort a list <code>signalList</code> of disembodied property list objects by a property named <code>strength</code>, do the following:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009100"></a>signalList = &#39;( <br />      ( nil strength 1.5 )<br />      ( nil strength 0.4 )<br />      ( nil strength 2.5 )<br />      )</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009101"></a>sort( signalList<br />      lambda( ( a b ) a-&gt;strength &lt;= b-&gt;strength )<br />      )</pre>

<p>
<a id="pgfId-1009104"></a>Refer to <a href="chap9.html#27967">&#8220;Declaring a Function Object (lambda)&#8221;</a> for further details.</p>

<h3>
<a id="pgfId-1009107"></a><a id="marker-1009106"></a>nprocedure</h3>

<p>
<a id="pgfId-1009108"></a>Do not use the <code>nprocedure</code> function in new code that you write. It is only included in the system for compatibility with prior releases. </p>
<ul><li>
<a id="pgfId-1009109"></a>To allow your function to accept an indeterminate number of arguments, use the <a id="marker-1009110"></a><code>@rest</code> option with the <code>procedure</code> function.</li><li>
<a id="pgfId-1009111"></a>To allow your function to receive arguments unevaluated, use the <code>defmacro</code><a id="marker-1009112"></a> function.</li></ul>


<h3>
<a id="pgfId-1009113"></a>defmacro</h3>

<p>
<a id="pgfId-1009115"></a>The <a id="marker-1009114"></a><code>defmacro</code> function provides a means for you to define a <code>macro</code> function. You can use a macro to design your own customized SKILL syntax. Your macro is responsible for translating your custom syntax at compile time into a SKILL expression to be compiled and subsequently executed. </p>
<p>
<a id="pgfId-1009119"></a>Refer to <a href="chap9.html#90007">&#8220;Macros&#8221;</a> for further discussion and examples.</p>

<h3>
<a id="pgfId-1009120"></a>mprocedures</h3>

<p>
<a id="pgfId-1009122"></a>The <a id="marker-1009121"></a><code>mprocedure</code> function is a more primitive alternative to the <code>defmacro</code> function. The <code>mprocedure</code> function has a single argument. The entire custom syntax is passed to the <code>mprocedure</code> function unevaluated.</p>
<p>
<a id="pgfId-1009123"></a>Do not use the <code>mprocedure</code> function in new code. It is only included in the system for compatibility with prior releases. Use the <code>defmacro</code> function instead. If you need to receive an indeterminate number of unevaluated arguments, use an <code>@rest </code>argument.</p>
<p>
<a id="pgfId-1009127"></a>Refer to <a href="chap9.html#90007">&#8220;Macros&#8221;</a> for further discussion and examples.</p>

<h3>
<a id="pgfId-1012786"></a>defglofun</h3>

<p>
<a id="pgfId-1012800"></a>The defglofun function defines a function which is global within a lexical scope.</p>

<h3>
<a id="pgfId-1009128"></a>Summary of Syntax Functions</h3>

<p>
<a id="pgfId-1009129"></a>The following table summarizes each syntax function for declaring a function. You should think twice about using anything other than <code>procedure</code>. </p>

<p>
<a id="pgfId-1010402"></a></p>
<table class="webflareTable" id="#id1010411">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1010413"></a>Comparison of Syntax Functions</div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1010421">
<a id="pgfId-1010421"></a>Syntax Function</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1010423">
<a id="pgfId-1010423"></a>Function Type</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1010425">
<a id="pgfId-1010425"></a>Argument Evaluation</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1010427">
<a id="pgfId-1010427"></a>Execution</span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010429"></a>procedure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010431"></a>lambda</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010433"></a>The arguments are evaluated and bound to the corresponding formal arguments.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010435"></a>The expressions in the body are evaluated at run time. The last value computed is returned.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010437"></a>defmacro</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010439"></a>macro</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010441"></a>The arguments are bound unevaluated to the corresponding formal arguments.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010443"></a>The expressions in the body are evaluated at compile time. The last value computed is compiled.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010445"></a>mprocedure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010447"></a>macro</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010449"></a>The entire function call is bound to the single formal argument.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010451"></a>The expressions in the body are evaluated at compile time. The last value computed is compiled.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010453"></a>nprocedure</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010455"></a>nlambda</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010457"></a>All arguments are gathered unevaluated into a list and bound to the single formal argument.</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010459"></a>The expressions in the body are evaluated at run time. The last value computed is returned.</p>
</td>
</tr>
</tbody></table>
<h2>
<a id="pgfId-1009179"></a><a id="17761"></a>Defining Parameters</h2>

<p>
<a id="pgfId-1009181"></a>You can declare how <a id="marker-1009180"></a>parameters are to be passed to your function by adding the at (@) options in the formal argument list. The available @ options are <code>@rest</code>, <code>@optional</code>, and <code>@key</code>. You can use these options in <code>procedure</code>, <code>lambda</code>, and <code>defmacro</code> argument lists.</p>

<h3>
<a id="pgfId-1009182"></a>@rest Option</h3>

<p>
<a id="pgfId-1009184"></a>The <a id="marker-1009183"></a><code>@rest</code> option allows an arbitrary number of parameters to be passed to a function in a list. The name of the parameter following <code>@rest</code> is arbitrary, although <code>args</code> is a good choice.</p>
<p>
<a id="pgfId-1009185"></a>The following example illustrates the benefits of an <code>@rest</code> argument.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009186"></a>procedure( trTrace( fun @rest args )<br />      let( ( result )<br />            printf( &quot;\nCalling %s passing %L&quot; fun args )<br />            result = apply( fun args )<br />            printf( &quot;\nReturning from %s with %L\n&quot; fun result )<br />            result<br />            ) ; let<br />      ) ; procedure</pre>

<p>
<a id="pgfId-1009187"></a>For example, invoking the <code>trTrace</code> function passing <code>plus</code> and <code>1, 2, 3</code> returns <code>6</code>.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009188"></a>trTrace( &#39;plus 1 2 3 ) =&gt; 6</pre>

<p>
<a id="pgfId-1009189"></a>and displays the following output in the CIW.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009190"></a>Calling plus passing (1 2 3)<br />Returning from plus with 6</pre>

<ul><li>
<a id="pgfId-1009191"></a>The <code>trTrace</code> function calls the <code>fun</code> function and passes the arguments it received. </li><li>
<a id="pgfId-1009193"></a>The <a id="marker-1009192"></a><code>apply</code> function calls a given function with the given argument list. <code>trTrace</code> passes the <code>@rest </code>argument list directly to the <code>apply</code> function.</li></ul>

<p>
<a id="pgfId-1009194"></a>The <code>trTrace</code> function must accept an arbitrary number of arguments. The number of arguments passed can vary from call to call.</p>
<p>
<a id="pgfId-1009195"></a>Another benefit of <code>@rest</code> is that it puts the arguments into a single list. The <code>trTrace</code> function would be less convenient to use if the caller had to put <code>fun</code>&#8217;s arguments into a list.</p>
<p>
<a id="pgfId-1012918"></a>If in a function that specifies keyword arguments and passes arguments using <code>@rest </code>option, you use the same keyword argument more than once, SKILL uses the first value of the keyword encountered in the function. Any value that does not match with either required or keyword arguments are passed to the <code>@rest</code> argument.</p>
<p>
<a id="pgfId-1012919"></a>The following example illustrates the scenario where the same keyword argument (<code>x</code>) is specified twice.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012920"></a>defun( test (a @key x y @rest z)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012921"></a>  printf(&quot;a=%L x=%L y=%L z=%L\n&quot; a x y z))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012922"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012923"></a>(test 0 ?x 1 ?x 2)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012924"></a>=&gt; a=0 x=1 y=nil z=(?x 2)</pre>
<h3>
<a id="pgfId-1009196"></a>@optional Option</h3>

<p>
<a id="pgfId-1009198"></a>The <a id="marker-1009197"></a><code>@optional</code> option gives you another way to specify a flexible number of arguments. With <code>@optional</code>, each argument on the argument list is matched up with an argument on the formal argument list. </p>
<p>
<a id="pgfId-1009199"></a>You can provide any optional parameter with a default value. Specify the default value using a default form. The default form is a two-member list. The first member of this list is the optional parameter&#8217;s name. The second member is the default value. </p>
<p>
<a id="pgfId-1009200"></a>The default value is assigned only if no value is assigned when the function is called. If the procedure does not specify a default value for an argument, <code>nil</code> is assigned.</p>
<p>
<a id="pgfId-1009201"></a>If you place <code>@optional</code> in the argument list of a procedure definition, any parameter following it is considered optional.</p>
<p>
<a id="pgfId-1009202"></a>The <code>trBuildBBox</code> function builds a bounding box.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009203"></a>procedure( trBuildBBox( height width @optional <br />      ( xCoord 0 ) ( yCoord 0 ) )<br />            list( <br />            xCoord:yCoord ;;; lower left <br />            xCoord+width:yCoord+height ) ;;; upper right<br />      ) ; procedure</pre>

<p>
<a id="pgfId-1009204"></a>Both <code>length</code> and <code>width</code> must be specified when this function is called. However, the coordinates of the box are declared as optional parameters. If only two parameters are specified, the optional parameters are given their default values. For <code>xCoord</code> and <code>yCoord</code>, those values are 0.</p>
<p>
<a id="pgfId-1009205"></a>Examine the following calls to <code>trBuildBBox</code> and their return values: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009206"></a>trBuildBBox( 1 2 )       =&gt; ((0 0) (2 1))<br />trBuildBBox( 1 2 4 )     =&gt; ((4 0) (6 1)) <br />trBuildBBox( 1 2 4 10)&#160;&#160; =&gt; ((4 10) (6 11))</pre>
<h3>
<a id="pgfId-1009207"></a>@key Option</h3>

<p>
<a id="pgfId-1009208"></a><code>@optional</code> relies on order to determine what arguments are assigned to each formal argument. The <code>@key</code><a id="marker-1009209"></a> option lets you specify the expected arguments in any order. </p>
<p>
<a id="pgfId-1009210"></a>For example, examine the following generalization of the <code>trBuildBBox</code> function. Notice that within the body of the function, the syntax for referring to the parameters is the same as for ordinary parameters: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009211"></a>procedure( trBuildBBox( <br />      @key ( height 0 ) ( width 0 ) ( xCoord 0 ) ( yCoord 0 ) )<br />
&#160;&#160;    list( <br />            xCoord:yCoord ;;; lower left <br />            xCoord+width:yCoord+height ) ;;; upper right<br />      ) ; procedure</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009212"></a>trBuildBBox()                                                           =&gt; ((0 0) (0 0))<br />trBuildBBox( ?height 10 )                              =&gt; ((0 0) (0 10))<br />trBuildBBox( ?width 5 ?xCoord 10 )&#160;&#160; =&gt; ((10 0) (15 0)) </pre>
<h4>
<a id="pgfId-1018141"></a>Default Values of Arguments</h4>

<p>
<a id="pgfId-1017834"></a>Each optional argument, whether optional or mandatory (see the arguments defined with @key), can be provided with an expression that is used to compute the default value of that optional argument. This is done using the SKILL or SKILL ++ environment in which the function is defined. The expression is evaluated for each call where the given optional parameter is not provided a value, and the optional argument set to the resulting value.</p>
<p>
<a id="pgfId-1017836"></a>For instance:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017837"></a>(inSkill</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017838"></a> (procedure (testSkill a @optional (b (car a)))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017839"></a> &#160;&#160;  b))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017840"></a>(inSkill (testSkill &#39;(1 2 3)))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017841"></a>*Error* car: argument #1 should be a list (type template = &quot;l&quot;) &#8211; unbound</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017842"></a></pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017843"></a>(inScheme</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017844"></a> (procedure (testScheme a @optional (b (car a)))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017845"></a> &#160;&#160;  b))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017846"></a>(inScheme (testScheme &#39;(1 2 3)))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017847"></a>1</pre>

<p>
<a id="pgfId-1017848"></a>In SKILL, an expression of an optional argument is evaluated in a environment that does not include the bindings of the other function parameters and cannot refer to them.</p>
<p>
<a id="pgfId-1017850"></a>In SKILL++, an expression can refer to the values of other function parameters. Furthermore, in SKILL++ the expression can refer to parameters that occur later in the parameter list:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017852"></a>(inScheme</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017853"></a> (procedure (testScheme2 @key (b (car a)) a)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017854"></a> &#160;&#160;  b))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017855"></a>(inScheme (testScheme2 ?a &#39;(1 2 3)))</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1017856"></a>1</pre>
<h3>
<a id="pgfId-1013278"></a>@aux Option</h3>

<p>
<a id="pgfId-1013414"></a>The <a id="marker-1013815"></a><code>@aux</code> option provides a way to declare auxiliary variables that are local to the function body. These variables are specified as variable name-value pairs. If the value is specified, the variable is bound to <code>t</code>, otherwise it is bound to <code>nil</code>. </p>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1013915"></a><code>@aux</code> variables are semantically similar to <code>letseq</code>.</div>

<p>
<a id="pgfId-1013758"></a>The following definitions are valid and the same rules are applicable for <code>defun</code>, <code>define</code>, <code>procedure</code>, <code>defmethod</code>, <code>lambda</code>, and <code>defmacro</code>:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013558"></a>(defun myfunction (a b c @key d e @aux f g h)<br />   ...)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013560"></a>(defun myfunction (a b c @optional d e @aux f g h)<br />   ...)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013496"></a>(defun myfunction (a b c @rest d @aux f g h)<br />   ...)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013499"></a>(defun myfunction (a b c @key d e @rest f @aux g h)<br />   ...)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1013502"></a>(defun myfunction (a b c @optional d e @rest f @aux g h)<br />   ...)</pre>

<p>
<a id="pgfId-1013702"></a>After all other parameter specifiers (such as <code>@rest</code>, <code>@optional</code>, and <code>@key</code>) have been evaluated, the symbols following the <code>@aux</code> keyword are processed from left to right. </p>

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1013989"></a><code>@aux</code> keyword is supported in SKILL++.</div>
<h3>
<a id="pgfId-1009213"></a>Combining Arguments </h3>

<p>
<a id="pgfId-1009214"></a><code>@key</code> and <code>@optional</code> are mutually exclusive; they cannot appear in the same argument list. Consequently, there are two standard forms that <code>procedure</code> argument lists follow: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009215"></a>procedure(functionname([var1 var2 &#8230;]<br />      [@optional opt1 opt2 &#8230;]<br />      [@rest r])<br />      .<br />      .<br />)</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009216"></a>procedure(functionname([var1 var2 &#8230;]<br />      [@key key1 key2 &#8230;]<br />      [@rest r])<br />      .<br />      .<br />)</pre>
<h2>
<a id="pgfId-1009217"></a><a id="25755"></a>Type <a id="typechecking"></a>Checking</h2>

<p>
<a id="pgfId-1009219"></a>Unlike most conventional languages that perform <a id="marker-1009218"></a>type checking at compile time, SKILL performs dynamic type checking when functions are executed (not when they are defined). Each SKILL lambda or macro function can have as part of its definition an argument template that defines the types of arguments that the function expects. Type checking is not supported in <a id="marker-1009220"></a><code>mprocedure</code> functions.</p>
<p>
<a id="pgfId-1011983"></a>Type characters are discussed in <a href="chap2.html#65855">&#8220;Data Characteristics&#8221;</a>. For type checking purposes, you can use several <a id="marker-1011984"></a>composite type characters (shown in the table below) representing a union of data types.</p>

<p>
<a id="pgfId-1010469"></a></p>
<table class="webflareTable" id="#id1010473">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1010475"></a>Composite Characters for <a id="Typechecking"></a>Type Checking</div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1010479">
<a id="pgfId-1010479"></a>Character</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1010481">
<a id="pgfId-1010481"></a>Meaning </span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010483"></a><code>S</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010485"></a>Symbol or string</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1010487"></a><code>n</code></p>

</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010489"></a>Number: <code>fixnum</code>, <code>flonum</code></p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">

<p>
<a id="pgfId-1010491"></a><code>u</code></p>

</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1013235"></a>Function: <br />Either a symbol (function name), a function object (SKILL function/binary function/primeop), or a SKILL list</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010495"></a><code>g</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1010497"></a>Any data type</p>
</td>
</tr>
</tbody></table>

<p>
<a id="pgfId-1009254"></a>You specify the <a id="marker-1009252"></a>argument <a id="marker-1009253"></a>type template as a string of type characters at the end of a formal argument list. If the template is present, SKILL matches the data type of each argument against the template at the time the function is invoked. For example: </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009255"></a>procedure( f(x y &quot;nn&quot;) x**2 + y**2 ) </pre>

<p>
<a id="pgfId-1009256"></a><code>nn</code> specifies that <code>f</code> accepts two numerical arguments.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009257"></a>procedure( comparelength(str len &quot;tx&quot;) strlen(str) == len)</pre>

<p>
<a id="pgfId-1009258"></a><code>tx</code> specifies that the first argument must be a string and the second must be an integer.</p>

<h2>
<a id="pgfId-1009266"></a><a id="21206"></a><a id="12977"></a>Local Variable<a id="marker-1012013"></a>s<a id="marker-1012000"></a></h2>

<p>
<a id="pgfId-1009267"></a>When you write functions, you should make your variables local. You can define local variables using the <code>let</code> and <code>prog</code> functions:</p>
<ul><li>
<a id="pgfId-1012025"></a><a href="chap3.html#87059">Defining Local Variables Using the let Function</a></li><li>
<a id="pgfId-1012096"></a><a href="chap3.html#83236">Defining Local Variables Using the prog Function</a></li></ul>

<p>
<a id="pgfId-1012103"></a>See also <a href="chap3.html#92441">&#8220;Initializing Local Variables to Non-nil Values&#8221;</a>.</p>

<h3>
<a id="pgfId-1012098"></a><a id="87059"></a>Defining Local Variables Using the let Function</h3>

<p>
<a id="pgfId-1012100"></a>You can use the <a id="marker-1012099"></a><code>let</code> function to establish temporary values for local variables.</p>
<ul><li>
<a id="pgfId-1009276"></a>You can include a list of the local variables followed by one or more SKILL expressions. These variables are initialized to <code>nil</code>.</li><li>
<a id="pgfId-1009277"></a>The SKILL expressions make up the body of the <code>let</code> function, which returns the value of the last expression computed within its body.</li><li>
<a id="pgfId-1009278"></a>The local variables are known only within the <code>let</code> statement. The values of the variables are not available outside the <code>let</code> statement.<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1009279">
<a id="pgfId-1009279"></a>procedure( trGetBBoxHeight( bBox )
    let( ( ll ur lly ury )
        ll                 = car( bBox )
        lly      = cadr( ll )
        ur       = cadr( bBox )
        ury      = cadr( ur )
        ury - lly
    ) ; let
) ; procedure</pre></li><li>
<a id="pgfId-1009280"></a>The local variables are <code>ll,</code> <code>ur,</code> <code>lly</code>, and <code>ury</code>. </li><li>
<a id="pgfId-1009281"></a>They are initialized to <code>nil</code>.</li><li>
<a id="pgfId-1014051"></a>The return value is <code>ury - lly</code>.</li></ul>







<h3>
<a id="pgfId-1014054"></a><a id="83236"></a>Defining Local Variables Using the prog Function</h3>

<p>
<a id="pgfId-1012051"></a>A list of local variables and your SKILL statements make up the arguments to the <a id="marker-1012050"></a><code>prog</code> function.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009286"></a>prog( ( <code><em>localVariables</em></code> ) <code><em>yourSKILLstatements</em></code> )</pre>

<p>
<a id="pgfId-1009287"></a>The <code>prog</code> function allows an explicit loop to be written because the<code> go</code> function is supported within the <code>prog</code>. In addition, <code>prog</code> allows you to have multiple return points through use of the <code>return</code> function. If you are not using either of these two features, <code>let</code> is much simpler and faster (see <a href="chap3.html#87059">&#8220;Defining Local Variables Using the let Function&#8221;</a>).</p>

<h3>
<a id="pgfId-1009288"></a><a id="92441"></a>Initializing Local Variables to Non-nil Values</h3>

<p>
<a id="pgfId-1009289"></a>You can use <code>let</code> to initialize local variables to non-<code>nil</code> values by making a two element list with the local variable and its initial value. You cannot refer to any other local variable in the initialization expression. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009290"></a>procedure( trGetBBoxHeight( bBox )<br />    let( ( ( ll car( bBox ) ) ( ur cadr( bBox ) ) lly ury )<br />        lly            = cadr( ll )<br />        ury            = cadr( ur )<br />        ury - lly<br />    ) ; let<br />) ; procedure</pre>
<h3>
<a id="pgfId-1014241"></a>Declaring dynamic variables (SKILL) inside lexical code (Scheme)</h3>

<p>
<a id="pgfId-1014341"></a>As explained in Chapter 13 (<a href="chap13.html#17549">Contrast Variable Scoping</a>), SKILL and SKILL++ use different scoping rules. However, there are times when you need to declare dynamic variables in lexical scope. You can declare such dynamic variables using the <code>defdynamic</code> or <code>dynamicLet</code> functions and reference their values using the <code>dynamic</code> function. See <em><a actuate="user" class="URL" href="../sklangref/funcprog.html#firstpage" show="replace" xml:link="simple">Cadence SKILL Language Reference</a></em> for more information about these functions.</p>

<h2>
<a id="pgfId-1009291"></a><a id="36873"></a>Global Variables</h2>

<p>
<a id="pgfId-1009293"></a>Besides <a id="marker-1009292"></a>predefined functions that you are not allowed to modify, there are several variable <a id="marker-1009294"></a>names reserved by various system functions. They are listed in <a href="chap2.html#19378">&#8220;Naming Conventions&#8221;</a>.</p>
<p>
<a id="pgfId-1009298"></a>The use of global variables in SKILL, as with any language, should be kept to a minimum. </p>
<p>
<a id="pgfId-1009299"></a>Following standard naming conventions and running SKILL Lint can reduce your exposure to problems associated with global variables.</p>

<h3>
<a id="pgfId-1009300"></a>Testing Global Variables</h3>

<p>
<a id="pgfId-1009301"></a>Applications typically initialize one or more global variables. Before an application runs for the first time, it is likely that its global variables are <code>unbound</code>. In such circumstances, retrieving the value of such a global variable causes an error.</p>
<p>
<a id="pgfId-1009303"></a>Use the <a id="marker-1009302"></a><code>boundp</code> function to check whether a variable is <code>unbound</code> before accessing its value. For example:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009304"></a>boundp( &#39;trItems ) &amp;&amp; trItems</pre>

<p>
<a id="pgfId-1009305"></a>returns <code>nil</code> if <code>trItems</code> is <code>unbound</code> and returns the value of <code>trItems</code> otherwise.</p>

<h3>
<a id="pgfId-1009306"></a>Avoiding Name Clashes</h3>

<p>
<a id="pgfId-1009308"></a>Two applications might accidentally access and set the same <a id="marker-1009307"></a>global value. Use a standard naming scheme to minimize the chance of this problem occurring. SKILL Lint can flag global variables that do not obey your naming scheme. For details, refer to the chapter on SKILL Lint in <em>Cadence SKILL IDE User Guide</em>.</p>
<p>
<a id="pgfId-1009310"></a>Assume that <code>trApplication1</code> and <code>trApplication2</code> are two application functions that are supposed to be totally independent. In particular, the order in which they are executed should not matter. Assume both rely on a single global variable. To observe what can happen if the two applications were accidentally coded to use the same global variable, consider the following example.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009311"></a>procedure( trApplication1()<br />      when( !boundp( &#39;sharedGlobal ) ;;; not set <br />            sharedGlobal = 1<br />            ) ; when<br />      ) ; procedure<br />
procedure( trApplication2()
&#160;&#160;    when( !boundp( &#39;sharedGlobal ) ;;; not set<br />            sharedGlobal = 2<br />            ) ; when<br />      ) ; procedure</pre>

<p>
<a id="pgfId-1009312"></a>The order in which you run <code>trApplication1</code> and <code>trApplication2</code> determines the final value of <code>sharedGlobal</code>. </p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009313"></a>sharedGlobal = &#39;unbound<br />trApplication1()                      =&gt; 1<br />sharedGlobal                          =&gt; 1<br />trApplication2()                      =&gt; nil<br />sharedGlobal&#160;&#160;                        =&gt; 1</pre>
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009314"></a>sharedGlobal = &#39;unbound<br />trApplication2()                      =&gt; 2<br />sharedGlobal                          =&gt; 2<br />trApplication1()                      =&gt; nil<br />sharedGlobal&#160;&#160;                        =&gt; 2</pre>

<p>
<a id="pgfId-1009315"></a>Name &#8220;clashes&#8221; can also occur between functions because programmers can be using the same function names. In this case, a subsequent function definition either overwrites a previous one, or, if <code>writeProtect</code> is set, the function definition fails with an error. </p>

<h3>
<a id="pgfId-1009316"></a>Naming Scheme</h3>

<p>
<a id="pgfId-1009317"></a>The recommended naming scheme is to</p>
<ul><li>
<a id="pgfId-1009318"></a>Use casing to separate code that is developed within Cadence from that developed outside.</li><li>
<a id="pgfId-1009319"></a>Use a group prefix to separate code developed within Cadence.</li></ul>

<p>
<a id="pgfId-1009320"></a>All code developed by Cadence Design Systems should name global variables and functions with an optional underscore; up to three lowercase characters that signify the code package; an optional further lowercase character (one of c, i, or v) and then the name itself starting with an uppercase character. For example, <code>dmiPurgeVersions()</code> or <code>hnlCellOutputs</code>. Any global object created by code developed outside Cadence shall be named starting with an uppercase character, such as <code>AcmeGlobalForm</code>. This includes global variables, functions, namespaces, and objects such as classes or tables. </p>

<h3>
<a id="pgfId-1009321"></a>Reducing the Number of Global Variables</h3>

<p>
<a id="pgfId-1009323"></a>One other technique to reduce the number of global <a id="marker-1009322"></a>variables is to consolidate a collection of related globals into a disembodied property list or a symbol&#8217;s property list. That symbol becomes the only global. </p>
<p>
<a id="pgfId-1009324"></a>This technique could even be extended to associate one symbol with an entire software module. The disadvantage of this approach is that long property lists involve an access time penalty.</p>
<p>
<a id="pgfId-1014141"></a></p>

<h2>
<a id="pgfId-1009325"></a><a id="38184"></a>Redefining Existing Functions </h2>

<p>
<a id="pgfId-1009327"></a>You often need to redefine a <a id="marker-1009326"></a>function that you are debugging. The procedure defining constructs allow you to redefine existing functions; however, functions that are write protected cannot be redefined. </p>
<ul><li>
<a id="pgfId-1009328"></a>A function not being executed can be redefined if the write protection switch was turned off when the function was initially defined. To turn off the <code>writeProtect</code> switch, type<br /><pre class="webflare-pre-block webflare-courier-new" id="#id1009329">
<a id="pgfId-1009329"></a>sstatus( writeProtect nil ) </pre></li><li>
<a id="pgfId-1009330"></a>When building contexts, <code>writeProtect</code> is always set to<code> t</code>.</li></ul>


<p>
<a id="pgfId-1009331"></a>Aside from debugging, the ability to have multiple definitions for the same function is useful sometimes. For example, within the Open Simulation System (OSS) &#8220;default&#8221; netlisting functions can be overridden by user-defined functions. </p>
<p>
<a id="pgfId-1009332"></a>Finally, you should use a standard naming scheme for functions and variables.</p>

<h2>
<a id="pgfId-1009333"></a><a id="26282"></a>Physical Limits for Functions</h2>

<p>
<a id="pgfId-1012943"></a>The following <a id="marker-1012942"></a>physical limitations exist for functions:</p>
<ul><li>
<a id="pgfId-1012944"></a>Total number of required arguments must be less than 65536</li><li>
<a id="pgfId-1013166"></a>Total number of <span class="webflare-courier-new" style="white-space:pre"><em>keyword/optional</em></span> arguments must be less than 255</li><li>
<a id="pgfId-1013167"></a>Total number of local variables in a <code>let</code> must be less than 65536</li><li>
<a id="pgfId-1013168"></a>Max size of code vector is less than 1GB </li></ul>



<p>
<a id="pgfId-1012946"></a>By default, code vectors are limited to functions that can compile less than 32KB words. This translates roughly into a limit of 20000 lines of SKILL code per function. The maximum number of arguments limit of 32KB is mostly applicable in the case when functions are defined to take an @rest argument or in the case of apply called on an argument list longer than 32KB elements.</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1012947"></a>To remove that limitation you should set the following value: setSaveContextVersion(getNativeContextVersion())</pre>

<p>
<a id="pgfId-1009341"></a>Then, the generated contexts (version:602) will not be compatible with old releases but allow code vector in functions to be greater than 32KB.</p>
<p>
<a id="pgfId-1009342"></a>SKILL Lint catches argument numbers greater than the limits with the following message:</p>

<pre class="webflare-courier-new codeContent">
<a id="pgfId-1009343"></a>NEXT RELEASE (DEF6): &lt;filename - line number&gt; (&lt;funcname&gt; :<br />definition for &lt;funcname&gt; cannot have more than 255 optional arguments.</pre>
<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap2.html" id="prev" title="Language Characteristics">Language Characteristics</a></em></b><b><em><a href="chap4.html" id="nex" title="Data Structures">Data Structures</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
 

 <div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160;⠀ </center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div> 

</body></html>