
<html><head><title>stop</title>
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="jaini" />
<meta name="CreateDate" content="2023-03-01" />
<meta name="CreateTime" content="1677669103" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the Virtuoso AMS Designer simulator and Xcelium Simulator with mixed-signal option that supports the Verilog-AMS,  VHDL-AMS, and SystemVerilog-AMS language standards." />
<meta name="DocTitle" content="Spectre AMS Designer and Xcelium Simulator Mixed-Signal User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="stop" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="reference" />
<meta name="reference_type" content="command reference" />
<meta name="prod_feature" content="Analog Mixed-Signal,Digital Mixed-Signal," />
<meta name="prod_subfeature" content="Tcl Commands, Tcl Commands," />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="" />
<meta name="FileType" content="Chapter" />
<meta name="Keyword" content="ams_dms_simug" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-03-01" />
<meta name="ModifiedTime" content="1677669103" />
<meta name="NextFile" content="strobe.html" />
<meta name="Group" content="Mixed-Signal Simulation" />
<meta name="Platform" content="Functional Verification," />
<meta name="PrevFile" content="status.html" />
<meta name="c_product" content="Xcelium," />
<meta name="Product" content="Xcelium," />
<meta name="ProductFamily" content="Xcelium," />
<meta name="ProductVersion" content="22.09" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Spectre AMS Designer and Xcelium Simulator Mixed-Signal User Guide -- stop" />
<meta name="Version" content="22.09" />
<meta name="Renderer" content="WIKI" />
<meta name="SpaceKey" content="amssimug2209" />
<meta name="confluence-version" content="7.4.1" />
<meta name="ecms-plugin-version" content="04.10.026" />

        
        <link href="styles/site.css" rel="stylesheet" type="text/css" />
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    

    
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    document.querySelectorAll("img").forEach((img, index) => {
   img.addEventListener("click", (e) => { 
    document.querySelector("#cad_image_modal").classList.add("opac");
      document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0; margin: auto;max-height: 96%;max-width: 96%;" src="${e.target.src}">`;});});});
</script>

<style>
 img{cursor:pointer;
 }
 #cad_image_modal{
 position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;
 }
 #cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;
 }
 #cad_image_modal span{
  position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;
 }
 </style>

</head><body style="background-color: #FFFFFF;"><!-- Begin Buttons --><header xmlns:html="http://www.w3.org/1999/xhtml"><div class="docHeadr">Product Documentation<img src="images/Cadence-Logo.jpg" /></div>
<nav class="blueHead"><ul><li><a class="content" href="ams_dms_simugTOC.html">Contents</a></li><li><a class="prev" href="status.html" title="status">status</a></li><li style="float: right;"><a class="viewPrint" href="ams_dms_simug.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="strobe.html" title="strobe">strobe</a></li></ul></nav></header><!-- End Buttons --><div xmlns:html="http://www.w3.org/1999/xhtml" style="font-size:14px;line-height:1.42857142857;margin:20px 0 0 0;font-weight:bold;"><center>Spectre AMS Designer and Xcelium Simulator Mixed-Signal User Guide<br />Product Version 22.09, September 2022</center></div>
<div xmlns:html="http://www.w3.org/1999/xhtml" style="margin-left:5%;">
<p></p>

<p></p>
<div id="main-header">
                    
                    
                                                <h1 style="margin: 4px 0 4px;"><span>stop</span></h1>

                    
                </div>
<div class="wiki-content group" id="main-content">
                    
<p><span class="confluence-anchor-link" id="stop-Tcl_stop"></span> <span class="confluence-anchor-link" id="stop-1034611"></span>Creates or operates on a breakpoint. You can</p>
<ul><li>Create various kinds of breakpoints (using the <code>-create</code>&#160;modifier followed by an option that specifies the breakpoint type)</li></ul><ul><li>Display information on breakpoints (<code>-show</code>)</li></ul><ul><li>Disable a breakpoint (<code>-disable</code>)</li></ul><ul><li>Enable a previously disabled breakpoint (<code>-enable</code>)</li></ul><ul><li>Delete a breakpoint (<code>-delete</code>)</li></ul>
<p>See the &quot;Setting Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information:</p>
<h3 id="stop-Syntax">Syntax</h3>
<p style="margin-left: 60.0px;"><code>stop</code></p>
<p style="margin-left: 90.0px;"><code> -create </code><br /><code> &#160; &#160; &#160; &#160;-assert [{-all | -depth {levels | all | to_cells}}] [scope_name] </code><br /><code> &#160; &#160; &#160; &#160;-condition {tcl_expression}</code><br /><code>
   &#160; &#160; &#160; &#160;-delta delta_cycle_number [-relative|-absolute] </code><br /><code> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[-start delta_cycle_number]&#160; </code><br /><code> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[-modulo delta_cycle_number]</code><br /><code>&#160; &#160; &#160; &#160; &#160; &#160; &#160; [-timestep]</code><br /><code>-iso_rule rule_name [rule_name ...] [-iso_enable | -iso_disable]</code><br /><code>-label &quot;stop_message&quot;<br />-line line_number<br />&#160; &#160; &#160; &#160; {-unit unit_name | [ scope_name ] [-all]}<br />&#160; &#160; &#160; &#160; [-file filename]<br />-object object_names</code><br /><code>-at_resfunc &lt;net&gt; -cv_limit &lt;num&gt;</code><br /><br /><code>-pdname power_domain_name [power_domain_name ...]</code><br /><code>[-isolation [-iso_disable | -iso_enable]]<br />[-pd_off]<br />[-pd_on]<br />[-pd_standby]<br />[-pd_trans]<br />[-retention [-sr_restore | -sr_save]]</code></p>
<p style="margin-left: 90.0px;"><code>&#160;-process process_name</code></p>
<p style="margin-left: 90.0px;"><code>-pwr_mode_transition mode_transition_name [mode_transition_name ...] </code><br /><code> -randomize [-always] [object_name ] </code><br /><code> -sr_rule rule_name [rule_name ...] [-sr_save | -sr_restore] </code><br /><code> -subprogram subprogram_name</code></p>
<p style="margin-left: 90.0px;"><code>-time time_spec [-relative | -absolute] </code><br /><code> &#160; &#160; [-start time_spec] </code><br /><code> &#160; &#160; [-modulo time_spec]</code></p>
<p style="margin-left: 60.0px;"><code>&#160; &#160; [-continue] </code><br /><code> &#160; &#160; [-delbreak count] </code><br /><code> &#160; &#160; [-execute command] </code><br /><code> &#160; &#160; [-if { tcl_expression}]&#160; </code><br /><code> &#160; &#160; [-name break_name] </code><br /><code> &#160; &#160; [-silent] </code><br /><code> &#160; &#160; [-skip count]</code></p>
<p style="margin-left: 30.0px;"><code>&#160; &#160; -delete { break_name | pattern} ... </code><br /><code> &#160; &#160; -disable { break_name | pattern} ... </code><br /><code> &#160; &#160; -enable { break_name | pattern} ... </code><br /><code> &#160; &#160; -show [{ break_name | pattern} ...]</code></p>

<p>The argument to <code>-delete</code>,<code> -disable</code>,<code> -enable</code>, or <code>-show</code>&#160;can be</p>
<ul><li>A break name</li></ul><ul><li>A list of break names</li></ul><ul><li>A pattern</li></ul><ul><ul><li>The asterisk (*) matches any number of characters</li></ul></ul><ul><ul><li>The question mark (?) matches any one character</li></ul></ul><ul><ul><li>[<span style=""> characters </span>] matches any one of the characters</li></ul></ul><ul><li>Any combination of literal break names and patterns</li></ul><h3 id="stop-ModifiersandOptions">Modifiers and Options</h3>
<div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 97.6339%;"><colgroup> <col style="width: 19.4014%;" /> <col style="width: 25.3457%;" /> <col style="width: 53.0671%;" /> </colgroup><tbody><tr><th class="confluenceTh">
<p>Modifiers</p>
</th><th class="confluenceTh">
<p>Options and Arguments</p>
</th><th class="confluenceTh">
<p>Function</p>
</th></tr>
<tr><td class="confluenceTd">
<p><code>-create</code></p>
</td>
<td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p>Creates a breakpoint. This modifier must be followed by an option that specifies the breakpoint type:</p>

<p><code> -condition </code></p>

<p><code> -delta </code>(VHDL only)</p>

<p><code> -line </code></p>

<p><code> -object </code></p>

<p><code> -process </code>(VHDL only)</p>

<p><code> -time </code></p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>-assert [{-all | -depth {levels | all | to_cells}}] [scope_name]</code></td>
<td class="confluenceTd" colspan="1">
<p>The <code>-assert</code> option lets you define a single breakpoint that is shared by multiple assertions in the design. Stop at failures for all assertions in the design hierarchy by using the -all option.<br /><code>xcelium&gt; stop -assert -all</code> <br />Stop at failures for all assertions in a specified scope (or the current debug scope if no scope is specified).<br /><code>xcelium&gt; stop -assert</code> <br /><code>xcelium&gt; stop -assert top</code> <br /><code>xcelium&gt; stop -assert top.u1</code></p>

<p>Specify how many scope levels to descend when searching for assertions to stop by using<br />the <code>-depth</code> option. The argument to <code>-depth</code> can be:</p>
<ul><li><code>Levels</code> - Descend the specified number of scopes. For example, <code>-depth 1</code> means include only the given scope, <code>-depth 2</code> means include the given scope and its sub-scopes, and so on. The default is 1.</li><li><code>all</code> - Include all scopes in the hierarchy below the given scope.</li><li><code>to_cells</code> - Include all scopes in the hierarchy below the specified scope(s), but stop at cells (Verilog modules with `celldefine or VITAL entities with VITAL Level0 attribute).</li></ul>
<p>By using the <code>-assert</code> option, you can avoid having to define a whole set of breakpoints on the<br />assertions using separate <code>stop -object</code> commands. The <code>-assert</code> option can also be used with other <code>stop</code> command options, such as <code>-execute</code> and <code>-continue</code>.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-condition </code>{<code>tcl_expression</code>}</p>
</td>
<td class="confluenceTd">
<p>Sets a breakpoint that triggers when any digital object referenced in <code> tcl_expression</code> changes value (wires, signals, registers, and variables) or is written to (memories) and the expression evaluates to true (non-zero, non-x, non-z). <code>tcl_expression</code> must contain at least one digital object.</p>

<p><span>For RNM nets, you can set condition for </span> <code>`wrealXState</code> <span> and </span> <code>`wrealZStates</code> <span> to trigger a breakpoint when the specified state is true.</span></p>

<p>Although condition breakpoints are not triggered by changes in analog objects, you can include analog objects in the conditional expression, and their values are used when the condition is evaluated (due to a digital object changing value).</p>

<p>The simulator does not support stop points on individual bits of registers. If a bit-select of a register appears in the expression, the simulator stops and evaluates the expression when any bit of that register changes value. The same holds true for compressed wires.</p>

<p>See <a href="#stop-1035041">Tcl Expressions as Arguments</a>&#160;for details on the format of conditional expressions.</p>

<p>Objects included in a <code>-condition</code> expression must have read access. An error is printed if the object does not have read access. See <a href="Access_to_Digital_Simulation_Objects.html">Enabling Read, Write, or Connectivity Access to Digital Simulation Objects</a>&#160;for details.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="stop-continue"></span> <code>-continue </code></p>
</div>
</td>
<td class="confluenceTd">
<p>Resumes the simulation after executing the breakpoint. The simulator does not go into interactive mode.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-delbreak </code> <code> count </code></p>
</td>
<td class="confluenceTd">
<p>Deletes the breakpoint after it has triggered <code>count</code> number of times.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-delta  delta_cycle_num </code></p>

<p><code>[-absolute] </code></p>

<p><code>[-relative]</code></p>

<p><code>[-start  delta_cycle_num]</code></p>

<p><code>[-modulo delta_cycle_num]</code></p>

<p><code>[-timestep]</code></p>
</td>
<td class="confluenceTd">
<p>Sets a breakpoint that triggers when the simulation delta cycle count reaches the specified delta cycle.</p>

<p>The delta cycle specification can be absolute or relative (the default). If absolute, the breakpoint is automatically deleted after the delta cycle is reached and the breakpoint triggers. If relative, the delta cycle specification is an interval, and the breakpoint stops the simulation every<code> n </code>delta cycles.</p>

<p>Use <code>-start</code> to specify the absolute delta cycle at which a repetitive breakpoint is to begin firing. If this cycle is before the current cycle, the first stop occurs at the next cycle at which it would have occurred had the stop been set at the cycle specified with <code>-start.</code></p>

<p>The <code>-modulo</code> option is similar to <code>-start</code>. Use <code>-modulo</code> to specify the absolute delta cycle of the first stop cycle for a repeating delta cycle stop. This differs from <code>-start</code> only when the given cycle is more than one repeat interval in the future. In this case, the first stop occurs at a delta cycle less than or equal to one interval in the future such that a stop eventually occurs at the given cycle. For example, if you set a delta breakpoint to stop the simulation every 10 delta cycles, and specify <code>-modulo 15</code>, the simulation stops at delta cycle 5, 15, 25, and so on.</p>

<p><code>save -environment</code> writes this option to the script to restore your delta breakpoint pattern.</p>

<p>The <code>-timestep</code> option provides a way to detect infinite loops (due to infinite delta cycles) in the<br />design. This option halts the simulation if the specified number of delta cycles is created at any given simulation time. The simulation halts after the first timestep delta cycle is reached, and the simulation cannot be advanced.</p>

<p>See the &quot;Setting a Delta Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><div class="content-wrapper">
<p><code>-at_resfunc &lt;net&gt; -cv_limit &lt;num&gt;<span class="confluence-anchor-link" id="stop-at_resfunc"></span></code></p>
</div>
</td>
<td class="confluenceTd" colspan="1">
<p>Sets a breakpoint when the resolution function value changes for the target user-defined nettype (UDN). The break occurs in the resolution function for any RNM net within the specified scope.</p>

<p>Optionally, you can set the breakpoint on the number of convergence iterations using by the <code>cv_limit</code> option. The <code>cv_limit</code> value must be a number larger than the expected number of delta cycle iterations required to resolve a time point.</p>

<p>When in resolution function, no other additional argument needs to be added to the TCL <code>driver</code> or <code>value</code> commands to report the net being resolved.</p>

<p>The <code>-if {tcl_expression}</code> option can be added to further qualify the stop behavior. In addition, the <code>-execute</code> <code>(tcl_command)</code> or <code>-execFile {tcl_commandfile}</code> options can be used to augment the stop behavior. For example, to display drivers when the stop occurs, specify: <code>-execute driver</code></p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>
          <span>-iso_rule</span>
        </code></td>
<td class="confluenceTd" colspan="1">
<p>Stop when the specified isolation rule becomes enabled or disabled.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>
<span>rule_name [rule_name ...] [-iso_enable | -iso_disable]</span>
        </code></td>
<td class="confluenceTd" colspan="1">
<p>You can specify multiple isolation rule names.<br />The <code>-iso_rule</code> option has two sub-options:</p>
<ul><li><code>-iso_disable</code>&#8211;Stop only when the isolation rule becomes disabled.</li><li><code>-iso_enable</code>&#8211;Stop only when the isolation rule becomes enabled.</li></ul></td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1">
<p><code>
            <span>-label</span> &quot;stop_message&quot;</code></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Specify a label for the breakpoint message. The breakpoint will issue the stop_message.</p>

<p>For example:<br /><code>xcelium&gt; stop -line 19 -file <span>testbench.sv</span> -label &quot;setup phase&quot;</code></p>

<p><code>Created stop 1</code></p>

<p><code>xcelium&gt; run 0 FS + 0 setup phase</code></p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="stop-execute"></span> <code>-execute </code> <code> command </code></p>
</div>
</td>
<td class="confluenceTd">
<p>Executes the specified Tcl command when the breakpoint is triggered.</p>

<p>If the command that you want to execute requires an argument, enclose the command and its argument in curly braces.</p>

<p>You also can specify that you want to execute a list of commands. Separate the commands with a semicolon. Tcl, however, displays only the output of the last command.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd"><div class="content-wrapper">
<p><span class="confluence-anchor-link" id="stop-if"></span> <code>-if</code>{<code>tcl_expression</code>}</p>
</div>
</td>
<td class="confluenceTd">
<p>Sets a condition on the breakpoint. The breakpoint triggers only if the given Tcl Boolean expression evaluates to true (non-zero, non-x, non-z). This option can be used with any breakpoint type. For more information on the format of <code> tcl_expression,s</code>ee <a href="#stop-1035041">Tcl Expressions as Arguments</a>.</p>

<p>For RNM nets, you can set condition for <code>`wrealXState</code> and <code>`wrealZStates</code> to trigger breakpoint when the specified state is true.</p>

<p>Objects included in an <code>-if</code> expression must have read access. An error is printed if the object does not have read access. See&#160;<a href="Access_to_Digital_Simulation_Objects.html">Access to Digital Simulation Objects</a>.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-line line_number </code></p>

<p><code>{-unit unit_name| </code> <br /><code>[scope_name] [-all] }</code></p>

<p><code>[-file <em>filename</em>]</code></p>
</td>
<td class="confluenceTd">
<p>Sets a breakpoint that triggers when the specified line number is about to execute. You can set breakpoints on both analog and digital code statements. You cannot set a line breakpoint when you are using the simulation front end (SFE) parser. In addition, because structural code is not sequential, you cannot set line breakpoints in such code.</p>

<p>You must specify which design unit contains the line. There are two ways to do this:</p>

<p>Use <code>-unit.</code> The stop occurs whenever the line number in the specified design unit is about to execute, no matter where in the design hierarchy that unit appears.</p>

<p>Specify the name of a particular scope in the design hierarchy. This creates an instance-specific breakpoint. The breakpoint occurs only for that particular instance of the corresponding design unit, no matter where else it may appear in the design hierarchy. To create a breakpoint that is not instance-specific using the <code>scope_name</code> method, use the <code>-all</code> option. If the scope name is omitted, then the current debug scope is used.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p>The <code>-file</code> option specifies which of the source files that make up the specified design unit contains the specified line. This is necessary if the design unit has multiple source files.</p>

<p>You must compile with the <code>-linedebug</code> option to enable the setting of line breakpoints.</p>

<p>See the &quot;Setting a Source Code Line Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-name </code> <code>break_name </code></p>
</td>
<td class="confluenceTd">
<p>Specifies a name for the breakpoint. This name can then be used to delete, disable, or enable the breakpoint. If you do not use <code>-name</code>, breakpoints are numbered sequentially.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-object </code> <code>object_name </code></p>
</td>
<td class="confluenceTd">
<p>Sets a breakpoint that triggers when the specified object changes value (wires, signals, registers, and variables) or is written to (memories).</p>

<p><span style=""> <strong>Note:</strong>&#160;</span>You cannot create object breakpoints for analog objects.</p>

<p>The object specified as the argument must have read access for the breakpoint to be created. An error is printed if the object does not have read access. See <a href="Access_to_Digital_Simulation_Objects.html">Access to Digital Simulation Objects</a>.</p>

<p>See the &quot;Setting an Object Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code>
          <span>-pdname</span>
          <br />
        </code></td>
<td class="confluenceTd" colspan="1">
<p><br /></p>
</td>
<td class="confluenceTd" colspan="1">
<p>Set a breakpoint that triggers when the specified power domain changes status. If no options are<br />specified, simulation stops when the power domain is powered down or powered up. You can specify multiple power domain names.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>power_domain_name [power_domain_name ...]</code> <br /><code>[-isolation [-iso_disable | -iso_enable]]</code> <br /><code>[-pd_off]</code> <br /><code>[-pd_on]</code> <br /><code>[-pd_standby]</code> <br /><code>[-pd_trans]</code> <br /><code>[-retention [-sr_restore | -sr_save]]</code></td>
<td class="confluenceTd" colspan="1">
<p>The -pdname option has several sub-options that let you create power domain breakpoints that</p>

<p>trigger under specific conditions:</p>
<ul><li><code>-pd_off</code>&#8211;Stop when the power domain turns off.</li><li><code>-pd_on</code>&#8211;Stop when the power domain turns on.</li></ul>
<p>This option stops the simulation when the specified power domain has transitioned to the ON state or to the UNINITIALIZED state. The state of the power domain is UNINITIALIZED when the simulation is being controlled by active state conditions, and when the power domain is on but there are no active state conditions enabled to specify the nominal condition to which the domain should transition.</p>
<ul><li><code>-pd_standby</code>&#8211;Stop when the power domain enters standby mode.</li><li><code>-pd_trans</code>&#8211;Stop when the power domain transitions. The breakpoint triggers when the specified power domain starts transitioning from one nominal condition to a different nominal condition.</li><li><code>-isolation</code>&#8211;Stop when any isolation rule associated with the power domain is enabled or disabled.</li><li><code>-iso_disable</code>&#8211;Stop when any isolation rule associated with the power domain is disabled.</li><li><code>-iso_enable</code>&#8211;Stop when any isolation rule associated with the power domain is enabled.</li><li><code>-retention</code>&#8211;Stop when any state retention rule associated with the power domain saves or restores its variables.</li><li><code>-sr_restore</code>&#8211;Stop when any state retention rule associated with the power domain restores its variables.</li><li><code>-sr_save</code>&#8211;Stop when any state retention rule associated with the power domain saves its variables.</li></ul></td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-process </code> <code>process_name </code></p>
</td>
<td class="confluenceTd">
<p>Sets a breakpoint that triggers when the specified VHDL named process starts executing or when it resumes executing after a wait statement.</p>

<p>You must compile with <code>-linedebug</code> to enable the setting of process breakpoints.</p>

<p>See the &quot;Setting a Process Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-silent </code></p>
</td>
<td class="confluenceTd">
<p>Suppresses the display of the message that is printed when a breakpoint triggers.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-skip </code> <code>count </code></p>
</td>
<td class="confluenceTd">
<p>Tells the simulator to ignore the breakpoint for the first <code>count</code> times that it triggers.</p>

<p>You can use <code>-skip</code> to set a breakpoint on the<code> n</code> <span style=""> <sup>th</sup> </span> occurrence of an event; in particular, you can use it to get inside <code>for</code> loops.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code>
          <span>-pwr_mode_transition </span>
        </code></td>
<td class="confluenceTd" colspan="1"><code>
          <span>mode_transition_name mode_transition_name ...]</span>      </code></td>
<td class="confluenceTd" colspan="1">Stop when the specified power mode transition starts and ends.</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code>
          <span>-randomize</span>
          <br />
        </code></td>
<td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1">
<p>Sets a breakpoint in SystemVerilog randomize() method calls.</p>

<p>The SystemVerilog built-in randomize() function returns the value 1 for success or 0 for failure. A failure occurs because there are conflicts in the collection of constraints to solve or because a variable is over-constrained.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>-always] [object_name]</code></td>
<td class="confluenceTd" colspan="1">
<p>The <code>stop -create -randomize</code> command lets you set a breakpoint in randomize() method calls.<br />You can then use other Tcl commands, such as <code>deposit -constraint_mode</code>, <code>deposit -rand_mode</code>, <code>constraint</code>, and <code>run -rand_solve</code>, to debug the randomization failures. <br />By default, simulation stops at the end of randomize() calls when the call is about to return 0, or failure. If you include the <code>-always</code> option, simulation stops for all randomize() calls, regardless of the return status of the call.</p>

<p>You can include an <code>object_name</code> argument to stop the simulation in specific randomize() calls. The<br />argument can be a class name or a module name. The simulator stops on a failure in any call of<br />the randomize() method in the specified module or with the specified class name. If <code>-always</code> is<br />specified, the simulator stops in all calls to the randomize() method.<br />stop <code>-randomize</code> commands are supported for calls to class and scope randomize methods.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code>
          <span>-sr_rule</span>
          <br />
        </code></td>
<td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1">Stop when the specified state retention rule saves or restores its variables.</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>
<span>rule_name [rule_name ...] [-sr_save | -sr_restore]</span>
        </code></td>
<td class="confluenceTd" colspan="1">
<p>You can specify multiple state retention rule names.<br />The <code>-sr_rule</code> option has two sub-options:</p>
<ul><li><code>-sr_restore</code>: Stop only when the state retention rule restores its variables.</li><li><code>-sr_save</code>: Stop only when the state retention rule saves its variables.</li></ul></td>
</tr>
<tr><td class="confluenceTd" colspan="1"><span> <code>-subprogram</code> </span></td>
<td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1">
<p>Set a breakpoint that triggers when the specified VHDL subprogram or Verilog task or function is<br />called.</p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><br /></td>
<td class="confluenceTd" colspan="1"><code>
          <span>subprogram_name</span>
          <br />
        </code></td>
<td class="confluenceTd" colspan="1">
<p>You must compile with the <code>-linedebug</code> option to enable the setting of subprogram breakpoints.</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><br /></p>
</td>
<td class="confluenceTd">
<p><code>-time time_spec </code> <br /><code>[-absolute]</code> <br /><code>[-relative]</code> <br /><code>[-start  time_spec]</code> <br /><code>[-modulo time_spec]</code></p>
</td>
<td class="confluenceTd">
<p>Sets a breakpoint that triggers at the specified time. The time can be absolute or relative (the default). Absolute time breakpoints are automatically deleted after they trigger. Relative time breakpoints are periodic, stopping, for example, every 10 ns.</p>

<p>The digital solver is always active when the simulator stops for a time breakpoint.</p>

<p>Use <code>-start</code> to specify the absolute simulation time at which a relative time breakpoint is to begin firing. If this time is before the current simulation time, the first stop occurs at the next future time at which it would have occurred had the stop been set at the time specified with <code>-start.</code></p>

<p>The <code>-modulo</code> option is similar to -<code>start</code>. Use <code>-modulo</code> to specify the absolute simulation time of the first stop time for a repeating stop. This differs from <code>-start</code> only when the given time is more than one repeat interval in the future. In this case, the first stop occurs at a time less than or equal to one interval in the future such that a stop eventually occurs at the given time. For example, if you set a time breakpoint to stop the simulation every 100 ns, and specify <code>-modulo 250</code>, the simulation stops at time 50, 150, 250, and so on.</p>

<p>When you execute a <code>save -environment</code> command to save your debug environment, this option is written to the script to restore your time breakpoint pattern.</p>

<p>See the &quot;Setting a Time Breakpoint&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd"><div class="content-wrapper">
<p><code>-disable </code></p>
<span class="confluence-anchor-link" id="stop-disable"></span></div>
</td>
<td class="confluenceTd">
<p>{<code>break_name</code>|<code>pattern</code>} ...</p>
</td>
<td class="confluenceTd">
<p>Disables the breakpoints specified by the argument without deleting them. See the &quot;Disabling, Enabling, Deleting, and Displaying Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd"><div class="content-wrapper">
<p><code>-enable </code></p>
<span class="confluence-anchor-link" id="stop-enable"></span></div>
</td>
<td class="confluenceTd">
<p>{<code>break_name</code>|<code>pattern</code>} ...</p>
</td>
<td class="confluenceTd">
<p>Enables the previously disabled breakpoints specified by the argument. See the &quot;Disabling, Enabling, Deleting, and Displaying Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd"><div class="content-wrapper">
<p><code>-delete </code></p>
<span class="confluence-anchor-link" id="stop-delete"></span></div>
</td>
<td class="confluenceTd">
<p>{<code>break_name</code>|<code>pattern</code>} ...</p>
</td>
<td class="confluenceTd">
<p>Deletes the breakpoints specified by the argument. See the &quot;Disabling, Enabling, Deleting, and Displaying Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
<tr><td class="confluenceTd"><div class="content-wrapper">
<p><code>-show </code></p>
<span class="confluence-anchor-link" id="stop-show"></span></div>
</td>
<td class="confluenceTd">
<p>[{<code>break_name</code>|<code>pattern</code>} ...]</p>
</td>
<td class="confluenceTd">
<p>Shows the status of the breakpoints specified by the argument. If no breakpoint is specified, all breakpoints are shown. See the &quot;Disabling, Enabling, Deleting, and Displaying Breakpoints&quot; section of the &quot;Debugging Your Design&quot; chapter in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more information.</p>
</td>
</tr>
</tbody></table></div>
<h3 id="stop-Example">Example</h3>
<h4 id="stop-ObjectBreakpoints">Object Breakpoints</h4>

<p>The following command creates a breakpoint that stops simulation when<code> sum </code>changes value. The <code>-create</code>&#160;modifier is not required. Because the&#160;<code>-name</code>&#160;option is not included to specify a breakpoint name, <code>xmsim</code>&#160;assigns a sequential number as the name. This breakpoint is called <code>1.</code></p>

<p><code> xcelium&gt; stop -create -object sum</code> <br /><code>Created stop 1 </code></p>

<p>The following command creates a breakpoint named <code>mybreak</code>&#160;that stops simulation when <code>sum</code>&#160;changes value.</p>

<p><code> xcelium&gt; stop -object sum -name mybreak</code> <br /><code>Created stop mybreak</code></p>

<p>The following command creates a breakpoint that stops simulation when&#160;<code>EEnet_net1</code>&#160;changes value.</p>

<p><code>xcelium&gt; stop -object EEnet_net1&#160;</code> <br /><code>Created stop 1</code> <br /><code>xcelium&gt; run 5 ns</code> <br /><code>0 FS + 1 (stop 1: top.EEnet_net1 = &#39;{V:4.9505, I:0, R:99.0099})</code></p>

<p>The following command creates a breakpoint that stops simulation when resolution function value&#160;changes. <code>net1</code> is a user defined nettype that has a user defined resolution function.</p>

<p><code>xcelium&gt; stop -create -at_resfunc top.net1</code><br /><code>Created stop 1</code><br /><code>xcelium&gt; run<br /></code><br /><code>50 NS + 1 (stop 1: Resolution Function udt_package::Tavg)</code><br /><code>resolving net: top.net1</code></p>

<p>The following command creates a breakpoint that triggers when <code>sum</code>&#160;changes value. The breakpoint is ignored the first 3 times it triggers.</p>

<p><code> xcelium&gt; stop -object sum -skip 3 </code></p>

<p>The following command creates a breakpoint that stops simulation when <code>clr</code>&#160;changes value. The&#160;<code>value data</code>&#160;command is executed when the breakpoint triggers. Because the <code>value</code>&#160;command requires an argument, it must be enclosed in curly braces.</p>

<p><code> xcelium&gt; stop -object clr -execute {value data} </code></p>

<p>The following command creates a breakpoint that triggers when <code>clr</code>&#160;changes value. The <code>value data</code>&#160;command is executed when the breakpoint triggers. The <code>-continue</code>&#160;option prevents the simulator from entering interactive mode every time the stop triggers.</p>

<p><code> xcelium&gt; stop -object clr -execute {value data} -continue </code></p>

<p>The following command creates an object breakpoint that triggers when<code> data </code>changes value. The <code>-delbreak</code>&#160;option specifies that the breakpoint is deleted after it triggers three times.</p>

<p><code> xcelium&gt; stop -object data -continue -delbreak 3 </code></p>

<p>The following command creates a breakpoint that triggers when <code>clk</code>&#160;changes value, but only if <code>clk</code>&#160;is high. See&#160;<a href="#stop-1035041">Tcl Expressions as Arguments&#160;</a>for details on the syntax of the argument to the <code>-if</code>&#160;option.</p>

<p><code> xcelium&gt; stop -object clk -if {#clk == 1} -continue </code></p>

<p>The following command creates a breakpoint that triggers when<code> data[1] </code>has the value<code> 1 </code>and the time becomes greater than 3 ns.</p>

<p><code> stop -object data -if {#data[1] == 1 &amp;&amp; [time ns -nounit] &gt; 3}</code></p>

<p>The following command shows the error message that is displayed if you run in regression mode and then try to set an object breakpoint on an object that does not have read access.</p>

<p><code> xcelium&gt; stop -object clk|</code> <br /><code>xmsim: *E,RDACRQ: Object does not have read access: hardrive.clk. </code></p>

<p>The following shows an error caused by trying to create a breakpoint on an analog object.</p>

<p><code> xcelium&gt; stop -object compSig</code> <br /><code>xcelium: *W,STALOB: Cannot set stop on analog object:</code> <br /><code> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.dac.compSig. This object ignored.</code> <br /><code>xmsim: *E,STOBEX: Object expected after -OBJECT</code> <br /><code> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;option of stop command. </code></p>
<h4 id="stop-LineBreakpoints">Line Breakpoints</h4>

<p>The following command creates a breakpoint that stops simulation when line number 10 in the current debug scope is about to execute.</p>

<p><code> xcelium&gt; stop -line 10 </code></p>

<p>The following command creates a breakpoint that stops simulation when line number 13 in scope <code>counter</code>&#160;is about to execute.</p>

<p><code> xcelium&gt; stop -line 13 counter </code></p>

<p>In the following command, the <code>-all</code>&#160;option specifies that the stop is noninstance-specific. The breakpoint occurs on all scopes which are instances of the same module. For example if there are two instances of module <code>m16</code>, as follows:</p>

<p><code> module board;</code> <br /><code>&lt;declarations&gt;m16 counter1 (...);</code> <br /><code>m16 counter2 (...);</code> <br /><code>&lt;code&gt;</code> <br /><code>endmodule</code></p>

<p>the breakpoint triggers when line 13 in either <code>counter1</code>&#160;or <code>counter2 </code>is about to execute.</p>

<p><code> xcelium&gt; stop -line 13 counter1 -all </code></p>

<p>The following command is equivalent to the command shown in the previous example. Both commands create non-instance-specific breakpoints.</p>

<p><code> xcelium&gt; stop -line 13 -unit m16 </code></p>

<p>In the following example, the <code>-file</code>&#160;option specifies which of the source files that make up the given scope (or the debug scope if none is given) contains the specified line. This is necessary if the scope has multiple source files.</p>

<p><code> xcelium&gt; stop -line 13 counter -file foo.v </code></p>
<h4 id="stop-TimeBreakpoints">Time Breakpoints</h4>

<p>The following command creates a breakpoint that stops simulation at absolute time 200 ns. The breakpoint is automatically deleted after it triggers.</p>

<p><code> xcelium&gt; stop -time 200 ns -absolute </code></p>

<p>The following command creates a repetitive breakpoint that stops the simulation every 200 ns and then executes the <code>value</code>&#160;command. The&#160;<code>-relative</code>&#160;option is the default for time breakpoints.</p>

<p><code> xcelium&gt; stop -time 200 ns -relative -execute {value data} </code></p>

<p>The following command creates a repetitive breakpoint that stops the simulation every 200 ns. The&#160;<code>-start</code>&#160;option specifies the absolute time at which the breakpoint starts. For example, if the current simulation time is 300 ns, the breakpoint stops the simulation at time 600, 800, 1000, and so on.</p>

<p><code> xcelium&gt; stop -time 200 ns -start 600 ns </code></p>

<p>In the following example, the current simulation time is 300 ns. The absolute time specified with <code>-start</code>&#160;is before the current simulation time. The first stop occurs at the next future time at which it would have occurred had the stop been set at the time specified with&#160;<code>-start</code>. In this example, the first stop occurs at time 450 ns.</p>

<p><code> xcelium&gt; stop -time 200 ns -start 250 ns </code></p>

<p>The following example shows how the <code>-modulo</code>&#160;option is used to save a breakpoint pattern. Suppose that you simulate to time 300 ns and then set a repetitive breakpoint with the following command:</p>

<p><code> xcelium&gt; stop -time 200 ns -start 350 ns </code></p>

<p>This command stops the simulation at time 350, 550, 750, and so on. If you then execute a <code>save -environment</code>&#160;command to save your debug environment, the following line is written to the script:</p>

<p><code> stop -create -name 1 -time 200 NS -relative -modulo 950 NS </code></p>

<p>If you then exit and re-enter the simulation and source the script containing this command, the breakpoint pattern is re-established. In this example, if you restart the simulation and start at time 0, the breakpoint triggers the first time at time 150. It then triggers at 350, 550, 750, and so on.</p>

<p>The following command includes the <code>-if</code>&#160;option to set a breakpoint at time 100 ns (relative) if <code>data[1]</code>&#160;has the value <code>1.</code></p>

<p><code> xcelium&gt; stop -time 100 ns -if {#data[1] == 1} </code></p>
<h4 id="stop-DeltaBreakpoints">Delta Breakpoints</h4>

<p>The following command creates a breakpoint that stops the simulation when it reaches 20 delta cycles. The breakpoint is automatically deleted after it triggers.</p>

<p><code> xcelium&gt; stop -delta 20 -absolute </code></p>

<p>The following command creates a repetitive breakpoint that stops the simulation every 10 delta cycles. The <code>-start</code>&#160;option specifies the absolute delta cycle at which the breakpoint starts. For example, if the current delta cycle count is 0, the breakpoint stops the simulation when the delta cycle count is 30, 40, 50, and so on.</p>

<p><code> xcelium&gt; stop -delta 10 -start 30 </code></p>
<h4 id="stop-ConditionBreakpoints">Condition Breakpoints</h4>

<p>In a condition breakpoint, the argument to the <code>-condition</code>&#160;option is a Tcl expression. See&#160;<a href="#stop-1035041">Tcl Expressions as Arguments</a>.</p>

<p>The following command sets a condition breakpoint that stops the simulation when <code>count</code>, the output of a 32-bit counter, has the value 100, decimal. The signal <code>count</code>&#160;is available from the top level of the hierarchy.</p>

<p><code> Verilog: xcelium&gt; stop -condition {[value %d top.count] = 100}</code> <br /><code>VHDL: xcelium&gt; stop -condition {[value %d :count] = 100}</code></p>

<p>If you are currently at the top level, you can omit the hierarchical path specification to<code> count </code>, and the two commands shown in the previous example could be written as follows:</p>

<p><code> xcelium&gt; stop -condition {[value %d count] = 100} </code></p>

<p>The<code> value </code>command uses the value of the <code>vlog_format </code>(or<code> vhdl_format</code>) variable. If you set the value of this variable to<code> %d</code>, the command shown in the previous example could be written as follows:</p>

<p><code> xcelium&gt; stop -condition {[value count] = 100} </code></p>

<p>Instead of using the<code> value </code>command to get the value of <code>count</code>&#160;into the expression evaluator, you can use <code>#count</code>. Include the format specifier after the # sign.</p>

<p><code> xcelium&gt; stop -condition {#%dcount = 100} </code></p>

<p>For Verilog, you can use the standard notation (for example<code> 4&#39;b0011</code>). For example, you can set the breakpoint on <code>count</code>&#160;as follows:</p>

<p><code> xcelium&gt; stop -condition {#count = 32&#39;d100}</code> <br /><code>xcelium&gt; stop -condition {#count = 32&#39;b00000000000000000000000001100100}</code></p>

<p>VHDL does not have the same type of notation. Vectors must be enclosed in quotation marks, as shown in the next example.</p>

<p><code> xcelium&gt; stop -condition {#count = &quot;00000000000000000000000001100100&quot;} </code></p>

<p>The following command sets a condition breakpoint that stops the simulation when bit 0 of<code> count </code>is 1. The expression is evaluated when any bit of<code> count </code>changes value. For VHDL, single-bit entities must be enclosed in single quotation marks.</p>

<p><code> Verilog: xcelium&gt; stop -condition {#count[0] == 1}</code> <br /><code>VHDL: xcelium&gt; stop -condition {#count(0) == `1&#39;}</code></p>

<p>The following command is identical to the previous command. An explicit <code>value</code>&#160;command is used to get the value of <code>count</code>&#160;(bit 0) into the expression parser.</p>

<p><code> Verilog: xcelium&gt; stop -condition {[value %b count[0]] == 1&#39;b1}</code> <br /><code>VHDL: xcelium&gt; stop -condition {[value %b count(0)] == `1&#39;}</code></p>

<p>In the following command, the <code>-if</code>&#160;option is used to conditionalize the condition breakpoint. This breakpoint stops the simulation at the next positive edge of the clock if <code>en1</code>&#160;or <code>en2</code>&#160;is 1.</p>

<p><code> Verilog: xcelium&gt; stop -condition {#clock == 1} -if {#en1 || #en2}</code> <br /><code>VHDL: xcelium&gt; stop -condition {#clk_n == &#39;1&#39;}</code> <br /><code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-if {#enable==&#39;1&#39;|| #reset_n==&#39;1&#39;}</code></p>

<p>The following command stops the simulation at 5 ns (absolute time). After that, <code>clock</code>&#160;changes depending on the condition in the <code>if</code>&#160;expression, and this happens repeatedly every 5 ns. The<code> -continue </code>option is used to prevent the simulation from stopping every time the breakpoint triggers. VHDL requires use of the single quotation marks.</p>

<p><code> xcelium&gt; stop -time 5 ns -start 5 ns<br />&#160;&#160;&#160;&#160;-execute {if {#clk == &#39;0&#39;} {force clk &#39;1&#39;}<br />&#160;&#160;&#160;&#160;else {force clk &#39;0&#39;}} -continue </code></p>
<h4 id="stop-ProcessBreakpoints">Process Breakpoints</h4>

<p>The following command sets a breakpoint that stops the simulation whenever the process called<code> :load_action </code>is executed.</p>

<p><code> xcelium&gt; stop -process :load_action </code></p>
<h4 id="stop-ExamplesofOtherstopCommandModifiers">Examples of Other stop Command Modifiers</h4>

<p>The following command sequence illustrates the<code> -show </code>modifier. The first command creates a source line breakpoint called <code>break1</code>; the second creates an object breakpoint called&#160;<code>break2</code>. The third command shows the status of the two breakpoints.</p>

<p><code> xcelium&gt; stop -line 12 -name break1<br />Created stop break1<br />xcelium&gt; stop -object data -name break2<br />Created stop break2<br />xcelium&gt; stop -show<br />break1  Enabled         Line: ./shortdrive.v:12 (scope: top)<br />break2  Enabled         Object top.data<br />xcelium&gt; </code></p>

<p>In the following command sequence, breakpoint <code>break1</code>&#160;is first disabled with the <code>-disable</code>&#160;modifier and then enabled with the -<code>enable</code>&#160;modifier.</p>

<p><code> xcelium&gt; stop -show<br />break1  Enabled         Line: ./shortdrive.v:12 (scope: top)<br />break2  Enabled         Object top.data<br />xcelium&gt; stop -disable break1<br />xcelium&gt; stop -show<br />break1  Disabled        Line: ./shortdrive.v:12 (scope: top)<br />break2  Enabled         Object top.data<br />xcelium&gt; stop -enable break1<br />xcelium&gt; </code></p>

<p>The following command deletes breakpoint <code>break1.</code></p>

<p><code> xcelium&gt; stop -delete break1 </code></p>

<p>To disable, enable, or delete the two breakpoints <code>break1</code>&#160;and <code>break2</code>, any of the following commands could be used.</p>

<p><code> xcelium&gt; stop -delete *1 *2</code> <br /><code>xcelium&gt; stop -delete break?</code> <br /><code>xcelium&gt; stop -delete br*</code></p>

<p>The following command displays information on any breakpoint beginning with <code>v</code>&#160;or <code>b.</code></p>

<p><code> xcelium&gt; stop -show {[vb]*} </code></p>
<h3 id="stop-1035041TclExpressionsasArguments"><span class="confluence-anchor-link" id="stop-1035041"></span>Tcl Expressions as Arguments</h3>

<p>The<code> stop </code>command has two options that let you specify conditions. Both options require a Tcl expression argument.</p>
<ul><li><code> -condition<br /> </code>This option specifies that you are creating a condition breakpoint, as opposed to some other kind of breakpoint, such as a time or object breakpoint. A condition breakpoint triggers when any digital object named in the Tcl expression has an event that would trigger an object breakpoint and the expression evaluates to non-zero, non-x, or non-z. Although condition breakpoints are not triggered by changes in analog objects, you can include analog objects in the conditional expression and their values are used when the condition is evaluated (due to a digital object changing value).</li></ul><ul><li><code> -if<br /> </code>This option can be used with any breakpoint type, including condition breakpoints. The Tcl expression argument is evaluated, and the stop triggers if the expression evaluates to non-zero, non-x, or non-z.</li></ul>
<p>There are two general rules to keep in mind when writing the Tcl expression:</p>
<ul><li>
<p>Enclose the expression in braces to suppress immediate substitution of values.<br /><span style="">{<code>tcl_expression</code>}</span></p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>If you are using the SimVision environment, these braces are included on the Set Break form.</p>
</div>
</div>

<p>In the following example, the value of <code>w[1]</code>&#160;would be substituted with its current value (<code>1&#39;bx</code>, for example) if there were no braces. No object would be named in the expression by the time the<code> stop </code>command routine sees it, resulting in an error.<br /><code>xcelium&gt; stop -condition #w[1] == 1</code> <br /><code>  xcelium&gt; stop -condition {#w[1] == 1}</code></p>
</li></ul><ul><li>You must use either an explicit<code> value </code>command or the # character to get the object&#39;s value into the expression parser because the parser does not understand names. For example, the following command generates an error message.<br /><code>xcelium&gt; stop -time 100 ns -if {r[1] == 1}</code> <br /><code> Use the following commands:</code> <br /><code> Verilog:</code> <br /><code>  xcelium&gt; stop -time 100 ns -if {[value r[1]] == 1&#39;b1}</code> <br /><code>  xcelium&gt; stop -time 100 ns -if {#r[1] == 1}</code> <br /><code>  VHDL:</code> <br /><code>  xcelium&gt; stop -time 100 ns -if {[value r(1)] == `1&#39;}</code> <br /><code>  xcelium&gt; stop -time 100 ns -if {#r(1) == `1&#39;</code>}</li></ul>
<p>Format specifiers can be used with either the <code>value</code>&#160;command or the # sign. If you use the # sign, place the format specifier after the # sign. For example,</p>

<p>Verilog:</p>

<p><code> xcelium&gt; stop -condition {[value %d out] = 12}</code> <br /><code>xcelium&gt; stop -condition {#%dout = 12}</code></p>

<p>VHDL:</p>

<p><code> xcelium&gt; stop -condition {[value %d out] = 12}</code> <br /><code>xcelium&gt; stop -condition {#%dout = 1}</code></p>

<p>For VHDL, you must enclose vectors in quotation marks and single-bit entities in single quotation marks. For example,</p>

<p><code> Verilog: xcelium&gt; stop -condition {#clock == 1}</code> <br /><code>VHDL: xcelium&gt; stop -condition {#clock == `1&#39;}</code></p>

<p><code> Verilog: xcelium&gt; stop -condition {#count = 4&#39;b0101}</code> <br /><code>VHDL: xcelium&gt; stop -condition {#clock = &quot;0101&quot;}</code></p>

<p>See the &quot;Basics of Tcl&quot; appendix in<em> <span style=""> Cadence Verilog Simulation User Guide </span> </em>for more details on basic Tcl syntax and on the extensions to Tcl that have been added to handle types and operators of the Verilog and VHDL hardware description languages.</p>

<p>For RNM nets, the following command creates a conditional on-change break when <code>top.rnmnet</code> changes to <code>`wrealXState</code>:</p>

<p><code>stop -create -object -if {#top.rnmnet = &quot;`wrealXState&quot;} top.rnmnet</code></p>

                    </div>
<br /><br /></div>
<footer xmlns:html="http://www.w3.org/1999/xhtml"><nav class="navigation"><b><em><a href="status.html" id="prev" title="status">status</a></em></b><b><em><a href="strobe.html" id="nex" title="strobe">strobe</a></em></b></nav><div>
          For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved.
        </div>
</footer><br xmlns:html="http://www.w3.org/1999/xhtml" />
<div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160;&#10240;</center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div>

</body></html>