
<html><head><title>Specifying User-Defined Nettype and Resolution Function</title>
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="jaini" />
<meta name="CreateDate" content="2023-03-01" />
<meta name="CreateTime" content="1677669021" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Describes the Virtuoso AMS Designer simulator and Xcelium Simulator with mixed-signal option that supports the Verilog-AMS,  VHDL-AMS, and SystemVerilog-AMS language standards." />
<meta name="DocTitle" content="Spectre AMS Designer and Xcelium Simulator Mixed-Signal User Guide" />
<meta name="DocType" content="User Guide" />
<meta name="FileTitle" content="Specifying User-Defined Nettype and Resolution Function" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="task" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="Digital Mixed-Signal,Digital Mixed-Signal,Digital Mixed-Signal," />
<meta name="prod_subfeature" content="SystemVerilog Real Number Modeling, User-Defined Nettypes, Wreal/Real Nets," />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="" />
<meta name="FileType" content="Chapter" />
<meta name="Keyword" content="ams_dms_simug" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-03-01" />
<meta name="ModifiedTime" content="1677669021" />
<meta name="NextFile" content="Resolving_Wreal_Nets_of_Built-In_Nettype.html" />
<meta name="Group" content="Mixed-Signal Simulation" />
<meta name="Platform" content="Functional Verification," />
<meta name="PrevFile" content="Specifying_Built-In_SystemVerilog_Nettypes.html" />
<meta name="c_product" content="Xcelium," />
<meta name="Product" content="Xcelium," />
<meta name="ProductFamily" content="Xcelium," />
<meta name="ProductVersion" content="22.09" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Spectre AMS Designer and Xcelium Simulator Mixed-Signal User Guide -- Specifying User-Defined Nettype and Resolution Function" />
<meta name="Version" content="22.09" />
<meta name="Renderer" content="WIKI" />
<meta name="SpaceKey" content="amssimug2209" />
<meta name="confluence-version" content="7.4.1" />
<meta name="ecms-plugin-version" content="04.10.026" />

        
        <link href="styles/site.css" rel="stylesheet" type="text/css" />
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    

    
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    document.querySelectorAll("img").forEach((img, index) => {
   img.addEventListener("click", (e) => { 
    document.querySelector("#cad_image_modal").classList.add("opac");
      document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0; margin: auto;max-height: 96%;max-width: 96%;" src="${e.target.src}">`;});});});
</script>

<style>
 img{cursor:pointer;
 }
 #cad_image_modal{
 position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;
 }
 #cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;
 }
 #cad_image_modal span{
  position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;
 }
 </style>

</head><body style="background-color: #FFFFFF;"><!-- Begin Buttons --><header xmlns:html="http://www.w3.org/1999/xhtml"><div class="docHeadr">Product Documentation<img src="images/Cadence-Logo.jpg" /></div>
<nav class="blueHead"><ul><li><a class="content" href="ams_dms_simugTOC.html">Contents</a></li><li><a class="prev" href="Specifying_Built-In_SystemVerilog_Nettypes.html" title="Specifying_Built-In_SystemVerilog_Nettypes">Specifying_Built-In_SystemVeri ...</a></li><li style="float: right;"><a class="viewPrint" href="ams_dms_simug.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="Resolving_Wreal_Nets_of_Built-In_Nettype.html" title="Resolving_Wreal_Nets_of_Built-In_Nettype">Resolving_Wreal_Nets_of_Built- ...</a></li></ul></nav></header><!-- End Buttons --><div xmlns:html="http://www.w3.org/1999/xhtml" style="font-size:14px;line-height:1.42857142857;margin:20px 0 0 0;font-weight:bold;"><center>Spectre AMS Designer and Xcelium Simulator Mixed-Signal User Guide<br />Product Version 22.09, September 2022</center></div>
<div xmlns:html="http://www.w3.org/1999/xhtml" style="margin-left:5%;">
<p></p>

<p></p>
<div id="main-header">
                    
                    
                                                <h1 style="margin: 4px 0 4px;"><span>Specifying User-Defined Nettype and Resolution Function</span></h1>

                    
                </div>
<div class="wiki-content group" id="main-content">
                    
<p><span class="confluence-anchor-link" id="SpecifyingUserDefinedNettypeandResolutionFunction-user_defined_nettype"></span><span class="confluence-anchor-link" id="SpecifyingUserDefinedNettypeandResolutionFunction-1066573"></span>Like the built-in real SV nettype, a user-defined nettype (UDN) is declared with the keyword<code style="letter-spacing: 0.0px;">&#160;nettype</code>, and includes a data type and optionally a resolution function. For example, the following declares a user-defined nettype&#160;<code style="letter-spacing: 0.0px;">wTsum</code>&#160;with data type&#160;<code style="letter-spacing: 0.0px;">T</code>:</p>

<p><code>nettype T wTsum;</code></p>

<p>Here,&#160;<code>T&#160;</code>is a&#160;<code>struct</code>&#160;data type with real fields. For example:</p>

<p><code>typedef struct {</code><br /><code>&#160; &#160; real field1;</code><br /><code>&#160; &#160; real field2;</code></p>

<p><code>} T;</code></p>

<p>The valid data types for the nettypes are scalar reals and unpacked structures containing real, logic, bit, integer, and enum data types. Static arrays of unpacked structure nettype with or without resolution functions are supported. Other data types are not supported.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>To use <code>longint</code> and <code>shortreal</code> datatypes in structured UDNs, you must use the <code>-extended_struct_UDN</code> option.</p>
</div>
</div>

<p>Use the&#160;<code>with</code>&#160;keyword to optionally specify a resolution function to resolve the driven value of nets of user-defined nettype, as shown below.</p>

<p><code>nettype T wTsum with Tsum;</code></p>

<p>The resolution function of a nettype with a data type&#160;<code>T&#160;</code>is an SV function with a return type of&#160;<code>T.</code>&#160;The function has a single input argument whose type is a dynamic array of elements of type&#160;<code>T.</code>&#160;A resolution function neither resizes the dynamic array input argument nor writes to any part of it.</p>

<p>Calls to only the following system tasks or functions are supported inside the resolution function:</p>
<div class="table-wrap"><table class="wrapped relative-table confluenceTable" style="width: 33.6611%;"><colgroup><col style="width: 35.4561%;" /><col style="width: 26.8503%;" /><col style="width: 37.6936%;" /></colgroup><tbody><tr><td class="confluenceTd">
<p><code>$bitstoreal </code></p>
</td>
<td class="confluenceTd">
<p><code>$realtobits </code></p>
</td>
<td class="confluenceTd">
<p><code>$signed </code></p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><code>$cast </code></p>
</td>
<td class="confluenceTd">
<p><code>$rtoi </code></p>
</td>
<td class="confluenceTd">
<p><code>$itor </code></p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><code>$time </code></p>
</td>
<td class="confluenceTd">
<p><code>$realtime </code></p>
</td>
<td class="confluenceTd">
<p><code>$display </code></p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><code>$fdisplay </code></p>
</td>
<td class="confluenceTd">
<p><code>$fwrite </code></p>
</td>
<td class="confluenceTd">
<p><code>$bits </code></p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><code>$size </code></p>
</td>
<td class="confluenceTd">
<p><code>$left </code></p>
</td>
<td class="confluenceTd">
<p><code>$right </code></p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><code>$high </code></p>
</td>
<td class="confluenceTd">
<p><code>$increment </code></p>
</td>
<td class="confluenceTd">
<p><code>$fatal </code></p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><code>$warning </code></p>
</td>
<td class="confluenceTd">
<p><code>$info </code></p>
</td>
<td class="confluenceTd">
<p><code>$finish </code></p>
</td>
</tr>
<tr><td class="confluenceTd">
<p><code>$error </code></p>
</td>
<td class="confluenceTd">
<p><code>$dimension </code></p>
</td>
<td class="confluenceTd">
<p><code>$sformatf </code></p>
</td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code><span>$unsigned</span></code></td>
<td class="confluenceTd" colspan="1"><code><span>$stime</span></code></td>
<td class="confluenceTd" colspan="1"><code><span>$write </span></code></td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code><span>$typename </span></code></td>
<td class="confluenceTd" colspan="1"><code><span>$low </span></code></td>
<td class="confluenceTd" colspan="1"><code><span>$resolved_wudn_name </span></code></td>
</tr>
<tr><td class="confluenceTd" colspan="1"><code><span>$resolved_wudn_drivers</span></code></td>
<td class="confluenceTd" colspan="1"><code><span>$test$plusargs</span></code></td>
<td class="confluenceTd" colspan="1"><code>$value$plusargs </code></td>
</tr>
</tbody></table></div>

<p>You can use the&#160;<code>-rnm_relax</code>&#160;option of&#160;<code>xrun</code>&#160;to access the global variables inside the resolution functions.</p>

<p>The <code style="letter-spacing: 0.0px;">$resolved_wudn_name()</code>&#160;system task returns a string containing the hierarchical name of the simulated user-defined nettype(UDN) being simulated.&#160;It always returns the highest level of the net-segment in the following situations: explicitly typed UDN, interconnect (explicit) type, and wire (implicit interconnect) type. It can take a single string argument that is a hierarchical scope. If no scope is given it returns the name of the top-most net that is part of the collapsed net by traversing upwards. If a scope is given it will no traverse past that scope and will return a hierarchical net name that is at that scope or below.&#160;</p>

<p>Unpacked arrays of nets of user-defined nettype (both with and without user-defined resolution functions) are supported. For unpacked arrays of nets of user-defined nettype, each element of the array is considered as an atomic net.</p>

<p>Array sliced and concatenated connections to user-defined nettype with user-defined resolution function and nettype module ports are supported (see examples below).</p>

<p><code>$resolved_wudn_drivers()</code>&#160;takes the driver array and an index and returns a string for the driver name.</p>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>Declaring a packed, multi-dimensional, or dynamic array of nets of user-defined nettype results in an error.</p>
</div>
</div>

<p>The resolution function of any net of a user-defined nettype is activated at time 0 at least once. This activation occurs even for nets with no drivers or when there is no value change on the drivers at time 0.</p>

<p>If a net has been defined as an unpacked array of nets (and&#160;<code>nettype</code>&#160;is defined at the element level), the resolution function is invoked for each element of the array. This means that if the array has five elements, the resolution function will be invoked five times at 0 simulation time.</p>

<p>The initial value of a net with a user-defined nettype is set before an&#160;<code>initial</code>&#160;or<code>&#160;always&#160;</code>procedure is started and before the activation of the time 0 resolution call. If no initializer is applied, the default initialization value for a net with a user-defined nettype is the default value defined by the data type. For a net with a user-defined nettype of&#160;<code>struct</code>&#160;data type, any initialization expressions for the members within&#160;<code>struct</code>&#160;are applied.</p>

<p>Assignment to nets of user-defined nettype is done using continuous assignments. Continuous assignments can be made with a declaration assignment or a continuous assignment statement.</p>

<p>A continuous assignment to an atomic net cannot drive a part of the net; it drives the entire net as per its nettype. Therefore, the left-hand side of a continuous assignment to a net of a user-defined nettype does not contain any indexing or select operations to the data type of&#160;<code>nettype.</code>&#160;In case of arrays of nets of user-defined nettype, indexing is done on the complete array because&#160;<code>nettype</code>&#160;is defined at the element level and not at the array level. However, no value can be written to the member of the element of the structure through the assignment statements targeting that member explicitly. For example:</p>

<p><code>assign dr_1[0] = T&#39;{0.5, 0.5}; // legal assignment</code><br /><code>assign dr_1 = &#39;{T&#39;{0.5, 0.5}, T&#39;{2.3,3.4}}; // legal assignment</code><br /><code>assign dr_1[0].field1 = 0.5 ; // illegal assignment</code></p>

<p>Assignment delays and net declaration delays are supported on the nets of user-defined nettypes and static arrays of unpacked structure nettype.</p>

<p>If the internal and external connections of a port are nets of user-defined nettypes and they are of matching nettype, they are merged into a single simulated net. Otherwise, an error is generated. If only one of the two connections is a net of user-defined nettype, then the connections must have matching data types; the port must be input or output, and the connection is treated as a continuous assignment from source to sink.</p>

<p>The following Tcl commands are supported on the user-defined nets and static arrays of unpacked structure nettype:</p>
<ul><li><code>describe</code></li></ul><ul><li><code>value</code></li></ul><ul><li><code>drivers</code></li></ul><ul><li><code>deposit</code></li></ul><ul><li><code>probe -screen</code></li></ul><ul><li><code>probe -shm</code></li></ul>
<p>SV-RNM (built-in SV nettypes and user-defined nettypes) is supported for the following in the AMS-CPF flow:</p>
<ul><li>Built-in SV-wreal nettypes defined in&#160;<code>cds_rnm_package</code>. For example ,&#160;<code>wreal1driver</code>,&#160;<code>wreal4state</code>,&#160;<code>wrealmin</code>,&#160;<code>wrealmax</code>,&#160;<code>wrealsum</code>, and&#160;<code>wrealavg</code>.</li></ul><ul><li>SV-RNM interconnect nets that coerce to SV-wreal.</li></ul><ul><li>User-defined nettypes with built-in resolution functions. Following built-in resolution functions are supported:</li></ul><ul><li><code>CDS_res_wreal1driver</code></li></ul><ul><li><code>CDS_res_wreal4state</code></li></ul><ul><li><code>CDS_res_wrealmin</code></li></ul><ul><li><code>CDS_res_wrealmax</code></li></ul><ul><li><code>CDS_res_wrealsum</code></li></ul><ul><li><code>CDS_res_wrealavg</code></li></ul><ul><li>Array of built-in wreal nettypes.</li></ul>
<p>SV-RNM is supported for the following CPF features:</p>
<ul><li>Creating power domain on blocks with real-valued signal</li></ul><ul><li>Power Smart IE selection</li></ul><ul><li>Interaction of power intent device and connect module</li></ul><ul><li>Power intent propagation on mixed-signal boundary</li></ul><ul><li>Dynamic compatibility check on mixed-signal boundary</li></ul><ul><li>Power corruption on a real-valued signal</li></ul><ul><li>IE power supply access from real-valued side</li></ul><ul><li>CPF-controlled SV-Wreal/Interconnect power supply</li></ul><ul><li>Real-valued signal driving a power event</li></ul><h4 id="SpecifyingUserDefinedNettypeandResolutionFunction-Examples"><span style=""><strong>Examples</strong></span></h4>

<p>Following is an example of arrays of net of structure nettypes without the resolution function:</p>

<p><code>// user-defined data type T</code></p>

<p><code>typedef struct {</code></p>

<p><code>&#160;&#160;&#160;&#160;real field1;</code><br /><code>&#160; &#160; real field2;</code></p>

<p><code>}T;</code></p>

<p><code>// A nettype declaration with data type and resolution function</code></p>

<p><code>nettype T wTsum;</code>&#160;</p>

<p><code>module top;</code><br /><code>wTsum w[2];</code><br /><code>T myvar[2];</code></p>

<p><code>assign myvar = w;</code><br /><code>driver1 d1(w);</code><br /><code>receiver1 r1(w);</code><br /><code>endmodule</code></p>

<p><code>module receiver1(rec_1);</code></p>

<p><code>output rec_1[2];</code><br /><code>&#160; &#160; wTsum rec_1[2];</code><br /><code>&#160; &#160; initial</code></p>

<p><code>&#160;&#160;&#160;&#160;#1 $display(&quot;sum = %p flag = %p \n&quot;, rec_1[0], rec_1[1]);</code></p>

<p><code>endmodule</code></p>

<p><code>module driver1 (dr_1);</code><br /><code>output dr_1[2];</code><br /><code>&#160; &#160; wTsum dr_1[2];</code><br /><code>&#160; &#160; assign dr_1[0] = T&#39;{0.5, 0.5};</code><br /><code>&#160; &#160; assign dr_1[1] = T&#39;{1.5, 1.5};</code></p>

<p><code>endmodule</code></p>

<p>Following is an example of arrays of net of structure nettypes with the resolution function:</p>

<p><code>// user-defined data type T</code></p>

<p><code>typedef struct {</code><br /><code>&#160; &#160; real field1;</code><br /><code>&#160; &#160; real field2;</code></p>

<p><code>}T;</code>&#160;</p>

<p><code>// user-defined resolution function Tsum</code><br /><code>function automatic T Tsum (input T driver[]);</code><br /><code>begin</code></p>

<p><code>&#160;&#160;&#160;&#160;Tsum.field1 = 0.0;</code><br /><code>&#160; &#160; foreach (driver[i])</code><br /><code>&#160; &#160; begin</code></p>

<p><code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$display(&quot;driver[%d]{%f, %f}&quot;,i, driver[i].field1, driver[i].field2);</code><br /><code>&#160; &#160; &#160; &#160; Tsum.field1 += driver[i].field1;</code><br /><code>&#160; &#160; &#160; &#160; Tsum.field2 += driver[i].field2;</code><br /><code>&#160; &#160; end</code></p>

<p><code>&#160;&#160;&#160;&#160;$display(&quot;Tsum{%f, %f}&quot;, Tsum.field1, Tsum.field2);</code></p>

<p><code>end</code></p>

<p><code>endfunction</code>&#160;</p>

<p><code>// A nettype declaration with data type and resolution function</code><br /><code>&#160; nettype T wTsum with Tsum;&#160;</code></p>

<p><code>module top;</code><br /><code>wTsum w[2];</code><br /><code>T myvar[2];</code></p>

<p><code>assign myvar = w;</code><br /><code>driver1 d1(w);</code><br /><code>driver2 d2(w);</code><br /><code>receiver1 r1(w);</code><br /><code>endmodule</code>&#160;</p>

<p><code>module receiver1(rec_1);</code></p>

<p><code>output rec_1[2];</code><br /><code>&#160; &#160; wTsum rec_1[2];</code><br /><code>&#160; &#160; initial</code></p>

<p><code>&#160;&#160;&#160;&#160;#1 $display(&quot;sum = %p flag = %p \n&quot;, rec_1[0], rec_1[1]);</code></p>

<p><code>endmodule</code>&#160;</p>

<p><code>module driver1 (dr_1);</code><br /><code>output dr_1[2];</code></p>

<p><code>&#160;&#160;&#160;&#160;wTsum dr_1[2];</code><br /><code>&#160; &#160; assign dr_1[0] = T&#39;{0.5, 0.5};</code><br /><code>&#160; &#160; assign dr_1[1] = T&#39;{1.5, 1.5};</code><br /><code>endmodule</code></p>

<p><code>module driver2 (dr_2);</code></p>

<p><code>input dr_2[2];</code></p>

<p><code>&#160;&#160;&#160;&#160;wTsum dr_2[2];</code><br /><code>&#160; &#160; assign dr_2[0] = T&#39;{2.5, 2.0};</code><br /><code>&#160; &#160; assign dr_2[1] = T&#39;{3.5, 3.0};</code></p>

<p><code>endmodule</code></p>

<p>Following is an example of a static array of unpacked structure nettype without resolution function:</p>

<p><code>module top;</code></p>

<p><code>typedef enum {ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX} enum_t;</code><br /><code>typedef struct {</code><br /><code>real r;</code><br /><code>integer i;</code><br /><code>bit b;</code><br /><code>enum_t e;</code><br /><code>} instruction;&#160;</code></p>

<p><code>nettype instruction net_r_inst;&#160;</code></p>

<p><code>instruction I1[0:3] = &#39;{instruction&#39;{1.0, 1, 1, ONE},instruction&#39;{2.0, 2, 1, TWO}, instruction&#39;{3.0, 3, 1, THREE}, instruction&#39;{4.0, 4, 1, FOUR}};</code></p>

<p><code>instruction I2[0:3] = &#39;{instruction&#39;{11.0, 11, 1, ONE},instruction&#39;{12.0, 12, 1, TWO}, instruction&#39;{13.0, 13, 1, THREE}, instruction&#39;{14.0, 14, 1, FOUR}};</code></p>

<p><code>net_r_inst I3[0:3] = &#39;{instruction&#39;{21.0, 21, 1, ONE},instruction&#39;{22.0, 22, 1, TWO}, instruction&#39;{23.0, 23, 1, THREE}, instruction&#39;{24.0, 24, 1, FOUR}};</code>&#160;</p>

<p><code>always @(I3[1].r) begin</code><br /><code>$display(&quot;\n(%f NS) =&gt; I3 with %%p = {%p}&quot;, $time, I3);</code><br /><code>$display(&quot;(%f NS) =&gt; I3[0].r = %f&quot;, $time(), I3[0].r);</code><br /><code>$display(&quot;(%f NS) =&gt; I3[1].r = %f&quot;, $time(), I3[1].r);</code><br /><code>$display(&quot;(%f NS) =&gt; I3[2].r = %f&quot;, $time(), I3[2].r);</code><br /><code>$display(&quot;(%f NS) =&gt; I3[3].r = %f&quot;, $time(), I3[3].r);</code><br /><code>end</code></p>

<p><code>endmodule</code></p>

<p>Following is an example of a static array of unpacked structure nettype with resolution function:</p>

<p><code>module top;</code></p>

<p><code>typedef enum {ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX} enum_t;</code><br /><code>typedef struct {</code></p>

<p><code>&#160; &#160;real r;</code><br /><code>&#160; &#160;integer i;</code><br /><code>&#160; &#160;bit b;</code><br /><code>&#160; &#160;enum_t e;</code><br /><code>} instruction;</code></p>

<p><code>function automatic instruction FUNC(input instruction drivers[]);</code></p>

<p><code>begin</code></p>

<p><code>FUNC = &#39;{1.1, 1, 0, ZERO} ;</code><br /><code>&#160; &#160; foreach (drivers[j]) begin</code><br /><code>&#160; &#160; &#160; &#160; &#160; &#160; FUNC.r += drivers[j].r;</code><br /><code>&#160; &#160; &#160; &#160; &#160; &#160; FUNC.i += drivers[j].i;</code><br /><code>&#160; &#160; &#160; &#160; &#160; &#160; FUNC.b = drivers[j].b ;</code><br /><code>&#160; &#160; &#160; &#160; &#160; &#160; FUNC.e = drivers[j].e ;</code><br /><code>&#160; &#160; &#160; &#160; end</code></p>

<p><code>end</code></p>

<p><code>endfunction&#160;&#160;</code></p>

<p><code>nettype instruction net_r_inst with FUNC;</code></p>

<p><code>instruction I1[0:3] = &#39;{instruction&#39;{1.0, 1, 1, ONE},instruction&#39;{2.0, 2, 1, TWO}, instruction&#39;{3.0, 3, 1, THREE}, instruction&#39;{4.0, 4, 1, FOUR}};</code></p>

<p><code>instruction I2[0:3] = &#39;{instruction&#39;{11.0, 11, 1, ONE},instruction&#39;{12.0, 12, 1, TWO}, instruction&#39;{13.0, 13, 1, THREE}, instruction&#39;{14.0, 14, 1, FOUR}};</code></p>

<p><code>net_r_inst I3[0:3] = &#39;{instruction&#39;{21.0, 21, 1, ONE},instruction&#39;{22.0, 22, 1, TWO}, instruction&#39;{23.0, 23, 1, THREE}, instruction&#39;{24.0, 24, 1, FOUR}};</code></p>

<p><code>assign I3 = I1 ;</code><br /><code>assign I3 = I2 ;&#160;</code></p>

<p><code>always @(I3[1].r) begin</code><br /><code>&#160; &#160; $display(&quot;\n(%f NS) =&gt; I3 with %%p = {%p}&quot;, $time, I3);</code><br /><code>&#160; &#160; $display(&quot;(%f NS) =&gt; I3[0].r = %f&quot;, $time(), I3[0].r);</code><br /><code>&#160; &#160; $display(&quot;(%f NS) =&gt; I3[1].r = %f&quot;, $time(), I3[1].r);</code><br /><code>&#160; &#160; $display(&quot;(%f NS) =&gt; I3[2].r = %f&quot;, $time(), I3[2].r);</code><br /><code>&#160; &#160; $display(&quot;(%f NS) =&gt; I3[3].r = %f&quot;, $time(), I3[3].r);</code></p>

<p><code>end</code></p>

<p><code>endmodule</code></p>

<p>Following is an example of SystemVerilog array slices for user-defined nettype port connection:</p>

<p><code>//Declaration of nettype</code></p>

<p><code>package multiple_drive_wire;&#160;</code></p>

<p><code>typedef struct{</code><br /><code>&#160; &#160; &#160; &#160; &#160; real x;</code><br /><code>&#160; &#160; &#160; &#160; &#160; real y;</code><br /><code>&#160; &#160; &#160; &#160; &#160; } user_wire;</code></p>

<p><code>function automatic user_wire resolve(user_wire driver[]);</code><br /><code>&#160; &#160; $display(&quot;Resolve&quot;);</code></p>

<p><code>&#160; &#160; foreach(driver[i])begin</code><br /><code>&#160; &#160; &#160;resolve.y += driver[i].x;</code><br /><code>&#160; &#160; &#160; &#160; end&#160;</code></p>

<p><code>endfunction // resolve</code></p>

<p><code>nettype user_wire user_wire_multi_drv with resolve;</code></p>

<p><code>endpackage // tb</code></p>

<p><code>//Declaration of module with nettype port</code><br /><code>module foo(inout user_wire_multi_drv a[1:0]);</code></p>

<p><code>&#160; &#160;real x1,x2;</code></p>

<p><code>&#160; &#160;assign a[0] = &#39;{x1,0};</code><br /><code>&#160; &#160;assign a[1] = &#39;{x2,0};</code></p>

<p><code>&#160; &#160;initial begin</code><br /><code>&#160; &#160; &#160; &#160; &#160; x1 = 0.00;</code><br /><code>&#160; &#160; &#160; &#160; &#160; x2 = 0.00;&#160;</code></p>

<p><code>for(int ii=0; ii &lt; 10; ii++)begin</code></p>

<p><code>&#160;&#160;&#160;&#160; x1 = 2.00*ii;</code><br /><code>&#160; &#160; &#160;x2 = 2.00*ii+1.00;</code><br /><code>&#160; &#160; &#160;#100;</code><br /><code>&#160; &#160; &#160; end</code></p>

<p><code>&#160; end</code></p>

<p><code>endmodule // foo</code></p>

<p>Modules with nettype ports using array slices can be connected using the following methods:</p>

<p><code>import multiple_drive_wire::*;</code></p>

<p><code>module top;</code></p>

<p><code>&#160; &#160;//interconnect bar[3:0]; --Standard declaration</code></p>

<p><code>&#160; &#160;//wire bar[3:0]; --Cadence RNM tech declaration (use -rnm_tech option to compile)</code></p>

<p><code>&#160; //user_wire_multi_drv bar[3:0]; --Explicit declaration</code></p>

<p><code>&#160; &#160; &#160;foo u0(.a(bar[1:0])); &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//array sliced port connect</code></p>

<p><code>&#160; &#160; &#160;foo u1(.a({bar[1],bar[0]})); //Concatenated Port Connect</code></p>

<p><code>endmodule // tb</code></p>
<h5 id="SpecifyingUserDefinedNettypeandResolutionFunction-RelatedTopics">Related Topics</h5><ul><li><a class="external-link" href="https://support.cadence.com/CadenceRedirectScreen?startURL=%2Fapex%2FArticleAttachmentPortal%3Fid%3Da1Od000000051AfEAI%26pageName%3DArticleContent%26sq%3D005d0000001T48sAAC_20181010102454985" rel="nofollow">System Verilog Real Number Modeling Overview (Video)</a></li><li><a class="external-link" href="https://support.cadence.com/apex/ArticleAttachmentPortal?id=a1Od0000000511KEAQ&amp;pageName=ArticleContent" rel="nofollow">Debug Support for Resolution Functions (Video)</a></li></ul>
                    </div>
<br /><br /></div>
<footer xmlns:html="http://www.w3.org/1999/xhtml"><nav class="navigation"><b><em><a href="Specifying_Built-In_SystemVerilog_Nettypes.html" id="prev" title="Specifying_Built-In_SystemVerilog_Nettypes">Specifying_Built-In_SystemVeri ...</a></em></b><b><em><a href="Resolving_Wreal_Nets_of_Built-In_Nettype.html" id="nex" title="Resolving_Wreal_Nets_of_Built-In_Nettype">Resolving_Wreal_Nets_of_Built- ...</a></em></b></nav><div>
          For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved.
        </div>
</footer><br xmlns:html="http://www.w3.org/1999/xhtml" />
<div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160;&#10240;</center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div>

</body></html>